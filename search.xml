<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ASCII编码</title>
    <url>/2018/02/02/ASCII%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ASCII（American Standard Code for Information Interchange，美国信息互换标准代码）是一套基于拉丁字母的字符编码，共收录了 128 个字符，用一个字节就可以存储，它等同于国际标准 ISO&#x2F;IEC 646。<br>ASCII 编码于 1967 年第一次发布，最后一次更新是在 1986 年，迄今为止共收录了 128 个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是 1234567890）、标点符号（,.!等）、特殊符号（@#$%^&amp;等）以及一些具有控制功能的字符（往往不会显示出来）。</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>字符&#x2F;缩写</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>NUL (NULL)</td>
<td>空字符</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>SOH (Start Of Headling)</td>
<td>标题开始</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
<td>2</td>
<td>STX (Start Of Text)</td>
<td>正文开始</td>
</tr>
<tr>
<td>11</td>
<td>3</td>
<td>3</td>
<td>ETX (End Of Text)</td>
<td>正文结束</td>
</tr>
<tr>
<td>100</td>
<td>4</td>
<td>4</td>
<td>EOT (End Of Transmission)</td>
<td>传输结束</td>
</tr>
<tr>
<td>101</td>
<td>5</td>
<td>5</td>
<td>ENQ (Enquiry)</td>
<td>请求</td>
</tr>
<tr>
<td>110</td>
<td>6</td>
<td>6</td>
<td>ACK (Acknowledge)</td>
<td>回应&#x2F;响应&#x2F;收到通知</td>
</tr>
<tr>
<td>111</td>
<td>7</td>
<td>7</td>
<td>BEL (Bell)</td>
<td>响铃</td>
</tr>
<tr>
<td>1000</td>
<td>8</td>
<td>8</td>
<td>BS (Backspace)</td>
<td>退格</td>
</tr>
<tr>
<td>1001</td>
<td>9</td>
<td>9</td>
<td>HT (Horizontal Tab)</td>
<td>水平制表符</td>
</tr>
<tr>
<td>1010</td>
<td>10</td>
<td>0A</td>
<td>LF&#x2F;NL(Line Feed&#x2F;New Line)</td>
<td>换行键</td>
</tr>
<tr>
<td>1011</td>
<td>11</td>
<td>0B</td>
<td>VT (Vertical Tab)</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>1100</td>
<td>12</td>
<td>0C</td>
<td>FF&#x2F;NP (Form Feed&#x2F;New Page)</td>
<td>换页键</td>
</tr>
<tr>
<td>1101</td>
<td>13</td>
<td>0D</td>
<td>CR (Carriage Return)</td>
<td>回车键</td>
</tr>
<tr>
<td>1110</td>
<td>14</td>
<td>0E</td>
<td>SO (Shift Out)</td>
<td>不用切换</td>
</tr>
<tr>
<td>1111</td>
<td>15</td>
<td>0F</td>
<td>SI (Shift In)</td>
<td>启用切换</td>
</tr>
<tr>
<td>10000</td>
<td>16</td>
<td>10</td>
<td>DLE (Data Link Escape)</td>
<td>数据链路转义</td>
</tr>
<tr>
<td>10001</td>
<td>17</td>
<td>11</td>
<td>DC1&#x2F;XON</td>
<td>设备控制1&#x2F;传输开始</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>(Device Control 1&#x2F;Transmission On)</td>
<td></td>
</tr>
<tr>
<td>10010</td>
<td>18</td>
<td>12</td>
<td>DC2 (Device Control 2)</td>
<td>设备控制2</td>
</tr>
<tr>
<td>10011</td>
<td>19</td>
<td>13</td>
<td>DC3&#x2F;XOFF</td>
<td>设备控制3&#x2F;传输中断</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>(Device Control 3&#x2F;Transmission Off)</td>
<td></td>
</tr>
<tr>
<td>10100</td>
<td>20</td>
<td>14</td>
<td>DC4 (Device Control 4)</td>
<td>设备控制4</td>
</tr>
<tr>
<td>10101</td>
<td>21</td>
<td>15</td>
<td>NAK (Negative Acknowledge)</td>
<td>无响应&#x2F;非正常响应&#x2F;拒绝接收</td>
</tr>
<tr>
<td>10110</td>
<td>22</td>
<td>16</td>
<td>SYN (Synchronous Idle)</td>
<td>同步空闲</td>
</tr>
<tr>
<td>10111</td>
<td>23</td>
<td>17</td>
<td>ETB (End of Transmission Block)</td>
<td>传输块结束&#x2F;块传输终止</td>
</tr>
<tr>
<td>11000</td>
<td>24</td>
<td>18</td>
<td>CAN (Cancel)</td>
<td>取消</td>
</tr>
<tr>
<td>11001</td>
<td>25</td>
<td>19</td>
<td>EM (End of Medium)</td>
<td>已到介质末端&#x2F;介质存储已满&#x2F;介质中断</td>
</tr>
<tr>
<td>11010</td>
<td>26</td>
<td>1A</td>
<td>SUB (Substitute)</td>
<td>替补&#x2F;替换</td>
</tr>
<tr>
<td>11011</td>
<td>27</td>
<td>1B</td>
<td>ESC (Escape)</td>
<td>逃离&#x2F;取消</td>
</tr>
<tr>
<td>11100</td>
<td>28</td>
<td>1C</td>
<td>FS (File Separator)</td>
<td>文件分割符</td>
</tr>
<tr>
<td>11101</td>
<td>29</td>
<td>1D</td>
<td>GS (Group Separator)</td>
<td>组分隔符&#x2F;分组符</td>
</tr>
<tr>
<td>11110</td>
<td>30</td>
<td>1E</td>
<td>RS (Record Separator)</td>
<td>记录分离符</td>
</tr>
<tr>
<td>11111</td>
<td>31</td>
<td>1F</td>
<td>US (Unit Separator)</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>100000</td>
<td>32</td>
<td>20</td>
<td>(Space)</td>
<td>空格</td>
</tr>
<tr>
<td>100001</td>
<td>33</td>
<td>21</td>
<td>!</td>
<td></td>
</tr>
<tr>
<td>100010</td>
<td>34</td>
<td>22</td>
<td>“”””</td>
<td></td>
</tr>
<tr>
<td>100011</td>
<td>35</td>
<td>23</td>
<td>#</td>
<td></td>
</tr>
<tr>
<td>100100</td>
<td>36</td>
<td>24</td>
<td>$</td>
<td></td>
</tr>
<tr>
<td>100101</td>
<td>37</td>
<td>25</td>
<td>%</td>
<td></td>
</tr>
<tr>
<td>100110</td>
<td>38</td>
<td>26</td>
<td>&amp;</td>
<td></td>
</tr>
<tr>
<td>100111</td>
<td>39</td>
<td>27</td>
<td>‘</td>
<td></td>
</tr>
<tr>
<td>101000</td>
<td>40</td>
<td>28</td>
<td>(</td>
<td></td>
</tr>
<tr>
<td>101001</td>
<td>41</td>
<td>29</td>
<td>)</td>
<td></td>
</tr>
<tr>
<td>101010</td>
<td>42</td>
<td>2A</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td>101011</td>
<td>43</td>
<td>2B</td>
<td>+</td>
<td></td>
</tr>
<tr>
<td>101100</td>
<td>44</td>
<td>2C</td>
<td>,</td>
<td></td>
</tr>
<tr>
<td>101101</td>
<td>45</td>
<td>2D</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>101110</td>
<td>46</td>
<td>2E</td>
<td>.</td>
<td></td>
</tr>
<tr>
<td>101111</td>
<td>47</td>
<td>2F</td>
<td>&#x2F;</td>
<td></td>
</tr>
<tr>
<td>110000</td>
<td>48</td>
<td>30</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>110001</td>
<td>49</td>
<td>31</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>110010</td>
<td>50</td>
<td>32</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>110011</td>
<td>51</td>
<td>33</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>110100</td>
<td>52</td>
<td>34</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>110101</td>
<td>53</td>
<td>35</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>110110</td>
<td>54</td>
<td>36</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>110111</td>
<td>55</td>
<td>37</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>111000</td>
<td>56</td>
<td>38</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>111001</td>
<td>57</td>
<td>39</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>111010</td>
<td>58</td>
<td>3A</td>
<td>:</td>
<td></td>
</tr>
<tr>
<td>111011</td>
<td>59</td>
<td>3B</td>
<td>;</td>
<td></td>
</tr>
<tr>
<td>111100</td>
<td>60</td>
<td>3C</td>
<td>&lt;</td>
<td></td>
</tr>
<tr>
<td>111101</td>
<td>61</td>
<td>3D</td>
<td>&#x3D;</td>
<td></td>
</tr>
<tr>
<td>111110</td>
<td>62</td>
<td>3E</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>111111</td>
<td>63</td>
<td>3F</td>
<td>?</td>
<td></td>
</tr>
<tr>
<td>1000000</td>
<td>64</td>
<td>40</td>
<td>@</td>
<td></td>
</tr>
<tr>
<td>1000001</td>
<td>65</td>
<td>41</td>
<td>A</td>
<td></td>
</tr>
<tr>
<td>1000010</td>
<td>66</td>
<td>42</td>
<td>B</td>
<td></td>
</tr>
<tr>
<td>1000011</td>
<td>67</td>
<td>43</td>
<td>C</td>
<td></td>
</tr>
<tr>
<td>1000100</td>
<td>68</td>
<td>44</td>
<td>D</td>
<td></td>
</tr>
<tr>
<td>1000101</td>
<td>69</td>
<td>45</td>
<td>E</td>
<td></td>
</tr>
<tr>
<td>1000110</td>
<td>70</td>
<td>46</td>
<td>F</td>
<td></td>
</tr>
<tr>
<td>1000111</td>
<td>71</td>
<td>47</td>
<td>G</td>
<td></td>
</tr>
<tr>
<td>1001000</td>
<td>72</td>
<td>48</td>
<td>H</td>
<td></td>
</tr>
<tr>
<td>1001001</td>
<td>73</td>
<td>49</td>
<td>I</td>
<td></td>
</tr>
<tr>
<td>1001010</td>
<td>74</td>
<td>4A</td>
<td>J</td>
<td></td>
</tr>
<tr>
<td>1001011</td>
<td>75</td>
<td>4B</td>
<td>K</td>
<td></td>
</tr>
<tr>
<td>1001100</td>
<td>76</td>
<td>4C</td>
<td>L</td>
<td></td>
</tr>
<tr>
<td>1001101</td>
<td>77</td>
<td>4D</td>
<td>M</td>
<td></td>
</tr>
<tr>
<td>1001110</td>
<td>78</td>
<td>4E</td>
<td>N</td>
<td></td>
</tr>
<tr>
<td>1001111</td>
<td>79</td>
<td>4F</td>
<td>O</td>
<td></td>
</tr>
<tr>
<td>1010000</td>
<td>80</td>
<td>50</td>
<td>P</td>
<td></td>
</tr>
<tr>
<td>1010001</td>
<td>81</td>
<td>51</td>
<td>Q</td>
<td></td>
</tr>
<tr>
<td>1010010</td>
<td>82</td>
<td>52</td>
<td>R</td>
<td></td>
</tr>
<tr>
<td>1010011</td>
<td>83</td>
<td>53</td>
<td>S</td>
<td></td>
</tr>
<tr>
<td>1010100</td>
<td>84</td>
<td>54</td>
<td>T</td>
<td></td>
</tr>
<tr>
<td>1010101</td>
<td>85</td>
<td>55</td>
<td>U</td>
<td></td>
</tr>
<tr>
<td>1010110</td>
<td>86</td>
<td>56</td>
<td>V</td>
<td></td>
</tr>
<tr>
<td>1010111</td>
<td>87</td>
<td>57</td>
<td>W</td>
<td></td>
</tr>
<tr>
<td>1011000</td>
<td>88</td>
<td>58</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>1011001</td>
<td>89</td>
<td>59</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>1011010</td>
<td>90</td>
<td>5A</td>
<td>Z</td>
<td></td>
</tr>
<tr>
<td>1011011</td>
<td>91</td>
<td>5B</td>
<td>[</td>
<td></td>
</tr>
<tr>
<td>1011100</td>
<td>92</td>
<td>5C</td>
<td>\</td>
<td></td>
</tr>
<tr>
<td>1011101</td>
<td>93</td>
<td>5D</td>
<td>]</td>
<td></td>
</tr>
<tr>
<td>1011110</td>
<td>94</td>
<td>5E</td>
<td>^</td>
<td></td>
</tr>
<tr>
<td>1011111</td>
<td>95</td>
<td>5F</td>
<td>_</td>
<td></td>
</tr>
<tr>
<td>1100000</td>
<td>96</td>
<td>60</td>
<td>&#96;</td>
<td></td>
</tr>
<tr>
<td>1100001</td>
<td>97</td>
<td>61</td>
<td>a</td>
<td></td>
</tr>
<tr>
<td>1100010</td>
<td>98</td>
<td>62</td>
<td>b</td>
<td></td>
</tr>
<tr>
<td>1100011</td>
<td>99</td>
<td>63</td>
<td>c</td>
<td></td>
</tr>
<tr>
<td>1100100</td>
<td>100</td>
<td>64</td>
<td>d</td>
<td></td>
</tr>
<tr>
<td>1100101</td>
<td>101</td>
<td>65</td>
<td>e</td>
<td></td>
</tr>
<tr>
<td>1100110</td>
<td>102</td>
<td>66</td>
<td>f</td>
<td></td>
</tr>
<tr>
<td>1100111</td>
<td>103</td>
<td>67</td>
<td>g</td>
<td></td>
</tr>
<tr>
<td>1101000</td>
<td>104</td>
<td>68</td>
<td>h</td>
<td></td>
</tr>
<tr>
<td>1101001</td>
<td>105</td>
<td>69</td>
<td>i</td>
<td></td>
</tr>
<tr>
<td>1101010</td>
<td>106</td>
<td>6A</td>
<td>j</td>
<td></td>
</tr>
<tr>
<td>1101011</td>
<td>107</td>
<td>6B</td>
<td>k</td>
<td></td>
</tr>
<tr>
<td>1101100</td>
<td>108</td>
<td>6C</td>
<td>l</td>
<td></td>
</tr>
<tr>
<td>1101101</td>
<td>109</td>
<td>6D</td>
<td>m</td>
<td></td>
</tr>
<tr>
<td>1101110</td>
<td>110</td>
<td>6E</td>
<td>n</td>
<td></td>
</tr>
<tr>
<td>1101111</td>
<td>111</td>
<td>6F</td>
<td>o</td>
<td></td>
</tr>
<tr>
<td>1110000</td>
<td>112</td>
<td>70</td>
<td>p</td>
<td></td>
</tr>
<tr>
<td>1110001</td>
<td>113</td>
<td>71</td>
<td>q</td>
<td></td>
</tr>
<tr>
<td>1110010</td>
<td>114</td>
<td>72</td>
<td>r</td>
<td></td>
</tr>
<tr>
<td>1110011</td>
<td>115</td>
<td>73</td>
<td>s</td>
<td></td>
</tr>
<tr>
<td>1110100</td>
<td>116</td>
<td>74</td>
<td>t</td>
<td></td>
</tr>
<tr>
<td>1110101</td>
<td>117</td>
<td>75</td>
<td>u</td>
<td></td>
</tr>
<tr>
<td>1110110</td>
<td>118</td>
<td>76</td>
<td>v</td>
<td></td>
</tr>
<tr>
<td>1110111</td>
<td>119</td>
<td>77</td>
<td>w</td>
<td></td>
</tr>
<tr>
<td>1111000</td>
<td>120</td>
<td>78</td>
<td>x</td>
<td></td>
</tr>
<tr>
<td>1111001</td>
<td>121</td>
<td>79</td>
<td>y</td>
<td></td>
</tr>
<tr>
<td>1111010</td>
<td>122</td>
<td>7A</td>
<td>z</td>
<td></td>
</tr>
<tr>
<td>1111011</td>
<td>123</td>
<td>7B</td>
<td>{</td>
<td></td>
</tr>
<tr>
<td>1111100</td>
<td>124</td>
<td>7C</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1111101</td>
<td>125</td>
<td>7D</td>
<td>}</td>
<td></td>
</tr>
<tr>
<td>1111110</td>
<td>126</td>
<td>7E</td>
<td>~</td>
<td></td>
</tr>
<tr>
<td>1111111</td>
<td>127</td>
<td>7F</td>
<td>DEL (Delete)</td>
<td>删除</td>
</tr>
</tbody></table>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/02/02/ASCII%E7%BC%96%E7%A0%81/">https://scholargeek.github.io/2018/02/02/ASCII%E7%BC%96%E7%A0%81/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS简介与基本语法</title>
    <url>/2019/09/01/CSS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h1><p>　　层叠样式表(Cascading Style Sheets)，缩写：CSS；又称串样式列表、级联样式表、串接样式表、阶层式样式表。是一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言，由W3C定义和维护。CSS3现在已被大部分现代浏览器支持，而下一版的CSS4仍在开发中。</p>
<span id="more"></span>

<h2 id="CSS概述"><a href="#CSS概述" class="headerlink" title="CSS概述"></a>CSS概述</h2><p>　　CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。CSS不能单独使用，必须与HTML或XML一起协同工作，为HTML或XML起装饰作用。本文主要介绍用于装饰HTML网页的CSS技术。其中HTML负责确定网页中有哪些内容，CSS确定以何种外观展现这些元素。CSS可以用于设定页面布局、设定页面元素样式、设定适用于所有网页的全局样式。CSS可以零散地直接添加在要应用样式的网页元素上，也可以集中化内置于网页、链接式引入网页以及导入式引入网页。<br>　　CSS最重要的目标是将文件的内容与它的显示分隔开来。在CSS出现前，几乎所有的HTML文件内都包含文件显示的信息，比如字体的颜色、背景应该是怎样的、如何排列、边缘、连线等等都必须一一在HTML文件内列出，有时重复列出。CSS使作者可以将这些信息中的大部分隔离出来，简化HTML文件，这些信息被放在一个辅助的，用CSS语言写的文件中。HTML文件中只包含结构和内容的信息，CSS文件中只包含样式的信息。<br>　　简而言之，CSS是一种用于装饰HTML的标记集合，是对HTML的标记扩展，可以进一步美化HTML页面以统一网页风格。</p>
<h2 id="CSS基本内容"><a href="#CSS基本内容" class="headerlink" title="CSS基本内容"></a>CSS基本内容</h2><h3 id="CSS样式表语法"><a href="#CSS样式表语法" class="headerlink" title="CSS样式表语法"></a>CSS样式表语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">RuleSelector &#123;property: value;property:value;...&#125;</span><br><span class="line"><span class="comment">&lt;!-- 规则选择器 &#123;属性:值;属性:值...&#125; --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="CSS样式信息存储位置"><a href="#CSS样式信息存储位置" class="headerlink" title="CSS样式信息存储位置"></a>CSS样式信息存储位置</h3><p>①存储在HTML文件内部，即存放在<head><style></style></head>区内，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>静夜思<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: large;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: pink;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-decoration-line</span>: underline;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.one</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-weight</span>: <span class="number">800</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.two</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-weight</span>: <span class="number">800</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>静夜思<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>床前明月光，<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span>疑是地上霜。<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>举头望明月，<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span>低头思故乡。<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>②存储在独立文件中，即存放在例如扩展名为<code>my.css</code>的文件中，可在需要美化的HTML文件中使用<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/my.css&quot; /&gt;</code>引用。如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!-- my<span class="selector-class">.css</span> --&gt;</span><br><span class="line"><span class="selector-id">#two</span> <span class="selector-class">.foolish</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">28px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#two</span> &gt; <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#one</span> &gt; <span class="selector-tag">span</span>,<span class="selector-id">#two</span> <span class="selector-class">.foolish</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">6px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS练习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./css/my.css&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;China&quot;</span> <span class="attr">class</span>=<span class="string">&quot;foolish&quot;</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>新加坡<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>美国<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>韩国<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>日本<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;foolish&quot;</span>&gt;</span>俄罗斯<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="规则选择器"><a href="#规则选择器" class="headerlink" title="规则选择器"></a>规则选择器</h3><p>规则选择器用于指定需要美化的HTML元素位置,包括:标签选择器、ID选择器、类别选择器、万用选择器、通配符选择器。</p>
<p>●标签选择器：使当前网页中所有相同的标签共享一个样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">标签名&#123;</span><br><span class="line">	属性名:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>●ID选择器：使当前网页指定ID的标签使用一个样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#id&#123;</span><br><span class="line">	属性名:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>●类别选择器：使当前网页指定的class标签为同一类以共享一个样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.class&#123;</span><br><span class="line">	属性名:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>●后代选择器：从父标签与后代标签的关系以定位到后代确定样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">父标签 后代标签(要定位的标签)&#123;</span><br><span class="line">	属性名:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>●父子选择器：从父标签定位到子标签确定样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">父标签 &gt; 子标签&#123;</span><br><span class="line">	属性名:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>●并列选择器：同时选择多个无关系的标签确定样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">标签1,标签2,标签3&#123;</span><br><span class="line">	属性名:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>●通用选择器：使当前网页所有标签添加指定样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">	属性名:值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/09/01/CSS/">https://scholargeek.github.io/2019/09/01/CSS/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习</title>
    <url>/2018/02/01/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C语言简介"><a href="#C语言简介" class="headerlink" title="C语言简介"></a>C语言简介</h1><p>C语言是1972年在美国贝尔实验室诞生，由丹尼斯●里奇、肯●汤普森设计的B语言为基础发展而来的；在该语言设计完成后，两人用它重写了UNIX系统，并使得在UNIX发展中C不断完善。于1989年诞生了第一个完备的C标准，简称“C89”，也就是“ANSI C”(美国国家标准协会制定的C标准)。它是一门面向过程的计算机编程语言，它以简易方式编译，可处理低级存储器，仅产生少量的机器码以及不需要任何运行环境支持便可运行的编程语言。与汇编相比可更快地描述问题，工作量小，可读性好，易于调试、修改和移植，代码质量相当，执行效率仅比汇编低10%~20%，因此可写系统软件。<br>发展历程： CPL→BCPL→B语言→C语言</p>
<span id="more"></span>
<p>C的成功源于可移植性，只要由那种架构对应的C编译器和库，便可将任意源代码放到这种架构上编译连接后生成目标二进制文件运行。这种可移植性使得代码可在不同架构上运行，无论是X86还是ARM。</p>
<h2 id="编译架构"><a href="#编译架构" class="headerlink" title="编译架构"></a>编译架构</h2><p><img src="https://s3.bmp.ovh/imgs/2023/01/20/9f4a1e02df30daf4.png" alt="C语言编译平台架构图"></p>
<h2 id="C语言的特点"><a href="#C语言的特点" class="headerlink" title="C语言的特点"></a>C语言的特点</h2><p>①简洁的语言（9种控制语句，32个关键字，与硬件关联少，配合各类库即可实现更多功能）<br>②结构化的控制语句<br>③丰富的数据类型（除含基本类型外，还含有最为灵活的指针类型）<br>④丰富的运算符（34个运算符）<br>⑤可对物理地址直接操作，允许对硬件内存地址进行直接读写，以实现汇编的主要功能<br>⑥代码具有较好的可移植性。<br>⑦生成的程序 高质量 高效率</p>
<h2 id="C语言与C"><a href="#C语言与C" class="headerlink" title="C语言与C++"></a>C语言与C++</h2><p>C是面向过程的语言，而C++是面向对象的语言，C++是为解决软件危机而诞生的，它提高了开发效率。早期并没有“C++”这个名字，而是成为带类的C，即C++主要是在C的基础上增加了面向对象和泛型的机制，提高了开发效率。随着C++的流行，其功能也得到完善，但并没有自己独立的编译器，编译还是通过原来C的编译器的不断扩展使之支持C++,故常称C&#x2F;C++编译器，它同时支持C和C++。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/02/01/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">https://scholargeek.github.io/2018/02/01/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS进阶内容学习</title>
    <url>/2019/09/06/CSS1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CSS进阶1"><a href="#CSS进阶1" class="headerlink" title="CSS进阶1"></a>CSS进阶1</h1><p>　　本文将表述关于盒子模型和其样式定位的内容。了解CSS盒子模型的概念、计算、以及如何设置元素的宽度和高度。</p>
<span id="more"></span>

<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>　　盒子模型(box model)又称框模型，指所有HTML元素都可以看作盒子。CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。<br><img src="https://s3.bmp.ovh/imgs/2024/03/18/eac973a675cf2eaf.jpg" alt="box-model"></p>
<p>●margin 框外位置<br>margin-top 上边界<br>margin-bottom 下边界<br>margin-left 左边界<br>margin-right 右边界</p>
<p>●padding 框内位置<br>padding-top 上填充<br>padding-bottom 下填充<br>padding-left 左填充<br>padding-right 右填充</p>
<p>●border 边框属性<br>border-top 上边框<br>border-bottom 下边框<br>border-left 左边框<br>border-right 右边框<br>border-width 边框粗细<br>border-color 边框颜色<br>border-style 边框样式</p>
<h2 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h2><p>　　定位即元素框相对于游览器窗口或父元素的位置。定位机制包括 默认、绝对定位和相对定位。其中绝对定位的参考系原点为网页左上顶点，而相对定位的参考系原点为父级元素下默认子元素原始位置左上顶点。</p>
<p>参考系坐标方向如下：<br><img src="https://s3.bmp.ovh/imgs/2024/03/18/aeb8e19606914926.png" alt="CSS参考系"></p>
<p>●position 定位属性<br>absolute 绝对定位<br>relative 相对定位</p>
<p><code>z-index</code>属性设置定位元素及其后代元素或 flex 项目的 Z 轴顺序。z-index 较大的重叠元素会覆盖较小的元素。z-index值可以为负数，默认值为0。<br><img src="https://s3.bmp.ovh/imgs/2024/03/18/857a08531f679e64.png" alt="z-index属性"></p>
<p>实列如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DIV类标签CSS修饰"><a href="#DIV类标签CSS修饰" class="headerlink" title="DIV类标签CSS修饰"></a>DIV类标签CSS修饰</h2><p>使占行标签收缩并漂移位置，使用CSS修饰属性<code>float</code>。<br>将li标签向左漂移的实列如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>标签浮动<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      li &#123;</span></span><br><span class="line"><span class="language-xml">        width: 100px;  <span class="comment">&lt;!-- 标签宽度 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        background-color: aqua;  <span class="comment">&lt;!-- 背景色 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        margin-left: 50px;  <span class="comment">&lt;!-- 左边界50像素 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        float: left;  <span class="comment">&lt;!-- 向左平移成一行 --&gt;</span></span></span><br><span class="line"><span class="language-xml">        list-style: none;  <span class="comment">&lt;!-- 无点标识 --&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>我<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>你<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>他<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/09/06/CSS1/">https://scholargeek.github.io/2019/09/06/CSS1/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习1</title>
    <url>/2018/02/03/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C语言概述"><a href="#C语言概述" class="headerlink" title="C语言概述"></a>C语言概述</h1><p>本文将描述C语言的基本构成及其特点。</p>
<span id="more"></span>
<h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>①源程序由函数构成，每个函数完成相对独立的功能。<br>②每个源程序中必须有且只能有一个主函数，可以放在任何位置，但程序总是从主函数开始执行。<br>③函数体:在函数后面用一对花括号括起来的部分。<br>④每个语句以分号结束，但预处理命令、函数头之后不能加分号。<br>⑤注释：括在“ &#x2F;* “  与  “ *&#x2F; ” 之间，没有空格，允许出现在程序的任意位置。<br>⑥预处理命令：以 # 开头的语句。</p>
<p>●自定义函数<br>库(Library)是指函数的集合，在磁盘中往往为一个文件夹。库函数(Library Function)指函数为C语言自带的集合，默认自带的有标准库，其他公司或个人开发的称为第三方库。</p>
<p>●主函数<br>一个程序必须有且只有一个main函数，它是程序的入口函数，程序从main函数开始，直到main函数结束。(当程序执行到return或函数末尾时，函数才结束)</p>
<p>●头文件<br>常用函数或库函数保存的文件，每个头文件包含若干类似功能的函数，调用头文件内函数时需引用，引用头文件有#include 命令。(早期C包含15个头文件[标准库] 如stdio.h stdlib.h)</p>
<p>从源代码生成可执行文件可分为四步：预处理(Preprocessing)、编译(Compilation)、汇编(Assembly)、链接(Linking)<br>用GCC编译流程如下图：<br>[Linux下]<br><img src="https://s3.bmp.ovh/imgs/2023/01/25/9e4b3852060b0843.png" alt="Linux下GCC编译过程"><br>[Windows下]<br><img src="https://s3.bmp.ovh/imgs/2023/01/25/e9de153952bd53d2.png" alt="Windows下GCC编译过程"></p>
<p>●预处理<br>主要处理源文件与头文件中以#开头的命令，如 #include #define #ifdef 等<br>一般规则如下：<br>①将所有的#define删除，展开所有宏定义<br>②处理所有条件编译命令，如#if #ifdef #elif #else #end 等<br>③将#include 所包含文件的内容插入当前位置，可递归<br>④删除所有注释 &#x2F;&#x2F; &#x2F;* *&#x2F;<br>⑤添加行号和文件名标识，便于调试时给出具体代码的位置<br>⑥保留所有#program 命令，因为编译器需要使用</p>
<p>●编译<br>将预处理完成的文件进行词法分析、语法分析、语义分析、优化分成相应的汇编代码文件。</p>
<p>●汇编<br>将汇编代码转化为可执行的机器指令</p>
<p>●链接<br>将引用的外部函数与变量的地址找到，将所有目标文件组织成一个可执行二进制文件。</p>
<p>C程序生成：一般先由源文件经编译生成目标文件，后经链接生成可执行文件。</p>
<h2 id="常量、变量和数据类型"><a href="#常量、变量和数据类型" class="headerlink" title="常量、变量和数据类型"></a>常量、变量和数据类型</h2><p>标识符：只能由字母、数字或下划线组成，第一个字符不能是数字、区分字母大小写。</p>
<h3 id="标识符分类"><a href="#标识符分类" class="headerlink" title="标识符分类"></a>标识符分类</h3><p>关键字：C语言规定的专用标识符，有固定含义。<br>预定义标识符：和“关键字”一样有特定含义<br>用户标识符：由用户需要定义的标识符。(见名知义，不可与关键字相同)</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在程序运行中，其值不能被改变的量(整形常量、实型常量、字符常量、字符串常量、符号常量)</p>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><table>
<thead>
<tr>
<th>进制位</th>
<th>表示范围</th>
</tr>
</thead>
<tbody><tr>
<td>十进制</td>
<td>基本数字范围0~9</td>
</tr>
<tr>
<td>八进制</td>
<td>以0开头，基本数字范围0~7</td>
</tr>
<tr>
<td>十六进制</td>
<td>以0x开头，基本数字范围0<code>~</code>F (0<code>~</code>9,A<code>~</code>F)</td>
</tr>
</tbody></table>
<h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><table>
<thead>
<tr>
<th>类别</th>
<th>表示形式</th>
</tr>
</thead>
<tbody><tr>
<td>小数形式</td>
<td>以小数点分隔左右两边为十进制数</td>
</tr>
<tr>
<td>指数形式</td>
<td>e前必须有数字，e后必须为整数</td>
</tr>
</tbody></table>
<p>用单引号括起来如’A’表示ASCII码字符集里的字符，即字符常量<br>用双引号括起来如“Hello”表示字符串</p>
<p>转义字符(特殊字符常量)以“\”打头，代表不同意思</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠\</td>
</tr>
<tr>
<td>\ddd</td>
<td>1<code>~</code>3位八进制数 代表一个ASCII字符  最大\177</td>
</tr>
<tr>
<td>\xhh</td>
<td>1<code>~</code>2位十六进制数 代表一个ASCII字符  最大\7f</td>
</tr>
</tbody></table>
<p>符号常量 由预处理“#define”定义的常量，可用标识符表示的一个常量。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>值可以改变的量(整型变量、实型变量、字符变量)  使用前必须先定义变量名</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>字符型</th>
<th>短整型</th>
<th>整型</th>
<th>长整型</th>
<th>单精度浮点型</th>
<th>双精度浮点型</th>
<th>无类型</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>char</td>
<td>short</td>
<td>int</td>
<td>long</td>
<td>float</td>
<td>double</td>
<td>void</td>
</tr>
<tr>
<td>32位环境下长度</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td></td>
</tr>
</tbody></table>
<p><em><strong>强类型语言</strong></em>：一旦确定类型，就不能赋值到其他类型，除非转换数据类型，C语言属于强类型语言<br><em><strong>弱类型语言</strong></em>：定义时不必指明数据类型，系统会自动推演类型</p>
<h3 id="类型的自动转换和强制转换"><a href="#类型的自动转换和强制转换" class="headerlink" title="类型的自动转换和强制转换"></a>类型的自动转换和强制转换</h3><p>自动转换规则(编译器自动进行的数据类型转换):<br>①按长度增加方向进行，以保证数值不失真，或精度不降低<br>②所有浮点运算以双精度进行，只有float也要转换为double才能运算<br>③char、short参与运算先转换为int<br><img src="https://s3.bmp.ovh/imgs/2023/01/26/a7cc37f690aa5298.png" alt="类型自动转换规则"></p>
<p>强制转换规则(程序员在代码中明确转换):<br>表达格式<br>    (type_name)expression<br>    (类型)(表达式)<br>用于防止数据失真，如两整数相除结果为小数时，需将两除数强制转换为小数以使得结果为小数。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/02/03/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A01/">https://scholargeek.github.io/2018/02/03/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A01/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习0</title>
    <url>/2018/02/02/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A00/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常识内容"><a href="#常识内容" class="headerlink" title="常识内容"></a>常识内容</h1><p>本文将讲述计算机常识内容，常识学习有利于计算机语言的理解。</p>
<span id="more"></span>
<h2 id="数据存储单位"><a href="#数据存储单位" class="headerlink" title="数据存储单位"></a>数据存储单位</h2><p>内存是随机存储器，是无数个元器件形成的电路，只能表示二进制。单个元器件为1bit(比特)<br>8 bit &#x3D; 1 Byte 一字节<br>1024 B &#x3D; 1 KB （KiloByte） 千字节<br>1024 KB &#x3D; 1 MB （MegaByte） 兆字节<br>1024 MB &#x3D; 1 GB （GigaByte） 吉字节<br>1024 GB &#x3D; 1 TB （TeraByte） 太字节<br>1024 TB &#x3D; 1 PB （PetaByte） 拍字节<br>1024 PB &#x3D; 1 EB （ExaByte） 艾字节<br>1024 EB &#x3D; 1 ZB （ZetaByte） 泽字节<br>1024 ZB &#x3D; 1 YB （YottaByte） 尧字节<br>1024 YB &#x3D; 1BB （Brontobyte）珀字节<br>1024 BB &#x3D; 1 NB （NonaByte） 诺字节<br>1024 NB &#x3D; 1 DB （DoggaByte）刀字节</p>
<h2 id="载入内存运行程序"><a href="#载入内存运行程序" class="headerlink" title="载入内存运行程序"></a>载入内存运行程序</h2><p>通过加载器(Loader)将硬盘上保存的程序文件复制到内存中，让CPU执行。<br><img src="https://s3.bmp.ovh/imgs/2023/01/25/c621a04599983078.png" alt="载入内存运行程序"></p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>字符为了达到通用性和规范性在计算机领域中发展出了字符集和字符编码。<br>最早专门为英文表达的字符集——ASCII编码 是基于拉丁字母的电脑编码，用于显示现代英语和其他西欧语言，即 (美国信息交换标准代码) 由美国国家标准学会制定。ASCII(American Standard Code for Information Interchange)已成为计算机通用标准。</p>
<p>常见字符编码(由ASCII编码主导，其他通用编码由此扩展而来，以保持兼容)</p>
<table>
<thead>
<tr>
<th>编码方案</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>ISO&#x2F;IEC 8859</td>
<td>欧洲字符集，支持丹麦语、荷兰语、德语、意大利语、拉丁语、挪威语、葡萄牙语、西班牙语、瑞典语 等（1987年首次发布），其主要在ASCII基础上衍生拉丁字母以支持欧洲多国所用的扩展拉丁字母</td>
</tr>
<tr>
<td>Shift_Jis</td>
<td>日语字符集，包含全角及半角拉丁字母，平假名、片假名、符号及日语汉字，1978年首发</td>
</tr>
<tr>
<td>Big5</td>
<td>繁体中文字符集，1984年发布，通行于台湾、香港等地区，收录了13053个中文汉字、408个普通字符、及33个控制字符</td>
</tr>
<tr>
<td>GB2312</td>
<td>简体中文字符集，1980年发布，共收录6763个汉字，其中一级汉字3755个，二级汉字3008个，同时收录了包括拉丁字母、希腊字母、日文平假名及片假名，俄语西里尔字母在内的682个字符</td>
</tr>
<tr>
<td>GBK</td>
<td>中文字符集，是在GB2312的基础上进行的扩展，1995年发布。GB2312收录了大陆99.75%使用频率的汉字，但有些人名及古汉语中的罕用字并不能处理，所以将GB2312进行扩展即GBK,GBK共收录了21886个汉字和图形符号，包括GB2312中全部汉字、非汉字符号、及GBK中全部繁体字及生僻字</td>
</tr>
<tr>
<td>GB18030</td>
<td>中文字符集，对GBK和GB2312又一次扩展，2000年发布。共收录了70244个汉字，支持国内少数民族的文字，及日语韩语中的汉字</td>
</tr>
<tr>
<td>UTF-8</td>
<td>变长编码方案，使用1~6个字节存储(一个字节最高为0，多字节时按首字节最高位的1的个数判断占几个字节)</td>
</tr>
<tr>
<td>UTF-32</td>
<td>一种固定长度编码方案，使用4个字节存储</td>
</tr>
<tr>
<td>UTF-16</td>
<td>变长且固定的编码方案，使用2或4个字节存储(0<code>~</code>FFF内按两个字节存储，10000<code>~</code>10FFFF按四个字节存储)</td>
</tr>
</tbody></table>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/02/02/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A00/">https://scholargeek.github.io/2018/02/02/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A00/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习10</title>
    <url>/2018/02/20/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A010/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>本文将详述C语言中关于文件的相关知识。</p>
<span id="more"></span>

<p>文件是数据源的一种，主要的作用是保存数据。<br>在操作系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。列如:<br>●通常把显示器称为标准输出文件，printf就是向这个文件输出数据。<br>●通常把键盘称为标准输入文件，scanf就是从这个文件读取数据。<br><strong>常见输出设备对应的文件:</strong></p>
<table>
<thead>
<tr>
<th>文件</th>
<th>硬件设备</th>
</tr>
</thead>
<tbody><tr>
<td>stdin</td>
<td>标准输入文件，一般指键盘: scanf() getchar()…</td>
</tr>
<tr>
<td>stdout</td>
<td>标准输入文件，一般指显示器 print() putchar()等</td>
</tr>
<tr>
<td>stderr</td>
<td>标准错误文件，一般指显示器;perror()等</td>
</tr>
<tr>
<td>stdprn</td>
<td>标准打印文件，一般指打印机</td>
</tr>
</tbody></table>
<p>C语言把文件分为ASCII文件和二进制文件。ASCII文件又称文本文件。<br>文件流：指数据在文件和内存之间传递的过程。<br>输入流：指数据从文件复制到内存的过程。<br>输出流：从内存保存到文件的过程。</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/02/04/57986c1e9fc1daa4.png" alt="文件与内存的关系"></p>
<p>数据流(Data Stream):指数据在数据源和程序(内存)之间传递的过程。<br>输入流(Input Stream):数据从数据源到(内存)程序的过程。<br>输出流(Output Stream):数据从程序(内存)到数据源的过程。<br>文件输入输出方式也称”存取方式”。C语言中，文件有两种存取方式：顺序存取和直接存取。</p>
<h2 id="文件类型指针"><a href="#文件类型指针" class="headerlink" title="文件类型指针"></a>文件类型指针</h2><p>可以用结构体类型来定义文件类型的指针变量，一般形式为：<br>    FILE *fp;<br>fp是一个指向FILE结构体类型的指针变量。</p>
<h2 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h2><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>1.调用形式:<br>    FILE *fp &#x3D; fopen(文件名,文件使用方式);<br>●函数返回一个指向FILE类型的指针。<br>●无论哪种使用方式，当打开文件时出现错误，fopen函数都将返回NULL。</p>
<p>2.常用文件打开方式及说明:<br>【控制读写权限(必须指明)】</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以”只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败。</td>
</tr>
<tr>
<td>w</td>
<td>以”写入”方式打开文件。如果文件不存在，那么创建一个新文件，如果文件存在，那么清空文件内容(相当于删除源文件，再创建一个新文件。)</td>
</tr>
<tr>
<td>a</td>
<td>以”追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件末尾(文件原有的内容保留)</td>
</tr>
<tr>
<td>r+</td>
<td>以读写方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败。</td>
</tr>
<tr>
<td>w+</td>
<td>以”写入&#x2F;更新”方式打开文件，相当于w和r+叠加的效果。首先建立一个新文件，进行写操作，随后可以从头开始读。如果指定文件已存在，则原有内容会被清空。</td>
</tr>
<tr>
<td>a+</td>
<td>以”追加&#x2F;更新”方式打开文件，相当于a和r+叠加的效果。既可以读也可写，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件末尾。</td>
</tr>
</tbody></table>
<p>【控制读写方式(可省略)】</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>“t”</td>
<td>文本文件。如果不写，默认为”t”。</td>
</tr>
<tr>
<td>“b”</td>
<td>二进制文件</td>
</tr>
</tbody></table>
<p>●调用fopen()函数时必须指明读写权限，但是可以不指明读写方式(此时默认为”t”)<br>●读写权限和读写方式可以组合使用，但必须以读写权限开头。<br>●整体来说，文件打开方式由r、w、a、t、b、+等6个字符拼成，各字符含义如下：</p>
<table>
<thead>
<tr>
<th>r(read)</th>
<th>w(write)</th>
<th>a(append)</th>
<th>t(text)</th>
<th>b(banary)</th>
<th>+</th>
</tr>
</thead>
<tbody><tr>
<td>读</td>
<td>写</td>
<td>追加</td>
<td>文本文件</td>
<td>二进制文件</td>
<td>读和写</td>
</tr>
</tbody></table>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>文件一旦使用完毕，应该用fclose()函数把文件关闭，以释放相关资源，避免数据丢失。<br>1.fclose()的用法为:<br>    int fclose(FILE *fp);<br>fp为文件指针，如 fclose(fp);</p>
<p>2.使用说明:<br>●若对文件的操作方式为”读”方式，则经以上函数调用之后，要使文件指针与文件脱离联系。可以重新分配文件指针去指向其他文件。<br>●若对文件的操作方式为”写”方式，则系统首先把该文件缓冲区中的剩余数据全部输出到文件中，然后使文件指针与文件脱离联系。<br>●在完成了对文件的操作后，应当关闭文件，否则文件缓冲区中剩余数据就会丢失。<br>●当执行了关闭操作后，成功则函数返回0，否则返回非0。</p>
<h2 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h2><h3 id="以字符形式读写文件"><a href="#以字符形式读写文件" class="headerlink" title="以字符形式读写文件"></a>以字符形式读写文件</h3><p>以字符形式读写文件时，每次可以从文件读取一个字符，或者向文件中写入一个字符。主要使用两个函数，分别是fgetc()和fputc()。<br>◆字符读取函数fgetc():<br>fgetc是 file get char的缩写，意为从指定文件中读取一个字符。<br>一般形式： int fgetc(FILE *fp);<br>fp为文件指针；fgetc()读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回EOF.<br>EOF(End of File)表示文件末尾，是在stdio.h中定义的宏，它的值往往为-1是负数。</p>
<p>在读取文件时，文件内部由系统设置一个位置指针，用于指向当前读写的位置；在文件打开时总是指向文件中的第一个字节，每次fgetc()使用后该位置指针会向后移动一个字节，所以可以连续使用fgetc()读取多个字符。</p>
<p>【程序示例】在屏幕上显示<code>D:\\demo.txt</code>文件的内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line"><span class="comment">//如果文件不存在，给出提示并退出</span></span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">&quot;D:\\demo.txt&quot;</span>,<span class="string">&quot;rt&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Fail to open file!&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次读取一个字节，直到读取完毕</span></span><br><span class="line"><span class="keyword">while</span>((ch=fgetc(fp))!=EOF)&#123;</span><br><span class="line">	<span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//输出换行符</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对EOF的说明：EOF本意指文件末尾，但读取文件出错时也会返回EOF。<br>要进一步判断读取状态可借助stdio.h中的feof()和ferror()函数。</p>
<p>feof()函数：用于判断文件内部指针是否指向末尾，当指向文件末尾时返回非零值，否则返回为0。<br>一般形式：<br>    int feof(FILE *fp);<br>ferror()函数：用于判断文件操作是否出错，当文件操作出错时返回非零值，否则返回为0。<br>一般形式：<br>    int ferror(FILE *fp);<br>◆字符写入函数fputc():<br>fputc 是file output char 的缩写，意为向指定文件写入一个字符。<br>一般形式：<br>    int fputc(int ch,FILE *fp);<br>ch为要写入的字符，fp为文件指针。fputc()写入成功时返回写入的字符，失败时返回EOF,返回值类型为int即可容纳这个值(负数)。<br>　　语句示列：把字符’a’写入fp所指向的文件中<br>    fputc(‘a’,fp);    或    char ch&#x3D;’a’;  fputc(ch,fp);<br>【程序示例】从键盘输入一行字符，写入文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line"><span class="comment">//判断文件是否打开成功</span></span><br><span class="line"><span class="keyword">if</span>(（fp=fopen(<span class="string">&quot;D:\\demo.txt&quot;</span>,<span class="string">&quot;wt+&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Fail to open file!&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input a string:\n&quot;</span>);</span><br><span class="line"><span class="comment">//每次从键盘读取一个字符并写入文件</span></span><br><span class="line"><span class="keyword">while</span>((ch=getchar())!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">	fputc(ch,fp);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fgetc()和fputc()函数每次只能读写一个字符，速度较慢；实际开发中往往读写字符串或数据块。</p>
<h3 id="以字符串形式读写文件"><a href="#以字符串形式读写文件" class="headerlink" title="以字符串形式读写文件"></a>以字符串形式读写文件</h3><p>◆读取字符串函数fgets():<br>fgets()函数用来指定文件中读取一个字符串，并保存到字符数组中。<br>一般形式：<br>    char *fgets(char *str,int n,FILE *fp);<br>str为字符数组，n为要读取的字符数目，fp为文件指针。<br>返回值：读取成功时返回字符数组首地址，也即str;读取失败时返回NULL;如果开始读取文件内部指针已指向了末尾，那么读取不到任何文字，也返回NULL。<br>▲注意：读取到的字符串会在末尾自动添加’\0’，n个字符有n+1个长度，遇到换行符会一并读取到字符串。</p>
<p>【程序示例】一行一行地读取文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="type">char</span> str[N+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">&quot;d:\\demo.txt&quot;</span>,<span class="string">&quot;rt&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Fail to open file!&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fgets(str,N,fp)!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>◆写字符串函数fputs():<br>fputs()函数用来向指定的文件写入一个字符串。<br>一般形式为：<br>    int fputs(char *str,FILe *fp);<br>str为要写入的字符串，fp为文件指针。写入成功则返回非负数，否则返回EOF。</p>
<p>【程序示例】向<code>d:\\demo.txt</code>文件中追加一个字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="type">char</span> str[<span class="number">102</span>]=&#123;<span class="number">0</span>&#125;,strTemp[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">&quot;D:\\demo.txt&quot;</span>,<span class="string">&quot;at+&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Fail to open file!&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input a string:&quot;</span>);</span><br><span class="line">gets(strTemp);</span><br><span class="line"><span class="built_in">strcat</span>(str,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcat</span>(str,strTemp);</span><br><span class="line"><span class="built_in">fputs</span>(str,fp);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="以数据块的形式读写文件"><a href="#以数据块的形式读写文件" class="headerlink" title="以数据块的形式读写文件"></a>以数据块的形式读写文件</h3><p>如果需要读取多行内容，需要使用fread()函数；相应地写入函数为fwrite()。<br>数据块:即若干个字节的数据，可以是一个字符、一个字符串或多行数据，并没有什么限制。<br>fread()原型:<br>    size_t fread(void *ptr,size_t size,size_t count,FILE *fp);<br>fwrite()原型:<br>    size_t fwrite(void *ptr,size_t size,size_t count,FILE <em>fp);<br>说明：<br>●ptr为内存区块的指针，它可以是数组、变量、结构体等。fread()中的ptr用来存放读取到的数据，而fwrite()中的ptr用来存放要写入的数据。<br>●size表示每个数据块的字节数<br>●count表示要读写的数据块的块数。<br>●fp表示文件指针<br>●理论上每次读写 size</em>count个字节的数据<br>●size_t是typedef定义的无符号整型数据类型，表示数量。<br>●返回值：返回成功读写的块数，也即count。<br><strong>若返回值小于count:</strong></p>
<table>
<thead>
<tr>
<th>fwrite()</th>
<th>fread()</th>
</tr>
</thead>
<tbody><tr>
<td>肯定发生了写入错误，可用ferror()函数检测</td>
<td>可能读到了文件末尾，可能发生了错误，可用ferror()、feof()检测</td>
</tr>
</tbody></table>
<p>rewind(fp):将文件中的指针重新定位到文件开头。</p>
<p>【程序示例】从键盘输入两个学生数据，写入一个文件中，再次读出这两个学生数据到屏幕上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>]; <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">	<span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125;boya[N],boyb[N],*pa,*pb;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">pa = boya;</span><br><span class="line">pb = boyb;</span><br><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">&quot;d:\\demo.txt&quot;</span>,<span class="string">&quot;wb+&quot;</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Fail to open file!&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从键盘输入数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input data:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++,pa++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %d %d %f&quot;</span>,pa-&gt;name,&amp;pa-&gt;num,&amp;pa-&gt;age,&amp;pa-&gt;score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数组数据写入文件</span></span><br><span class="line">fwrite(boya,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu),N,fp);</span><br><span class="line"><span class="comment">//将文件指针重置到文件开头</span></span><br><span class="line">rewind(fp);</span><br><span class="line"><span class="comment">//从文件读取数据并保存到数据boyb</span></span><br><span class="line">fread(boyb,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu),N,fp);</span><br><span class="line"><span class="comment">//输出数组boyb中的数据</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++,pb++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %f\n&quot;</span>,pb-&gt;name,pb-&gt;num,pb-&gt;age,pb-&gt;score);</span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="格式化读写文件"><a href="#格式化读写文件" class="headerlink" title="格式化读写文件"></a>格式化读写文件</h3><p>以磁盘文件作为读写对象的格式化读写函数fscanf()和fprintf()。<br>一般形式:<br>    int  fscanf(FILE *fp,char *format,…);<br>    int  fprintf(FILE *fp,char *format,…);<br>fp为文件指针，format为格式控制字符串，…表示参数列表。<br>返回值：<br>fprintf()返回成功写入字符的个数，失败则返回负数。<br>fscanf()返回参数列表中被成功赋值的参数个数。</p>
<h3 id="随机读写文件"><a href="#随机读写文件" class="headerlink" title="随机读写文件"></a>随机读写文件</h3><p>所谓随机读写指移动文件内部的位置指针后再进行读写。经常用于实际开发中读取文件的中间部分。<br>实现随机读写的关键是按要求移动位置指针，这称为文件的定位。<br>rewind()函数用于将位置指针移动到文件开头，原型为:<br>    void rewind(FILE *fp);<br>fseek()函数用于将位置指针移动到任意位置，它的原型为:<br>    int fseek(FILE *fp,long offset,int origin);<br>说明:<br>●fp为文件指针<br>●offset为偏移量，也就是要移动的字节数。offset为正，向后移动；为负，向前移动。<br>●origin为起始位置，也就是从何处开始计算偏移量。C语言的起始位置有以下三种，如下:</p>
<table>
<thead>
<tr>
<th>起始位置</th>
<th>常量名</th>
<th>常量值</th>
</tr>
</thead>
<tbody><tr>
<td>文件开头</td>
<td>SEEK_SET</td>
<td>0</td>
</tr>
<tr>
<td>当前位置</td>
<td>SEEK_CUR</td>
<td>1</td>
</tr>
<tr>
<td>文件末尾</td>
<td>SEEK_END</td>
<td>2</td>
</tr>
</tbody></table>
<p>●fseek一般用于二进制文件。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/02/20/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A010/">https://scholargeek.github.io/2018/02/20/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A010/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习3</title>
    <url>/2018/02/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h1><span id="more"></span>
<h2 id="单个字符的输入与输出"><a href="#单个字符的输入与输出" class="headerlink" title="单个字符的输入与输出"></a>单个字符的输入与输出</h2><h3 id="字符输出函数putchar"><a href="#字符输出函数putchar" class="headerlink" title="字符输出函数putchar()"></a>字符输出函数putchar()</h3><p>putchar() 函数的作用是向终端输入一个字符。</p>
<h3 id="字符输入函数getchar"><a href="#字符输入函数getchar" class="headerlink" title="字符输入函数getchar()"></a>字符输入函数getchar()</h3><p>getchar()函数的作用是从终端输入一个字符。<br>getchar()函数没有参数，其函数值为从输入设备得到的字符。</p>
<h2 id="数据格式的输入与输出"><a href="#数据格式的输入与输出" class="headerlink" title="数据格式的输入与输出"></a>数据格式的输入与输出</h2><h3 id="格式化输出函数"><a href="#格式化输出函数" class="headerlink" title="格式化输出函数"></a>格式化输出函数</h3><p>printf()函数是C语言提供的标准输出函数，它的作用是向终端(或系统隐含指定的输出设备)按指定格式输出若干个数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(格式控制,输出列表);</span><br></pre></td></tr></table></figure>
<p>①”格式控制”：用双引号括起来的字符串是”格式控制”字符串，它包含以下两种信息。<br>●格式转换说明，由”%”和格式字符组成<br>●需要原样输出的字符也写在格式控制内<br>②”输出列表”：需要输出的一些数据，可以是常量、变量或表达式。输出列表中各输出项用逗号隔开。</p>
<p>可在“%”与格式字符之间输入”宽度说明”，左对齐符号”-“,前导符号”0”等。</p>
<table>
<thead>
<tr>
<th>格式字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>d</td>
<td>用来对十进制进行输入输出</td>
</tr>
<tr>
<td>o</td>
<td>以八进制数形式输出整数</td>
</tr>
<tr>
<td>x</td>
<td>以十六进制数形式输出整数</td>
</tr>
<tr>
<td>u</td>
<td>用来输出unsigned型数据，即输出无符号的十进制数</td>
</tr>
<tr>
<td>c</td>
<td>用来输出一个字符</td>
</tr>
<tr>
<td>s</td>
<td>用来输出一个字符串</td>
</tr>
<tr>
<td>f</td>
<td>用来输出实数(单、双精度)，以小数形式输出，完全输出整数部分</td>
</tr>
<tr>
<td>e</td>
<td>以指数形式输出实数</td>
</tr>
<tr>
<td>g</td>
<td>自动以最短表达形式输出实数</td>
</tr>
</tbody></table>
<p>●格式控制串中，格式说明与输出项从左到右，在类型上必须一一对应匹配。<br>●在格式控制串中，格式说明与输出项个数要相等。<br>●在格式控制串中，可以包含任意的合法字符(包括转义字符),在输出它们时将原样输出。<br>●如果输出%，则应在格式控制串用两个连续的百分号“%%”表示。</p>
<p>printf() 格式控制符形式 %[flag][width][.precision]type<br>type:输出类型 如 %d %f %c %lf<br>width:最小输出宽度 至少占几个字符的位置[整体]<br>precision:输出小数精度。(当小数部分位数大于它时,会按四舍五入原则丢掉多于的数字；当小于它时则在其后补0)<br>用于整数时，precision表示最小输出宽度，与width不同 整数宽度将会在最左边补0<br>用于字符时，precision表示最大输出宽度，截取多于宽度的字符。<br>flag:标志字符</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>表示左对齐，如果没有，默认右对齐</td>
</tr>
<tr>
<td>+</td>
<td>表示输出符号(正负号)，若没有默认仅负数时输出符号</td>
</tr>
<tr>
<td>空格</td>
<td>值为正加空格，值为负默认负号</td>
</tr>
<tr>
<td>#</td>
<td>表示八、十六进制前缀(八进制前缀为0，十六进制前缀为0x),无论实数、有无小数皆在后面加小数点。</td>
</tr>
</tbody></table>
<h3 id="格式化输入函数"><a href="#格式化输入函数" class="headerlink" title="格式化输入函数"></a>格式化输入函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(格式控制，地址表列);</span><br></pre></td></tr></table></figure>
<p>其中scanf是函数名，”格式控制”的含义与printf()中相同。<br>“地址表列”，由若干变量地址组成，既可以是变量地址，也可以是字符串的首地址。<br>scanf()函数中的格式说明也是以%开始，以一个格式字符结束，中间可以加入附加字符。<br>●对unsigned型变量，可以用%d %o %x 格式输入<br>●在scanf()函数中格式字符前可以用一个整数指定输入数据所占宽度，但对输入实型数不能指定其小数位宽度。<br>●在格式控制串、格式说明的个数应该与输入项的个数相等，且要类型匹配。<br>●scanf()函数中的输入项只能是地址表达式，而不能是变量名或其它内容。<br>●如果在”格式控制”字串中除了格式说明以外还有其它字符，则在输入数据时应输入与这些字符相同的字符。<br>●在用”%c”格式输入字符时，空格字符和转义字符都可以作为有效字符输入。<br>●在输入数据时，若实际输入数据少于输入项个数，scanf()函数会等待输入，直到满足条件或遇到非法字符才结束，若实际输入数据多于输入项个数，多于数据将留在缓冲区备用，作为下一次输入操作的数据。<br>●在输入数据时，遇到以下情况时认为输入结束：空格、回车、跳格(Tab)</p>
<p>scanf() 读取字符串时遇空格则结束，不会读取空格后的字符串。<br>scanf() 格式控制符形式: %{*}{width}type<br>type:表示读取数据的类型，如:%d %s %[a-z] %[<code>^\n</code>] 等<br>width表示 最大读取宽度(可有可无)<br>*表示丢弃读取到的数据(可有可无)</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/02/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A03/">https://scholargeek.github.io/2018/02/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A03/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习2</title>
    <url>/2018/02/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h1><span id="more"></span>
<h2 id="C语言运算符简述"><a href="#C语言运算符简述" class="headerlink" title="C语言运算符简述"></a>C语言运算符简述</h2><h3 id="运算符简介"><a href="#运算符简介" class="headerlink" title="运算符简介"></a>运算符简介</h3><p>算术运算符：+  -  *  &#x2F;  %<br>关系运算符：&gt;  &gt;&#x3D;  &#x3D;&#x3D;  !&#x3D;  &lt;  &lt;&#x3D;<br>位运算符：&gt;&gt;  &lt;&lt;  ~  &amp;  |  ^<br>逻辑运算符：！  ||  &amp;&amp;<br>条件运算符：？ ：<br>指针运算符：&amp;  *<br>赋值运算符：&#x3D;<br>逗号运算符：,<br>字节运算符：sizeof<br>强制运算符：(类型名)(表达式)</p>
<h3 id="运算符的结合性和优先级"><a href="#运算符的结合性和优先级" class="headerlink" title="运算符的结合性和优先级"></a>运算符的结合性和优先级</h3><p>　　所有的单目运算符、条件运算符、赋值运算符其扩展运算符，结合方向都是从右向左，其余运算符的结合方向为从左向右。<br>    初等运算符&gt;单目运算符&gt;算术运算符(先乘除再加减)&gt;关系运算符&gt;逻辑运算符(不含！)&gt;条件运算符&gt;赋值运算符&gt;逗号运算符<br>其中 初等运算符即：圆括号()、下标运算符[]、结构体成员运算符-&gt;</p>
<h3 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h3><p>1.可以利用强制类型转换符将一个表达式转换成所需类型。<br>2.一般形式 (类型名)(表达式)</p>
<h3 id="逗号运算符和逗号表达式"><a href="#逗号运算符和逗号表达式" class="headerlink" title="逗号运算符和逗号表达式"></a>逗号运算符和逗号表达式</h3><p>1.逗号表达式：用逗号运算符将几个表达式连接起来。<br>2.一般形式：表达式1，表达式2，···，表达式n<br>3.求解过程：先求解表达式1，然后依次求解表达式2，直到表达式n的值。<br>表达式n的值即为整个逗号表达式的值。</p>
<h2 id="算数运算符和算术表达式"><a href="#算数运算符和算术表达式" class="headerlink" title="算数运算符和算术表达式"></a>算数运算符和算术表达式</h2><h3 id="基本的算术运算符"><a href="#基本的算术运算符" class="headerlink" title="基本的算术运算符"></a>基本的算术运算符</h3><p>1.分类： + (加法运算符或正值运算符)    - (减法运算符或负值运算符)    * (乘)    &#x2F; (除)    % (取余)<br>其中“%”运算的两端必须为整数，其余运算对象可以是整形或实型。<br>2.运算符两边数值必须一致才能进行运算，若不一致系统会自动进行类型转换(向长度方向增加进行)<br>3.所有实数的运算都是以双精度方式进行的，若是单精度数值，则需要在尾数后补0转换为双精度数。</p>
<h3 id="算术表达式和运算符的优先级与结合性"><a href="#算术表达式和运算符的优先级与结合性" class="headerlink" title="算术表达式和运算符的优先级与结合性"></a>算术表达式和运算符的优先级与结合性</h3><p>1.定义：用算术运算符和括号将运算量连接起来，符合C语言语法规则的表达式。<br>2.运算对象：函数、常量、变量···<br>3.运算规则</p>
<table>
<thead>
<tr>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>可使用多层圆括号，但括号必须配对。运算时由内向外依次计算各表达式的值。</td>
</tr>
<tr>
<td>对于不同优先级的运算符，按运算符的优先级由高到低进行运算，若优先级相同，则按结合方向进行运算。</td>
</tr>
<tr>
<td>若运算符两侧的操作数类型不同，则先利用自动转换或强制类型转换，再运算。</td>
</tr>
</tbody></table>
<h3 id="自加、自减运算符"><a href="#自加、自减运算符" class="headerlink" title="自加、自减运算符"></a>自加、自减运算符</h3><p>1.作用：“++”(自加运算符) 使运算变量的值增1，“–”(自减运算符) 使运算变量的值减1。<br>2.均是单目运算符。运算对象可以是整形或实型变量，但不可以是常量和表达式。<br>3.作为前缀或后缀与变量构成一个表达式。<br>4.结合方向：自右向左</p>
<h2 id="赋值运算符和赋值表达式"><a href="#赋值运算符和赋值表达式" class="headerlink" title="赋值运算符和赋值表达式"></a>赋值运算符和赋值表达式</h2><h3 id="赋值运算符和赋值表达式-1"><a href="#赋值运算符和赋值表达式-1" class="headerlink" title="赋值运算符和赋值表达式"></a>赋值运算符和赋值表达式</h3><p>1.”&#x3D;”称做赋值运算符，作用是将一个数值赋给一个变量或将一个变量的值赋给另一个变量，由赋值运算符组成的表达式称为赋值表达式。<br>2.一般形式：变量名 &#x3D; 表达式</p>
<table>
<thead>
<tr>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>赋值运算符的优先级别高于逗号运算符</td>
</tr>
<tr>
<td>赋值运算符“&#x3D;”和等于运算符“&#x3D;&#x3D;”不同</td>
</tr>
<tr>
<td>赋值运算符的左侧只能是变量，而不能是常量或表达式。右侧可以是表达式，包括赋值表达式</td>
</tr>
<tr>
<td>规定最左边变量得到的新值即为整个赋值表达式的值。</td>
</tr>
</tbody></table>
<h3 id="复合的赋值运算符"><a href="#复合的赋值运算符" class="headerlink" title="复合的赋值运算符"></a>复合的赋值运算符</h3><p>在赋值运算符之前加上其它运算符可构成复合赋值运算符</p>
<table>
<thead>
<tr>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>两个符号之间不可有空格</td>
</tr>
<tr>
<td>复合赋值运算符的优先级与赋值运算符相同</td>
</tr>
</tbody></table>
<h3 id="赋值运算中的类型转换"><a href="#赋值运算中的类型转换" class="headerlink" title="赋值运算中的类型转换"></a>赋值运算中的类型转换</h3><p>如果赋值运算符两侧的类型不一致，在赋值前系统将自动先把右侧表达式求得的数值按赋值号左边变量的类型进行转换(也可强制转换)</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="位运算符及含义"><a href="#位运算符及含义" class="headerlink" title="位运算符及含义"></a>位运算符及含义</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&amp; (按位与)</td>
<td>若两个相应的二进制位都为1，则该位结果为1，否则为0</td>
</tr>
<tr>
<td>&#96;</td>
<td>&#96; (按位或)</td>
</tr>
<tr>
<td>^ (按位异或)</td>
<td>若两个二进制位相同，则结果为0，不同则为1</td>
</tr>
<tr>
<td>~ (按位取反)</td>
<td>即0变1,1变0</td>
</tr>
<tr>
<td>&lt;&lt; (左移)</td>
<td>将一个数的二进制位全部左移若干位</td>
</tr>
<tr>
<td>&gt;&gt; (右移)</td>
<td>将一个数的二进制位全部右移若干位</td>
</tr>
</tbody></table>
<p>▲以上除”~”之外，均为双目运算符，要求两侧各有一个运算量，且运算量只能是整型或字符型数据，不能为实型数据。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/02/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02/">https://scholargeek.github.io/2018/02/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习5</title>
    <url>/2018/02/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A05/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>本文将描述数组的定义与应用、字符串处理等知识。</p>
<span id="more"></span>

<h2 id="一维数组的定义和引用"><a href="#一维数组的定义和引用" class="headerlink" title="一维数组的定义和引用"></a>一维数组的定义和引用</h2><h3 id="一维数组的定义"><a href="#一维数组的定义" class="headerlink" title="一维数组的定义"></a>一维数组的定义</h3><p>一维数组是指数组中的每一个元素只带有一个下标的数组。定义方式：类型说明符 数组名[常量表达式]</p>
<h3 id="一维数组元素的引用"><a href="#一维数组元素的引用" class="headerlink" title="一维数组元素的引用"></a>一维数组元素的引用</h3><p>数组元素的引用形式为：数组名[下标表达式]<br>说明：<br>●一个数组元素实质上是一个变量名，代表内存中的一个存储单元，一个数组占据的是一连串连续的存储单元。<br>●引用数组元素时，数组的下标可以是整型常量，也可以是整形表达式。<br>●数组必须先定义后使用<br>●只能逐个引用数组元素而不能一次引用整个数组。</p>
<h3 id="一维数组的初始化"><a href="#一维数组的初始化" class="headerlink" title="一维数组的初始化"></a>一维数组的初始化</h3><p>当数组定义后，系统会为该数组在内存中开辟一串连续的存储单元，但这些存储单元中并没有确定的值。可以在定义数组时为包含的数组元素赋初值。如：int a[6]&#x3D;{0,1,2,3,4,5}<br>说明：<br>●所赋初值放在一对花括号中，数值类型必须与所说明类型一致。<br>●所赋初值之间用逗号隔开，系统将按这些数组的排列顺序，从a[0]元素开始依次给数组a中的元素赋初值。<br>●不能跳过前面的元素给后面的元素赋初值，但是允许为前面元素赋值为0。<br>●当所赋初值个数少于所定义数组的元素个数时，将自动给后面的其他元素补初值0。<br>●可以通过赋初值来定义一维数组的大小，定义数组时的一对方括号中可以不指定数组的大小。</p>
<h2 id="二维数组的定义和引用"><a href="#二维数组的定义和引用" class="headerlink" title="二维数组的定义和引用"></a>二维数组的定义和引用</h2><h3 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h3><p>1.在C语言中，二维数组中元素排列的顺序是：按行存放，即在内存中先顺序存放第一行元素，再存放第二行的元素。二维数组元素的存储总是占用一块连续的内存单元。<br>2.一般形式:  类型说明符 数组名[常量表达式][常量表达式]</p>
<h3 id="二维数组元素的引用"><a href="#二维数组元素的引用" class="headerlink" title="二维数组元素的引用"></a>二维数组元素的引用</h3><p>表示形式:    数组名[下标表达式1][下标表达式2]<br>●数组的下标可以是整型表达式<br>●数组元素可以出现在表达式中，可以被赋值</p>
<h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><p>●可以在定义二维数组的同时给二维数组的元素赋初值<br>●全部初值放在一对花括号中，每一行的初值又分别括在一对花括号中，之间用逗号隔开。<br>●当某一对花括号内的初值个数少于该行中元素的个数时，系统将自动地给后面的元素赋初值0<br>●不能跳过每行前面的元素而给后面的元素赋值。<br>●对于二维数组，只可以省略第一个方括号中的常量表达式，但不能省略第二个方括号中的常量表达式。</p>
<h3 id="通过赋初值定义二维数组的大小"><a href="#通过赋初值定义二维数组的大小" class="headerlink" title="通过赋初值定义二维数组的大小"></a>通过赋初值定义二维数组的大小</h3><p>对于一维数组，可以在数组定义语句中省略方括号中的常量表达式，通过所赋初值的个数来确定数组的大小；<br>对于二维数组，只可以省略第一个方括号中的常量表达式，而不能省略第二个方括号中的常量表达式。</p>
<h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><h3 id="字符数组的定义"><a href="#字符数组的定义" class="headerlink" title="字符数组的定义"></a>字符数组的定义</h3><p>字符数组就是数组中的每一个元素都是字符。定义方法同普通数组的定义相同，即逐个对数组元素赋值。</p>
<h3 id="字符数组的初始化及引用"><a href="#字符数组的初始化及引用" class="headerlink" title="字符数组的初始化及引用"></a>字符数组的初始化及引用</h3><p>1.初始化：对字符数组初始化，可逐个元素地赋值，即把字符逐个赋给数组元素。<br>●如果花括号中提供的初值个数(即字符个数)大于数组长度，则编译时会按语法错误处理。<br>●如果初值个数小于数组长度，则将这些字符赋值给数组中前面那些元素，其余元素定为空字符\0;<br>2.引用形式：采用下标引用，即<br>    数组名[下标]</p>
<h3 id="字符串和字符串结束标志"><a href="#字符串和字符串结束标志" class="headerlink" title="字符串和字符串结束标志"></a>字符串和字符串结束标志</h3><p>C语言中，将字符串作为字符数组来处理。为测定字符串的实际长度，C语言规定了一个字符串结束标志，以字符”\0”代表。就是说，在遇到字符”\0”时，表示字符串结束，由它前面的字符组成字符串。</p>
<h3 id="字符数组的输入输出"><a href="#字符数组的输入输出" class="headerlink" title="字符数组的输入输出"></a>字符数组的输入输出</h3><p>字符数组的输入输出有两种方法：<br>●用”%c”格式符将字符逐个输入或输出。<br>●用”%s”格式符将整个字符串一次输入或输出。</p>
<p>在C语言中，有两个函数可以在控制台(显示器)上输出字符串<br>●puts() 输出字符串并自动换行，该函数只能输出字符串。<br>●printf() 通过格式控制符%s输出字符串，不能自动换行。除了字符串，printf()还可输出其他类型数据。</p>
<p>在C语言中，有两个函数可以从键盘上输入字符串，它们是<br>●scanf() 通过格式控制符%s输入字符串。除了字符串，scanf()还能输入其他类型的数据。[遇到空格就结束输入，无法含有空格]<br>●gets() 直接输入字符串，并且只能输入字符串。[认为空格也是字符串的一部分，以回车作为字符串结束]</p>
<h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><p>C语言没有提供对字符串进行整体操作的运算符，但在C语言的函数库中提供了一些用来处理字符串的函数。在调用这些函数前，必须在程序前面命令行包含标准头文件”string.h”。<br>●puts() 调用形式为puts(字符数组),将一个字符串(以”\0”结束)输出到终端设备。<br>●gets() 调用形式为gets(字符数组),从终端输入一个字符串到字符数组中，并得到一个函数值。<br>●strcpy() 调用形式strcpy(字符数组1,字符数组2),把字符数组2所指字符串的内容复制到字符数组1所指存储空间中。函数返回字符数组1的值，即目的串的首地址。<br>●strcat() 调用形式为strcat(字符数组1,字符数组2),该函数将字符数组2所指字符串的内容连接到字符数组1所指的字符串后面，并自动覆盖字符数值1串末尾的”\0”。该函数返回字符数组1的地址值。<br>●strlen() 调用形式为strlen(字符数组),此函数计算出以字符数组为起始地址的字符串的长度，并作为函数值返回。<br>●strcmp() 调用形式为strcmp(字符数组1,字符数组2),该函数用来比较字符数组1和字符数组2所指字符串的大小。若字符数组1&gt;字符数组2，函数值大于0(正数)；若字符数组1&#x3D;字符数组2，函数值等于0；若字符数组1&lt;字符数组2，函数值小于0(负数)。</p>
<h3 id="C语言数组是静态的"><a href="#C语言数组是静态的" class="headerlink" title="C语言数组是静态的"></a>C语言数组是静态的</h3><p>在C语言中，数组一旦被定义，占用的内存空间就是固定的，容量就是不可改变的，既不能在任何位置插入元素，也不能在任何位置删除元素，只能读取和修改元素，我们将这样的数组称为<em>静态数组</em><br>▲动态数组：指数组在定义后可以改变容量，允许任意位置插入或删除元素的数组。<br>一般 C、C++等编译型语言不支持动态数组；而PHP、JavaScript等解释型语言支持动态数组。</p>
<h3 id="数组越界与溢出"><a href="#数组越界与溢出" class="headerlink" title="数组越界与溢出"></a>数组越界与溢出</h3><p>数组越界: 当数组下标小于0或大于等于数组长度时引用 就会发生越界(out of bounds),即访问数组以外的内存。<br>下标小于0即<em>下限越界</em>(Off Normal Lower)<br>下标大于等于数组长度即为<em>上限越界</em>(Off Normal Upper)<br>数组溢出:即赋予数组元素的个数超过数组长度。</p>
<p>注意：在用字符串给字符数组赋值时，要保证数值长度大于字符串长度，以容纳结束符”\0”。</p>
<p>C语言变长数组(VLA, Variable Langth Array)：使用变量指明数组长度。<br>●在C89标准中，必须使用常量表达式指明数组长度。<br>●在C99标准中，可以使用变量指明数组长度。<br>变长数组仍是静态数组，其长度一旦定义就无法改变。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/02/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A05/">https://scholargeek.github.io/2018/02/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A05/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习4</title>
    <url>/2018/02/08/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="三大结构"><a href="#三大结构" class="headerlink" title="三大结构"></a>三大结构</h1><p>C语言中有三大结构，分别是 顺序结构、选择结构和循环结构。</p>
<span id="more"></span>

<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="关系运算符和关系表达式"><a href="#关系运算符和关系表达式" class="headerlink" title="关系运算符和关系表达式"></a>关系运算符和关系表达式</h3><h4 id="关系运算符及其优先次序"><a href="#关系运算符及其优先次序" class="headerlink" title="关系运算符及其优先次序"></a>关系运算符及其优先次序</h4><p>C语言提供6种关系运算符：小于(&lt;) 、小于等于(&lt;&#x3D;)、大于等于(&gt;&#x3D;)、大于(&gt;)、等于(&#x3D;&#x3D;)、不等于(!&#x3D;)<br>1.结合性:自左向右<br>2.优先级<br>    （&lt;、&lt;&#x3D;、&gt;&#x3D;、&gt;）4种关系运算符的优先级别相同<br>    （&#x3D;&#x3D;、!&#x3D;)优先级相同<br>    前4种优先级高于后2种<br>    关系运算符的优先级低于算术运算符、高于赋值运算符</p>
<h4 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h4><p>1.定义：由关系运算符连成的表达式。关系运算符的两边可以是C语言中的任何合法表达式。<br>2.关系运算符的结果是一个整数值——“0”或”1”，用非零值来表示”真”,用零值表示”假”。<br>3.当关系运算符两边值类型不一致时，系统将自动转化。</p>
<h3 id="逻辑运算符和逻辑表达式"><a href="#逻辑运算符和逻辑表达式" class="headerlink" title="逻辑运算符和逻辑表达式"></a>逻辑运算符和逻辑表达式</h3><h4 id="逻辑运算符及其优先级"><a href="#逻辑运算符及其优先级" class="headerlink" title="逻辑运算符及其优先级"></a>逻辑运算符及其优先级</h4><p>C语言提供了3种逻辑运算符：逻辑与(&amp;&amp;)、逻辑或(||)、逻辑非(!) 。其中”&amp;&amp;”和”||”是双目运算符，而”!”是单目运算符,要求必须在运算对象左边。<br>1.结合性:自左至右<br>2.优先级:”!”&gt;”&amp;&amp;”&gt;”||”<br>    “!”&gt;算术运算符&gt;关系运算符&gt;”&amp;&amp;”&gt;”||”&gt;赋值运算符</p>
<h4 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h4><p>1.逻辑表达式由逻辑运算符和运算对象组成。<br>2.参与逻辑运算的对象可以是一个具体的值，还可以是C语言中任意合法的表达式。<br>3.逻辑表达式的运算结果为1(真)或者为0(假)<br>● A&amp;&amp;B运算中，只有A,B同为真时才为真<br>● A||B运算中，只有A,B同为假时才为假<br>● 关系运算符不能连用，但可用逻辑运算符表示，如0&lt;x&lt;10 表示为 0&lt;x&amp;&amp;x&lt;10</p>
<h3 id="if语句和用if语句构成的选择结构"><a href="#if语句和用if语句构成的选择结构" class="headerlink" title="if语句和用if语句构成的选择结构"></a>if语句和用if语句构成的选择结构</h3><h4 id="if语句的几种形式"><a href="#if语句的几种形式" class="headerlink" title="if语句的几种形式"></a>if语句的几种形式</h4><ol>
<li>if(表达式)语句<br> if是C语言中的关键字<br> 表达式两侧的括号不可少，并且只能是圆括号<br> 紧跟着的语句，称if子句，如果在if子句中需要多个语句，则应使用大括号{}把一组语句括起来构成复合语句</li>
<li> if(表达式) 语句1<br> else 语句2</li>
<li>  if(表达式1) 语句1<br>  else if(表达式2) 语句2<br>  else if(表达式3) 语句3<br>  …<br>  else if(表达式m) 语句m<br>  else 语句n<br>● “语句1”是if子句，”语句2···语句m”是else子句<br>● 子句若为多余语句应用花括号({})把这些语句括起来组成复合语句<br>● else必须与if配对，共同组成if…else语句</li>
</ol>
<h4 id="if语句的嵌套"><a href="#if语句的嵌套" class="headerlink" title="if语句的嵌套"></a>if语句的嵌套</h4><p>在if语句中又包含一个或多个if语句结构，称为if语句的嵌套。</p>
<h4 id="条件运算符构成的选择结构"><a href="#条件运算符构成的选择结构" class="headerlink" title="条件运算符构成的选择结构"></a>条件运算符构成的选择结构</h4><ol>
<li>条件运算符 ？ ：</li>
<li>条件运算符的一般形式：表达式1？表达式2：表达式3</li>
<li>求解过程：先求解表达式1 的值，当表达式1的值是非0时，以表达式2的值作为整个条件表达式的值，当表达式1 的值是0时，以表达式3的值作为整个条件表达式的值。<br>4.优先级：条件运算符高于赋值运算符，但低于逻辑运算符、关系运算符和算术运算符。</li>
</ol>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>switch 语句是C语言提供的多分支选择语句,用来实现多分支选择结构。<br>一般形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> 常量表达式<span class="number">1</span>: 语句<span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> 常量表达式<span class="number">2</span>: 语句<span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> 常量表达式n: 语句n</span><br><span class="line"><span class="keyword">default</span>:语句n+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>●switch 后面用花括号括起来的部分是switch语句体。<br>●switch 后面括号内的“表达式”,可以是C语言中任意合法表达式，但表达式两侧的括号不可省略。<br>●case与其后面的常量表达式合称case语句标号，常量表达式的类型必须与switch后面的表达式的类型相匹配，且各case语句标号的值各不相同，不能重复。<br>●default也是关键字，起标号的作用，代表除了以上所有case标号之外的那些标号，default标号可以出现在语句体中任何标号位置上，当然也可以没有。<br>●case语句标号后的语句1，语句2，可以是一条语句，也可以是若干条，在必要时，case语句标号后的语句可以省略不写。</p>
<p>执行过程：<br>①首先计算”表达式”的值，假设为m<br>②从第一个case开始比较，”整数数值1”和m,如果它们相等，就执行冒号后面的所有语句,也就是从”语句1”到”语句n+1”不管后面的case是否匹配成功。<br>③如果”整型数值1”和m不相等就跳过它比较后面的表达式，直到发现某个整型数值相等的表达式，则执行其后面的所有语句。<br>④如果直到最后一个表达式都没有与表达式m值相匹配，则执行default后的”语句n+1”</p>
<p>●若想在switch语句中仅执行一个分支，则必须在每个分支后添加break语句<br>●break是C语言的一个关键字，专用于跳出switch语句，所谓”跳出”是指一但执行就不会再执行switch中任何语句。</p>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h3><p>1.一般形式：<br>    while(表达式) 循环体<br>●while是C语言的关键字<br>●紧跟其后的表达式可以是C语言中任意合法的表达式，该表达式是循环条件，由它来控制循环体是否执行。<br>●循环体只是一条可执行语句，当多项操作需重复时可用复合语句。</p>
<p>2.执行过程<br>①第一步：计算紧跟while后括号中表达式的值，当表达式的值为非0时，则接着执行while语句中的内嵌语句；当表达式的值为0时，则跳过该while语句，执行while结构后的其他语句。<br>②第二步：执行循环体内嵌语句<br>③第三步：返回去执行步骤①，直到条件不满足，即表达式的值为0时，退出循环，while结构结束。</p>
<p>3.特点：先对表达式进行条件判断，后执行语句。</p>
<h3 id="do…while语句"><a href="#do…while语句" class="headerlink" title="do…while语句"></a>do…while语句</h3><p>1.一般形式：<br>    do{<br>    循环体语句<br>    }while(表达式);<br>●do是C语言的关键字，必须和while联合使用，不能独立出现。<br>●do…while循环由do开始，用while结束。<br>●while后面的圆括号中的表达式，可以是C语言中任意合法的表达式，由它控制循环是否执行。<br>●在语法上，do和while之间只能是一条语句，如需执行多条语句时，可使用复合语句。<br>●while(表达式)后的分号不可丢。</p>
<p>2.执行过程：<br>①先执行一次指定的循环体语句<br>②执行完后，判别while后面的表达式的值，当表达式的值为非零(真)时，程序流程返回，去重新执行循环体语句。<br>③如此反复，直到表达式的值等于零为止，此时循环结束。</p>
<p>3.特点：先执行循环体一次，然后判断循环条件是否成立。</p>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>1.一般形式为：<br>    for(表达式1;表达式2;表达式3);<br>●圆括号中通常是3个表达式，用于for循环的控制。for语句中的表达式可以部分或全部省略，但其中分号不可省略。<br>●各表达式用分号隔开，圆括号不可省略。<br>●按照语法规则，循环体只能是一条语句，如需要完成多项操作，须使用复合语句。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)&#123;</span><br><span class="line">    语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.执行过程<br>①先执行”表达式1”<br>②再执行”表达式2”，如果它的值为真(非0)，则执行循环体，否则结束循环<br>③执行完循环体后再执行”表达式3”<br>④重复执行步骤②③，直到”表达式2”的值为假,就结束循环<br>▲上面步骤②③是一次循环，for语句的作用就是不断执行步骤②③。<br>●”表达式1”仅在第一次循环中执行，以后都不会再执行，可以认为这是一个初始化语句。<br>●”表达式2”一般是一个关系表达式，决定了是否还要继续下次循环，称为”循环条件”。<br>●”表达式3”很多情况下是一个带有自增自减操作的关系式，以使循环条件逐渐变得”不成立”。</p>
<p>其执行过程如图：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/30/c11a11028dd037c6.png" alt="for循环流程图"></p>
<h3 id="循环的嵌套"><a href="#循环的嵌套" class="headerlink" title="循环的嵌套"></a>循环的嵌套</h3><p>定义: 在某一个循环体内部又包含了另一个完整的循环结构，称为循环的嵌套。<br>注意:while、do…while、for循环都可以互相嵌套，循环的嵌套可以多层，但要保证每一层循环在逻辑上必须是完整的。</p>
<h3 id="几种循环的比较"><a href="#几种循环的比较" class="headerlink" title="几种循环的比较"></a>几种循环的比较</h3><p>while和do…while循环，只在while后面指定循环条件，循环体内应包含使循环趋于结束的语句，for中使循环趋于结束的操作可以包含在”表达式3”中。</p>
<h3 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a>break语句和continue语句</h3><h4 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h4><p>1.在break后面加上分号就可以构成break语句，break语句还可以用于从循环体内跳出，即提前结束循环。<br>2.说明：<br>①break语句只能出现在循环体内及switch语句内，不能用于其它语句。<br>②当break出现在循环体中的switch语句体内，其作用是跳出该switch语句体。<br>　当break出现在循环体中，而非switch语句内，则执行break后结束本层循环，不再进行条件判断。</p>
<h4 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h4><p>1.continue后面加上分号就可构成continue语句。<br>2.作用：结束本次循环，即跳过循环体中下面尚未执行的语句，而转去重新判定循环条件是否成立，从而确定下一次循环是否继续执行。</p>
<h4 id="break与continue的比较"><a href="#break与continue的比较" class="headerlink" title="break与continue的比较"></a>break与continue的比较</h4><p>break与continue相比；break用来结束所有循环，循环语句不再有执行的机会；continue用来结束本次循环直到跳到下一次循环，如果循环条件成立，还会继续循环。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/02/08/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A04/">https://scholargeek.github.io/2018/02/08/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A04/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习8</title>
    <url>/2018/02/16/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A08/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编译预处理"><a href="#编译预处理" class="headerlink" title="编译预处理"></a>编译预处理</h1><p>本文将讲述C语言中关于预处理的相关知识。</p>
<span id="more"></span>

<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>在实际开发中，编译器在编译程序之前还需要对源文件进行简单的处理，这种简单加工过程称为 预处理 (即预先处理、提前处理)。<br>预处理主要是处理以#开头的命令，以#号开头的命令称为 预处理命令。预处理是C语言的一个重要功能，由预处理程序完成。当对一个源文件进行编译时，系统将自动调用预处理程序对源程序中的预处理部分做处理，处理完毕自动进入对源程序的编译。编译器会将预处理的结果保存到和源文件同名的.i文件中。<br>C语言提供了多种预处理功能，如宏定义、文件包含、条件编译等，合理地使用它们会使编写的程序便于阅读、修改、移植和调试，也有利于模块化程序设计。</p>
<h2 id="文件包含命令-include的用法"><a href="#文件包含命令-include的用法" class="headerlink" title="文件包含命令(#include的用法)"></a>文件包含命令(#include的用法)</h2><p>#include叫做文件包含命令，用于引入对应头文件(.h文件)<br>#include就是将头文件的内容插入到该命令所在的位置，从而把头文件和当前源文件连成一个文件。<br>用法：<br>【列】  #include&lt;stdHeader.h&gt;<br>　　　#include”myHeader.h”<br>尖括号与双引号的区别在于头文件的搜索路径不同：<br>●使用尖括号&lt;&gt;，编译器会到系统路径下查找头文件。<br>●使用双引号””，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。</p>
<p>【注意】<br>●一个#include命令只能包含一个头文件，多个头文件需要多个#include命令。<br>●文件包含允许嵌套，即一个被包含的文件中又可以包含另一个文件。</p>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><h3 id="不带参数的宏定义"><a href="#不带参数的宏定义" class="headerlink" title="不带参数的宏定义"></a>不带参数的宏定义</h3><p>1.定义形式： #define 宏名 替换文本 或 #define 宏名<br>2.说明：<br>●在define宏名和宏替换文本之间要用空格隔开<br>●可以用#undef命令终止宏定义的作用域<br>●在进行宏定义时，可以引用已定义的宏名<br>●同一个宏名不能重复定义</p>
<h3 id="带参数的宏定义"><a href="#带参数的宏定义" class="headerlink" title="带参数的宏定义"></a>带参数的宏定义</h3><p>宏定义还可进行参数替换。<br>●如果程序中带有实参的宏，则按#define命令行中指定的字符串从左到右进行替换。<br>●如果字符串中包含宏中的形参(如 x,y)则将程序语句中相应的实参(可以是常量、变量或表达式)代替形参。<br>●如果宏定义中的字符串中的字符不是参数字符(如 (x<code>*</code>y)中的”<code>*</code>“号)，则保留。这样就形成了置换的字符串。</p>
<h3 id="C语言带参宏定义和函数的区别"><a href="#C语言带参宏定义和函数的区别" class="headerlink" title="C语言带参宏定义和函数的区别"></a>C语言带参宏定义和函数的区别</h3><p>带参数的宏和函数很像，但本质上有区别：宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理了，没有机会参与编译，也不会占用内存。而函数是一段可以重复使用的代码，会被编译，会分配内存，每一次调用函数就是执行这块内存中的代码。</p>
<h3 id="C语言的预定义宏"><a href="#C语言的预定义宏" class="headerlink" title="C语言的预定义宏"></a>C语言的预定义宏</h3><p>预定义宏 即先定义好的宏，无需再定义即直接使用。ANSI C规定的几个预定义宏如下：<br><code>_</code>LINE<code>_</code>: 表示当前源代码的行号<br><code>_</code>FILE<code>_</code>: 表示当前源文件的名称<br><code>_</code>DATE<code>_</code>: 表示当前编译日期<br><code>_</code>TIME<code>_</code>: 表示当前编译时间</p>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>条件编译：即能够根据不同情况编译不同代码，产生不同目标文件的机制。</p>
<h3 id="if的用法"><a href="#if的用法" class="headerlink" title="#if的用法"></a>#if的用法</h3><p>一般格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 整形常量表达式1</span></span><br><span class="line">    程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 整形常量表达式2</span></span><br><span class="line">    程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 整形常量表达式3</span></span><br><span class="line">    程序段<span class="number">3</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    程序段<span class="number">4</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>意为：如常量 “表达式1”的值为真(非0)，就对”程序段1”进行编译，否则就计算”表达式2”，结果为真(非0)就对”程序段2”进行编译，也为假，就继续往下匹配，直到遇到为真的表达式，或者最后到 #else。</p>
<h3 id="ifdef的用法"><a href="#ifdef的用法" class="headerlink" title="#ifdef的用法"></a>#ifdef的用法</h3><p>一般格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 宏名</span></span><br><span class="line">    程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>意为：如果当前的宏已被定义过，则对”程序段1”进行编译，否则对”程序段2”进行编译。</p>
<h3 id="ifndef的用法"><a href="#ifndef的用法" class="headerlink" title="#ifndef的用法"></a>#ifndef的用法</h3><p>一般格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 宏名</span></span><br><span class="line">    程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>意为：如果当前的宏未被定义过，则对”程序段1”进行编译，否则对”程序段2”进行编译。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/02/16/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A08/">https://scholargeek.github.io/2018/02/16/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A08/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习6</title>
    <url>/2018/02/12/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A06/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>本文将表述函数声明及使用的相关知识点。</p>
<span id="more"></span>

<h2 id="函数概述"><a href="#函数概述" class="headerlink" title="函数概述"></a>函数概述</h2><p>　　在C语言中，子程序的作用是由函数完成的。一个C程序可由一个主函数和若干个其它函数构成，并且只能有一个主函数。由主函数来调用其他函数，其他子函数之间也可以相互调用。<br>　　C程序的执行总是从main()函数开始。调用其他函数完毕后，程序流程回到main()函数，继续执行主函数中其他语句，直到main()函数结束，则整个程序的运行结束。</p>
<p>从用户使用的角度函数分为：<br>● 标准函数(库函数)<br>● 自定义函数<br>● 无参函数<br>● 有参函数</p>
<p>说明：<br>●库函数： C语言自带的函数<br>●库： 函数集合<br>●参数： 函数括号内包含的数据或变量</p>
<h3 id="无参函数的定义"><a href="#无参函数的定义" class="headerlink" title="无参函数的定义"></a>无参函数的定义</h3><p>如果函数不接收用户传递的数据，那么这时可不带参数，即使用无参函数，如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>●dataType为返回值类型，可以为任意数据类型。<br>●functionName是函数名，是标识符的一种。<br>●body是函数体，由花括号包围。<br>●若有返回值须在函数体内使用return语句返回，返回值数据类型须与dataType一致。</p>
<h3 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h3><p>若函数不需要返回值，或返回值类型不确定则定义无返回值函数，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//body</span></span><br><span class="line"><span class="comment">//No return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有参函数的定义"><a href="#有参函数的定义" class="headerlink" title="有参函数的定义"></a>有参函数的定义</h3><p>如果函数需要接收用户传递的数据，那么定义时就要带上参数，即定义有参函数，如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dataType <span class="title function_">functionName</span><span class="params">(dataType param1,dataType2 param2 ...)</span>&#123;</span><br><span class="line"><span class="comment">//body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>●有参函数可以有一个或多个参数，之间用”,”分隔。参数的本质上也是变量，定义时要指明类型和名称。</p>
<h2 id="函数参数和函数返回值"><a href="#函数参数和函数返回值" class="headerlink" title="函数参数和函数返回值"></a>函数参数和函数返回值</h2><h3 id="形式参数和实际参数"><a href="#形式参数和实际参数" class="headerlink" title="形式参数和实际参数"></a>形式参数和实际参数</h3><p>●在定义函数时，函数名后面括号中的变量称为”形式参数”(简称”形参”)<br>●在主调函数中，函数名后面括号中的参数(可以是一个表达式)称为”实际参数”(简称”实参”)</p>
<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>1.定义：函数的返回值就是通过函数调用使主调函数能得到一个确定的值。<br>2.表达形式：<br>    return 表达式;<br>    reutrn (表达式);<br>    return;<br>3.说明：<br>return语句中的表达式值的类型必须与函数首部所说明的一致。若类型不一致，则以函数值的类型为准，由系统自动进行强制转换。<br>当函数没有指明返回值，或没有返回语句时，函数返回了一个不确定的值。为了使函数不返回任何值，可以使用void定义函数。</p>
<h3 id="形参与实参的区别和联系"><a href="#形参与实参的区别和联系" class="headerlink" title="形参与实参的区别和联系"></a>形参与实参的区别和联系</h3><p>①形参变量只有在函数被调用时才会分配内存，调用结束后，立刻释放内存，所以形参变量只有在函数内部有效，不能在函数外部使用。<br>②实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参，所以应该提前用赋值，输入等办法使实参获得确定值。<br>③实参和形参在数量上、类型上、顺序上必须严格一致，否则会发生”类型不匹配”的错误。当然，如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可不同于形参类型。<br>④函数调用中发生的数据传递是单向的，只能把实参的值传给形参，而不能把形参的值反向地传给实参。换句话说，一旦完成了数据传递，实参与形参就无关了，即在函数调用过程中，形参的改变不会影响实参。</p>
<h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>一般形式： 函数名(实参表列)<br>函数的调用可分为 无参函数 和 有参函数两种：<br>● 调用无参函数，不用”实参表列”，但括号不能省略。<br>● 调用有参函数，各参数间用逗号隔开，其实参与形参类型一致。</p>
<p>所谓调用(Function Call)就是使用已定义好的函数。</p>
<h3 id="函数的嵌套调用"><a href="#函数的嵌套调用" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h3><p>函数不能嵌套定义，但可用嵌套调用，也就是一个函数的定义或调用过程中允许出现另外一个函数的调用。</p>
<h3 id="函数的声明以及函数原型"><a href="#函数的声明以及函数原型" class="headerlink" title="函数的声明以及函数原型"></a>函数的声明以及函数原型</h3><p>C语言中，除了主函数外，对于用户定义的函数要遵循先定义后使用的规则。把函数的定义放在调用之后，应该在调用之前对函数进行说明(或函数原型说明)(声明 Declaration)<br>函数声明一般形式如下：<br>    dataType functionName(dataType1 param1, dataType2 param2 …);<br>或<br>    dataType functionName(dataType1, dataType2…);<br>函数声明的格式相当于去掉函数定义中的函数体，并在最后加上分号;<br>函数声明给出了函数名、返回值类型、参数列表(重点是参数类型)等与该函数有关的信息，又称 函数原型(Function Prototype)。函数声明的作用是告诉编译器与该函数有关的信息，让编译器知道函数的存在及存在形式，即使函数暂时没有定义，编译器也知道如何使用它。</p>
<h2 id="函数的嵌套调用与递归调用"><a href="#函数的嵌套调用与递归调用" class="headerlink" title="函数的嵌套调用与递归调用"></a>函数的嵌套调用与递归调用</h2><h3 id="函数的嵌套调用-1"><a href="#函数的嵌套调用-1" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h3><p>C语言的函数定义都是独立的，互相平行的，C语句不允许嵌套定义函数，即一个函数内不能定义另一个函数。但可以嵌套调用函数，即在调用一个函数的过程中，又调用另一个函数。</p>
<h3 id="函数的递归调用"><a href="#函数的递归调用" class="headerlink" title="函数的递归调用"></a>函数的递归调用</h3><p>在调用一个函数的过程中又出现直接或间接地调用该函数本身，称为函数的递归调用。<br>使用递归法解决问题，须符合的条件：<br>● 可以把要解决的问题转化为一个新的问题，而这个新的问题的解决方法仍与原来的解决方法相同，只是所处理的对象有规律地递增或递减。<br>● 可以应用这个转化过程使问题得到解决，必须有一个明确的结束递归的条件。</p>
<h2 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h2><h3 id="数组元素作为函数实参"><a href="#数组元素作为函数实参" class="headerlink" title="数组元素作为函数实参"></a>数组元素作为函数实参</h3><p>数组元素可以作为函数的实参，与用变量作为实参一样，按照单向值传递的方式进行传递。</p>
<h3 id="数组名可以作为函数参数"><a href="#数组名可以作为函数参数" class="headerlink" title="数组名可以作为函数参数"></a>数组名可以作为函数参数</h3><p>可以用数组名作为函数的参数，此时实参与形参都应用数组名，数组名是整个数组的首地址。</p>
<h2 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h2><p>在函数内部定义的变量称为局部变量，只能在本函数内部使用。<br>在函数之外定义的变量称为外部变量，也即全局变量，可为本文件中其他函数所共用，他的有效范围从定义变量开始到本文件结束。<br>如果在同一个源文件中，全局变量与局部变量同名，则在局部变量的作用范围内，外部变量被”屏蔽”,即不起作用。</p>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>所谓 作用域(scope) 就是变量的有效范围，就是变量可以在哪个范围内使用，有些变量只能在一定范围内使用，超出范围就失效了。<br>变量的作用域由变量的定义位置决定，在不同位置定义的变量，其作用域不同。</p>
<h3 id="块级变量"><a href="#块级变量" class="headerlink" title="块级变量"></a>块级变量</h3><p>即由{}包围起来的代码中的变量定义，这样的变量具有块级作用域。<br>每个C语言程序都包含了许多作用域，不同的作用域中可以出现同名的变量，C语言会按照从小到大的顺序，一层一层地去父级作用域中查找变量，如果在最顶层的全局作用域中还未找到这个变量，那么就会报错。</p>
<h2 id="变量的存储类别"><a href="#变量的存储类别" class="headerlink" title="变量的存储类别"></a>变量的存储类别</h2><h3 id="auto变量"><a href="#auto变量" class="headerlink" title="auto变量"></a>auto变量</h3><p>当在函数内部或复合语句内定义变量时，如果没有指定存储类别，或使用了auto说明符，系统就认为所定义的变量具有自动类别。</p>
<h3 id="register变量"><a href="#register变量" class="headerlink" title="register变量"></a>register变量</h3><p>寄存器变量也是自动类变量。它与auto变量的区别仅在于：用register说明变量是建议编译程序将变量的值保留在CPU的寄存器中，而不是像一般变量那样占用内存单元。</p>
<h3 id="局部static变量"><a href="#局部static变量" class="headerlink" title="局部static变量"></a>局部static变量</h3><p>当函数体(或复合语句)内部用static来说明一个变量时，可以称该变量为静态局部变量。<br>它与auto变量，register变量的本质区别是：<br>①在整个程序运行期间、静态局部变量在内存中的静态存储区中占据着永久性的存储单元。即使退出函数后，下次再进入该函数时，静态局部变量仍使用原来的存储单元。由于不释放这些存储单元，这些存储单元中的值得以保留，因而可以继续使用存储单元中原来的值。<br>②静态局部变量的初值是在编译时赋予的，在程序执行期间不再赋以初值。对未赋值的局部变量，C语言编译程序自动给它赋初值为0。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/02/12/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A06/">https://scholargeek.github.io/2018/02/12/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A06/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习7</title>
    <url>/2018/02/14/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A07/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>本文将讲述C语言中关于指针的相关知识。</p>
<span id="more"></span>

<h2 id="关于地址和指针"><a href="#关于地址和指针" class="headerlink" title="关于地址和指针"></a>关于地址和指针</h2><p>　　在C语言中，将地址形象地称为”指针”。一个变量的地址称为变量的”指针”。一个专门用来存放另一个变量的地址的变量(即指针),则称它为”指针变量”。</p>
<h2 id="变量的指针和指向变量的指针变量"><a href="#变量的指针和指向变量的指针变量" class="headerlink" title="变量的指针和指向变量的指针变量"></a>变量的指针和指向变量的指针变量</h2><h3 id="指针变量的定义"><a href="#指针变量的定义" class="headerlink" title="指针变量的定义"></a>指针变量的定义</h3><p>定义 指针变量 的一般形式：类型名 <code>*</code>指针变量名,<code>*</code>指针变量名2…;<br>如: int *p,*t;</p>
<h3 id="指针变量的引用"><a href="#指针变量的引用" class="headerlink" title="指针变量的引用"></a>指针变量的引用</h3><p>指针变量中只能存放地址(指针),与指针相关的两个运算符是”&amp;”(取地址运算)和”*”(指针运算符)</p>
<h3 id="指针变量作为函数参数"><a href="#指针变量作为函数参数" class="headerlink" title="指针变量作为函数参数"></a>指针变量作为函数参数</h3><p>指针类型数据可以作为函数参数来进行传递，作用:将一个变量的地址传送到另一个函数中，参与该函数的运算。形参指针变量的值的改变不能使实参指针变量的值发生改变。</p>
<h3 id="关于-和-的谜题"><a href="#关于-和-的谜题" class="headerlink" title="关于*和&amp;的谜题"></a>关于*和&amp;的谜题</h3><p>假设有一个int类型的变量a,pa是指向它的指针，那么<code>*</code>&amp;a和&amp;<code>*</code>pa分别是什么意思呢？<br><code>*</code>&amp;a可以理解为<code>*</code>(&amp;a),&amp;a表示取变量a的地址(等价于pa),<code>*</code>(&amp;a)表示<code>取这个地址上的数据(等价于*pa)。即*&amp;a仍等价于a</code>。<br>&amp;*pa可以理解为&amp;(*pa),<code>*</code>pa表示取得pa指向的数据(等价于a),<code>&amp;(*pa)表示数据的地址(等价于&amp;a)。即&amp;*pa等价于pa。</code></p>
<h2 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h2><h3 id="指向数组元素的指针"><a href="#指向数组元素的指针" class="headerlink" title="指向数组元素的指针"></a>指向数组元素的指针</h3><p>C语言规定数组名代表数组的首地址，也就是数组中第0号元素的地址。<br>定义指向数组元素的指针变量的方法，与定义指向变量的指针变量相同。</p>
<h3 id="通过指针引用数组元素"><a href="#通过指针引用数组元素" class="headerlink" title="通过指针引用数组元素"></a>通过指针引用数组元素</h3><p>如果指针变量P以指向数组中的一个元素，则P+1指向同一数组中的下一个元素。</p>
<h3 id="用数组名作为函数的参数"><a href="#用数组名作为函数的参数" class="headerlink" title="用数组名作为函数的参数"></a>用数组名作为函数的参数</h3><p>●当数组名作为参数被传递时，若形参数组中各元素发生了变化，则原实参数组各元素的值也随之变化。<br>●如果用数组元素作为实参，情况就与用变量作为实参时一样，是”值传递”方式。</p>
<h3 id="指向多维数组的指针和指针变量"><a href="#指向多维数组的指针和指针变量" class="headerlink" title="指向多维数组的指针和指针变量"></a>指向多维数组的指针和指针变量</h3><p>多维数组可以看作是一维数组的延伸，多维数组的内存单元也是连续的内存单元。C语言实际上是把多维数组当成一维数组来处理。</p>
<h2 id="字符串与指针"><a href="#字符串与指针" class="headerlink" title="字符串与指针"></a>字符串与指针</h2><h3 id="字符串的表示形式"><a href="#字符串的表示形式" class="headerlink" title="字符串的表示形式"></a>字符串的表示形式</h3><p>●用字符数组存放一个字符串，然后输出该字符串。<br>●用字符指针指向一个字符串，用字符指针指向字符串中的字符。</p>
<h3 id="字符串指针作为函数参数"><a href="#字符串指针作为函数参数" class="headerlink" title="字符串指针作为函数参数"></a>字符串指针作为函数参数</h3><p>将一个字符串从一个函数传递到另一个函数，可以用地址传递的办法，即用字符数组名作为参数或指向字符串的指针变量作为参数，进行传递。</p>
<h3 id="字符指针变量和字符数组的区别"><a href="#字符指针变量和字符数组的区别" class="headerlink" title="字符指针变量和字符数组的区别"></a>字符指针变量和字符数组的区别</h3><p>●字符数组是由若干个元素组成的，每个元素中存放一个字符，而字符指针变量中存放的是地址，绝不可能将字符串的内容存放到字符指针变量中。<br>●赋值方式不同<br>●字符数组可以在定义时对整体赋初值，但在赋值语句中不能完成整体赋值。而字符指针变量既可以在定义时赋初值，也可以在赋值语句中完成。<br>●编译时不同<br>●在程序中指针变量的值可以改变。而数组名虽然代表了地址，但其值固定，不可改变。</p>
<h2 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h2><p>指针变量可以指向一个函数，编译时，一个函数将被分配给一个入口地址，这个入口地址就称为该函数的指针。因此，可以通过使用一个指向函数的指针变量调用此函数。</p>
<p>说明：<br>●指向函数的指针变量的一般定义形式为： 数据类型(<code>*</code>指针变量名)();<br>●在给函数指针变量赋值时，只需给出函数名而不必给出参数。<br>●用函数指针变量调用函数时，只需将(<code>*</code>S)代替函数名即可(S为已定义的指向函数的指针变量名)，在(<code>*</code>S)之后的括号中根据需要写上实参。<br>●对指向函数的指针变量，做自增自减或算术运算等都没有意义。</p>
<h2 id="指针数组和指向指针的指针"><a href="#指针数组和指向指针的指针" class="headerlink" title="指针数组和指向指针的指针"></a>指针数组和指向指针的指针</h2><h3 id="指针数组的概念"><a href="#指针数组的概念" class="headerlink" title="指针数组的概念"></a>指针数组的概念</h3><p>若在一个数组中，其元素均为指针类型数据，这样的数组称为指针数组。<br>一维指针数组的定义形式为：  类型名 <code>*</code>数组名[数组长度]</p>
<h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><p>指向指针数据的指针变量，简称为指向指针的指针，通常称为二级指针。<br>定义一个指向指针数据的指针变量的形式： 类型名 <code>**</code>a</p>
<h2 id="C语言空指针NULL以及void指针"><a href="#C语言空指针NULL以及void指针" class="headerlink" title="C语言空指针NULL以及void指针"></a>C语言空指针NULL以及void指针</h2><h3 id="空指针NULL"><a href="#空指针NULL" class="headerlink" title="空指针NULL"></a>空指针NULL</h3><p>形式： char <em>str &#x3D; NULL;<br>一般对没有初始化的指针赋值为NULL，意为零。<br>空指针是不指向任何数据的指针，是无效指针。很多库函数对传入的指针做了判断，如果是空指针就不做任何操作。其实NULL是stdio.h中定义的一个宏，具体内容为 #define NULL ((void</em>)0) ,NULL指向了地址为0的内存。</p>
<h3 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a>void指针</h3><p>void * 含义：表示指针指向未知的数据类型，它指向数据后一般在使用时还需强制类型转换。</p>
<h2 id="二维数组指针-指向二维数组的指针"><a href="#二维数组指针-指向二维数组的指针" class="headerlink" title="二维数组指针(指向二维数组的指针)"></a>二维数组指针(指向二维数组的指针)</h2><p>若有以下二维数组a: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>概念上是一个矩阵，但在内存中它线性连续分布。<br>C语言允许把二维数组分解为一维数组来处理，即数组a可分解为三个一维数组a[0],a[1],a[2]<br>每个一维数组包含了若干元素，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">如a[<span class="number">0</span>]包含 a[<span class="number">0</span>][<span class="number">0</span>] , a[<span class="number">0</span>][<span class="number">1</span>] , a[<span class="number">0</span>][<span class="number">2</span>] , a[<span class="number">0</span>][<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>假设数组a中第0个元素地址为1000，那么每个一维数组的首地址如图：<br><img src="https://s3.bmp.ovh/imgs/2023/02/03/dcdc259feb5d405b.png" alt="二维数组地址分布图"><br>定义指向a的指针变量p: int (*p)[4] &#x3D; a</p>
<h2 id="指针的总结"><a href="#指针的总结" class="headerlink" title="指针的总结"></a>指针的总结</h2><p>指针(Pointer)就是内存的地址，C语言允许用一个变量来存放指针，这种变量称为指针变量。指针变量可以存放基本数据的地址，也可以存放数组、函数及其他指针变量的地址。</p>
<p><strong>常见指针变量的定义：</strong></p>
<table>
<thead>
<tr>
<th>定义</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>int <code>*</code>p;</td>
<td align="left">p可以指向int型的数据，也可以指向类似int arr[n]的数组</td>
</tr>
<tr>
<td>int <code>**</code>p;</td>
<td align="left">p为二级指针，指向int*类型的数据</td>
</tr>
<tr>
<td>int <code>*</code>p[n];</td>
<td align="left">p为指针数组。[]优先级高于<code>*</code>，应理解为int <code>*</code>(p[n])</td>
</tr>
<tr>
<td>int (<code>*</code>p)[n];</td>
<td align="left">p为二维数组指针</td>
</tr>
<tr>
<td>int <code>*</code>p();</td>
<td align="left">p是一个函数，它的返回类型为int *</td>
</tr>
<tr>
<td>int (<code>*</code>p)();</td>
<td align="left">p是一个函数指针，指向原型为 int fun() 的函数</td>
</tr>
</tbody></table>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/02/14/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A07/">https://scholargeek.github.io/2018/02/14/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A07/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习9</title>
    <url>/2018/02/18/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A09/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="结构体、枚举和共用体"><a href="#结构体、枚举和共用体" class="headerlink" title="结构体、枚举和共用体"></a>结构体、枚举和共用体</h1><p>本文将分别讲述C语言中关于结构体、枚举和共用体的相关知识。</p>
<span id="more"></span>

<h2 id="用typedef说明一种新类型名"><a href="#用typedef说明一种新类型名" class="headerlink" title="用typedef说明一种新类型名"></a>用typedef说明一种新类型名</h2><p>1.一般形式：typedef 类型名 标识符;<br>其中，”类型名”一定是在此语句之前已有定义的类型标识符。”标识符”是一个用户定义标识符，用来标识新的类型名。<br>2.typedef语句作用：用”标识符”来代表已存在的”类型名”，并没有产生新的数据类型，因此原有的类型名依然有效。<br>3.声明一个新的类型名的具体步骤：<br>①先按定义变量的写法写出定义的主体(如： float a;)<br>②将变量名换成新类型名(如 将a换为FLO)<br>③在最左边加上关键字typedef(如 typedef float FLO)<br>④然后可以用新类型名去定义其他变量 (如: FLO b;)</p>
<h2 id="结构体数据类型"><a href="#结构体数据类型" class="headerlink" title="结构体数据类型"></a>结构体数据类型</h2><p>结构体用来存放一组不同类型的数据。<br>1.一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名&#123;</span></span><br><span class="line">    成员列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.结构体类型说明形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体标识名&#123;</span></span><br><span class="line">    类型名<span class="number">1</span> 结构体成员名表<span class="number">1</span>；</span><br><span class="line">    类型名<span class="number">2</span> 结构体成员名表<span class="number">2</span>；</span><br><span class="line">    ...</span><br><span class="line">    类型名n 结构体成员名表n；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>说明：<br>①”结构体标识名”和”结构体成员名表”都必须是合法的用户定义标识符。<br>②每一个”结构体成员名表”中都可以含有多个同类型的成员名，它们之间以逗号分隔。<br>③结构体类型说明中”类型名1”~”类型名n”，不仅可以是简单数据类型，也可以是某种结构体类型。当结构体说明中又包含结构体时，称为结构体的嵌套。<br>④ANSIC 标准规定结构体至多允许嵌套15层，并且允许内嵌结构体成员名与外层成员名相同。</p>
<h2 id="结构体类型变量的定义"><a href="#结构体类型变量的定义" class="headerlink" title="结构体类型变量的定义"></a>结构体类型变量的定义</h2><h3 id="先声明结构体类型再定义变量名"><a href="#先声明结构体类型再定义变量名" class="headerlink" title="先声明结构体类型再定义变量名"></a>先声明结构体类型再定义变量名</h3><p>如已定义了一个结构体类型 struct time ,可以如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time</span> <span class="title">time1</span>,<span class="title">time2</span>;</span></span><br><span class="line">结构体类型名 结构体变量名；</span><br></pre></td></tr></table></figure>
<p>time1和time2为struct time 类型变量，即它们都具有struct time 类型的结构。</p>
<h3 id="在声明类型的同时定义变量"><a href="#在声明类型的同时定义变量" class="headerlink" title="在声明类型的同时定义变量"></a>在声明类型的同时定义变量</h3><p>其一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名&#123;</span></span><br><span class="line">    成员列表;</span><br><span class="line">&#125;变量名表列;</span><br></pre></td></tr></table></figure>
<h3 id="直接定义结构体类型变量"><a href="#直接定义结构体类型变量" class="headerlink" title="直接定义结构体类型变量"></a>直接定义结构体类型变量</h3><p>一般形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">成员表列</span><br><span class="line">&#125;变量名表列；</span><br></pre></td></tr></table></figure>
<h2 id="结构体变量的引用"><a href="#结构体变量的引用" class="headerlink" title="结构体变量的引用"></a>结构体变量的引用</h2><p>引用结构体变量时应注意：<br>●结构体变量不能作为一个整体而对其进行任何操作，只能对结构体变量中的各个成员分别进行输入和输出等操作。结构体变量中的成员用以下方式引用： 结构体变量名.成员名<br>●如果结构体的某个成员本身又是一个结构体类型，则可以使用若干个成员运算符”.”，一级一级地找到最低的一级成员，只能对最低一级的成员进行赋值或存取运算。<br>●结构体变量的初始化，是指逐个对结构体变量的各个成员进行初始化的过程。</p>
<h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><p>所谓结构体数组，是指数组中的每一个元素都是一个结构体。在实际应用中，C语言结构体数组常被用来表示一个拥有相同数据结构的群体。<br>1.一般形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体变量名&#123;</span></span><br><span class="line">    成员表列</span><br><span class="line">&#125;数组名[常量表达式];</span><br></pre></td></tr></table></figure>
<p>2.结构体数组的初始值应顺序地放在一对花括号中。</p>
<h2 id="结构体指针-指向结构体的指针"><a href="#结构体指针-指向结构体的指针" class="headerlink" title="结构体指针(指向结构体的指针)"></a>结构体指针(指向结构体的指针)</h2><p>当一个指针变量指向结构体时，我们就称它为结构体指针。<br>结构体指针定义形式的一般形：<br>    struct 结构体名 *变量名;</p>
<h3 id="获取结构体成员"><a href="#获取结构体成员" class="headerlink" title="获取结构体成员"></a>获取结构体成员</h3><p>通过结构体指针可以获取结构体成员，一般形式为：<br>    (*pointer).memberName 或 pointer-&gt;memberName</p>
<h3 id="指向结构体数组的指针"><a href="#指向结构体数组的指针" class="headerlink" title="指向结构体数组的指针"></a>指向结构体数组的指针</h3><p>结构体数组及其元素也可用指针指向。在使用指针变量指向结构体数组时，只要把该结构体数组中的每个元素当做普通的结构体变量使用即可。</p>
<h3 id="用结构体变量和指向结构体的指针作为函数参数"><a href="#用结构体变量和指向结构体的指针作为函数参数" class="headerlink" title="用结构体变量和指向结构体的指针作为函数参数"></a>用结构体变量和指向结构体的指针作为函数参数</h3><p>●将一个结构体变量的成员作为实参传递给主调函数。<br>●用结构体变量作为一个整体实参<br>●C语言允许结构体变量的地址作为实参传递，这时对应形参应是一个基类型相同的结构体类型的指针。</p>
<p>▲结构体变量名代表整个集合本身，作为函数参数时传递整个集合，也就是所有成员，而非像数组一样被编译器转换为指针。若成员体较多，则开销大，影响效率。最好的办法是使用结构体指针，由实参向形参传递地址，效率高。</p>
<h3 id="程序示列"><a href="#程序示列" class="headerlink" title="程序示列"></a>程序示列</h3><p>计算全班学生的总成绩，平均成绩和以及140分以下的人数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> *name; <span class="comment">//姓名</span></span><br><span class="line">	<span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line">	<span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line">	<span class="type">char</span> group; <span class="comment">//所在小组</span></span><br><span class="line">	<span class="type">float</span> score; <span class="comment">//成绩</span></span><br><span class="line">&#125;stus[]=&#123;</span><br><span class="line">&#123;<span class="string">&quot;LiPing&quot;</span>,<span class="number">5</span>,<span class="number">18</span>,<span class="string">&#x27;C&#x27;</span>,<span class="number">145.0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;ZhangPing&quot;</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">130.5</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;HeFang&quot;</span>,<span class="number">1</span>,<span class="number">18</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">148.5</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;ChengLing&quot;</span>,<span class="number">2</span>,<span class="number">17</span>,<span class="string">&#x27;F&#x27;</span>,<span class="number">139.0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;WangMing&quot;</span>,<span class="number">3</span>,<span class="number">17</span>,<span class="string">&#x27;B&#x27;</span>,<span class="number">144.5</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> average(<span class="keyword">struct</span> stu *ps,<span class="type">int</span> len)&#123;</span><br><span class="line"><span class="type">int</span> i,num_140 = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> average,num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">	sum+=(ps+i)-&gt;score;</span><br><span class="line">	<span class="keyword">if</span>((ps+i)-&gt;score&lt;<span class="number">140</span>)</span><br><span class="line">	num_140++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sum=%.2f\n average=%.2f\n num_140=%d\n&quot;</span>,sum,sum/s,num_140);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="keyword">sizeof</span>(stus)/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu);</span><br><span class="line">	average(stus,len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>运行结果：
sum=707.50
average=141.50
num_140=2
</code></pre>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>C语言提供的枚举(Enum)类型,能够列出一个标识符的所有可能性。<br>枚举的一般形式为：<br>    enum typeName{valueName1,valueName2,valueName3,…};<br>如:   enum week{Mon,Tues,Wed,Thurs,Fri,Sat,Sun};<br>说明: 枚举值默认从0开始，往后逐个加1(递增)，即Mon、Tues、…Sun对应值分别为0、1…6。<br>枚举值也可指定 如:<br>    enum week{Mon&#x3D;1,Tues&#x3D;2,Wed&#x3D;3,Thurs&#x3D;4,Fri&#x3D;5,Sat&#x3D;6,Sun&#x3D;7};<br>或：<br>    enum week{Mon&#x3D;1,Tues,Wed,Thurs,Fri,Sat,Sun};</p>
<h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>共用体是一种类似结构体的构造数据类型，也包含了多个成员数据。<br>它的一般形式为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名&#123;</span></span><br><span class="line">	成员列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>说明:<br>共用体有时也被称为联合或者联合体，这也是Union的本意。<br>共用体与结构体的区别在于:结构体的各个成员会占用不同的内存，相互之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。<br>结构体占用的内存大于等于所有成员占用的总和(成员之间可能会有缝隙)，共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/02/18/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A09/">https://scholargeek.github.io/2018/02/18/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A09/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>DOS简介与命令</title>
    <url>/2018/01/01/DOS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="DOS简介"><a href="#DOS简介" class="headerlink" title="DOS简介"></a>DOS简介</h1><p>　　DOS（Disk Operating System），是磁盘操作系统的缩写，是个人计算机上的一类操作系统。从1981年直到1995年的15年间，DOS在IBM PC兼容机市场中占有举足轻重的地位。而且，若是把部分以DOS为基础的Microsoft Windows版本，如Windows 95、98和Me等都算入，那么其商业寿命至少可以算到2000年。<br>　　DOS家族包括MS-DOS、PC-DOS、DR-DOS、FreeDOS、PTS-DOS、ROM-DOS、JM-OS等，其中以MS-DOS最为著名。虽然这些系统常被简称为“DOS”，但没有任何一个系统单纯以“DOS”命名（只有一个毫无关连的1960年代IBM大型主机操作系统以此命名）。此外，有几个和DOS无关、在非x86的微计算机系统上执行的磁盘操作系统在名称中也有“DOS”字眼，而且在专门讨论该机器的场合中也会简称为“DOS”（例如：AmigaDOS、AMSDOS、ANDOS、Apple DOS、Atari DOS、Commodore DOS、CSI-DOS、ProDOS、TRS-DOS等），但这些系统和DOS可执行文件以及MS-DOS API并不兼容。</p>
<span id="more"></span>

<h2 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h2><p>　　所有DOS类的操作系统都是在使用Intel x86或其兼容CPU的机器上执行的（主要是IBM PC及其兼容机）。最早的时候，DOS并未受限于此；为了在许多以x86为基础，但和IBM PC不兼容的机器上执行，产生了不少特定机器版本的DOS及类似的操作系统。<br>　　DOS是单一用户、单工的操作系统，拥有不可重入的基本核心函数（意即同时间只能有一个程序调用这些函数）。有一个例外的状况，就是常驻程序（Terminate and Stay Resident，缩写为TSR）。某些常驻程序允许用户多工操作；然而此时仍有“核心不可重入”的问题：当一个进程（process）调用了操作系统核心中的服务函数（也就是系统调用）时，在这个调用结束之前，其他的进程绝对不能进行系统调用、打断第一个进程。<br>　　DOS的核心为用户程序提供了各式各样的函数，例如：在屏幕上显示文字、从键盘读入字符、访问磁盘上的文件等等。</p>
<h3 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h3><p>　　DOS透过批处理文件（扩展名为.BAT）提供界面脚本的功能。这些纯文本格式的脚本文件可以用任何的文本编辑器编辑。他们执行起来和编译而成的程序没有两样。文件中的每一行都被视为命令来执行。批处理文件也可以使用数个内部命令，例如goto和条件表达式。</p>
<h3 id="硬件访问"><a href="#硬件访问" class="headerlink" title="硬件访问"></a>硬件访问</h3><p>　　DOS提供了简单的硬件抽象层，让程序员可以开发文字界面的应用程序；但这个硬件抽象层无法访问大部分的计算机硬件，像是显卡、打印机，或是鼠标等。这使得程序员必须直接访问硬件，导致每个应用程序都有属于自己的一组硬件周边驱动程序。硬件制造商会将他们的硬件规格书发布，以确保在受欢迎的应用程序中有它们的驱动程序。</p>
<h3 id="设备保留名称"><a href="#设备保留名称" class="headerlink" title="设备保留名称"></a>设备保留名称</h3><p>　　在DOS中，有数个名称保留给设备使用，无法拿来当一般文件的名称，且不管扩展名是什么；这些保留名称是用来将应用程序的输出发送给硬件周边用的。这样的限制也影响到数个版本的Windows，在某些情况下甚至会造成死机和安全性弱点。其中一些保留名称有：NUL:、COM1:或AUX:、COM2:、COM3:、COM4:、CON:、LPT1:或PRN:、LPT2:、LPT3:，以及CLOCK$。</p>
<h3 id="磁盘命名法"><a href="#磁盘命名法" class="headerlink" title="磁盘命名法"></a>磁盘命名法</h3><p>　　在DOS中，磁盘驱动器是利用不同的字母命名的。标准的作法是保留“A”和“B”给软盘驱动器。若是系统只有一台软盘驱动器的话，DOS允许这台软盘驱动器同时使用这两个代号，然后DOS会要求用户更换磁片。这么做可以让用户把文件拷贝到不同的软盘上，或是执行某一片软盘上的程序，然后把资料文件存放在另一片软盘上。最早硬盘的代号为“C”和“D”。在一台硬盘驱动器上，DOS只允许一个活动分区的存在。随着支持的硬盘数量越来越多，磁盘代号的命名方法演变为：先将磁盘代号指派给每一颗硬盘驱动器的活动主分区，然后第二轮将代号指派给延伸分区中的逻辑卷，第三轮再把代号指定给非活动的主分区。（前题是：它们存在，而且包含了DOS可以读取的文件系统。）最后，DOS才将代号指派给光盘驱动器、RAM disk，以及其他的硬件。一般来说，磁盘代号都是依照驱动程序的加载顺序，按字母顺序指派的，但驱动程序也可以要求DOS指派不同的字母。例如网络磁盘驱动器的驱动程序通常会指派最后的几个字母。<br>　　因为DOS的应用程序会直接使用这些磁盘代号（和Unix类系统使用／dev目录的方法不同），因此若是新增了需要分配磁盘代号的硬件，可能会导致这些应用程序出错。举例来说：若是原本硬盘中的延伸分区中存在逻辑卷，此时新增一颗有主分区的硬盘的话，由于主分区拥有较高的分配优先权，所以原本硬盘的逻辑卷的代号就会改变。此外，就算是新增一颗只有延伸分区和逻辑卷的硬盘，还是会影响到RAM disk及光盘驱动器的代号。这个问题一直到9x系列的Windows都仍然存在；NT系列才有解决方案：磁盘代号会保留给已存在的磁盘驱动器机，除非用户手动更改。</p>
<h3 id="引导流程"><a href="#引导流程" class="headerlink" title="引导流程"></a>引导流程</h3><p>　　PC兼容机的引导扇区（MBR）位于第 0 扇区。对于DOS来说，这段代码会将DOS的HAL读入存储器中然后执行。在DR DOS及PC DOS中，这个HAL放在IBMBIO.COM文件中；而MS DOS则是放在IO.SYS。接下来这个HAL会加载位于IBMDOS.COM（PC DOS或DR DOS）或是MSDOS.SYS（MS DOS）里面的DOS内核。Windows 9x中附的DOS版本（MS DOS 7和8）将HAL和核心合并放在IO.SYS里面，而MSDOS.SYS则是文字格式的配置文件案。然后DOS核心会去执行CONFIG.SYS这个文件。在CONFIG.SYS中，SHELL这个命令指定了SHELL的文件位置（通常是COMMAND.COM）。接下来这个SHELL会被执行，然后它会去开启开机启动项（通常是AUTOEXEC.BAT）。</p>
<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><h3 id="与Windows的关系"><a href="#与Windows的关系" class="headerlink" title="与Windows的关系"></a>与Windows的关系</h3><p>　　纯32位版本的Windows（从NT开始；包含了2003、XP和Vista）并非以DOS为基础的。这些系统中内含了一个NT DOS虚拟机（NT Virtual DOS Machine，缩写为NTVDM），在上面执行一个修改过的DOS。原本以DOS为基础的系统使用传统的COMMAND.COM做为命令行界面，而Windows NT及其派生版本则是使用cmd.exe（不过cmd.exe也移植了许多DOS的命令）。x64架构的Windows也有cmd.exe（命令提示符），但是无法执行16位DOS程序（没有NTVDM）。</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>　　CMD命令提示符，（command）的缩写，是 Windows 系统中的命令行窗口。Windows 系统内部保留了可以执行 DOS 命令的 CMD 命令行窗口，但CMD 只是一个 Windows 下模拟 DOS 环境的程序，脚本是批处理，语法不完整，逻辑有缺陷。<br>　　CMD可以执行很多 DOS 命令，但是不能运行 DOS 程序。只能调用 Win32 或 Win64 的程序。</p>
<h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>　　Shell 本身是一种用C语言编写的程序，从用户的角度来看，Shell是用户与Linux操作系统沟通的桥梁。用户既可以输入命令执行，又可以利用 Shell 脚本编程，完成更加复杂的操作。Shell是Linux必有的，类似于 DOS 下的 command和后来的CMD。Shell的脚本十分完整，逻辑也严谨。</p>
<h2 id="DOS命令"><a href="#DOS命令" class="headerlink" title="DOS命令"></a>DOS命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>MD</td>
<td>建立子目录</td>
</tr>
<tr>
<td>CD</td>
<td>改变当前目录</td>
</tr>
<tr>
<td>RD</td>
<td>删除子目录命令</td>
</tr>
<tr>
<td>DIR</td>
<td>示磁盘目录命令</td>
</tr>
<tr>
<td>PATH</td>
<td>路径设置命令</td>
</tr>
<tr>
<td>TREE</td>
<td>显示磁盘目录结构命令</td>
</tr>
<tr>
<td>DELTREE</td>
<td>删除整个目录命令</td>
</tr>
<tr>
<td>FORMAT</td>
<td>磁盘格式化命令</td>
</tr>
<tr>
<td>SCANDISK</td>
<td>检查磁盘当前状态命令</td>
</tr>
<tr>
<td>UNFORMAT</td>
<td>恢复格式化命令</td>
</tr>
<tr>
<td>DISKCOPY</td>
<td>整盘复制命令</td>
</tr>
<tr>
<td>VOL</td>
<td>显示磁盘卷标命令</td>
</tr>
<tr>
<td>SCANDISK</td>
<td>检测、修复磁盘命令</td>
</tr>
<tr>
<td>DEFRAG</td>
<td>重整磁盘命令</td>
</tr>
<tr>
<td>SYS</td>
<td>系统复制命令</td>
</tr>
<tr>
<td>COPY</td>
<td>文件复制命令</td>
</tr>
<tr>
<td>XCOPY</td>
<td>目录复制命令</td>
</tr>
<tr>
<td>TYPE</td>
<td>显示文件内容命令</td>
</tr>
<tr>
<td>REN</td>
<td>文件改名命令</td>
</tr>
<tr>
<td>FC</td>
<td>文件比较命令</td>
</tr>
<tr>
<td>ATTRIB</td>
<td>修改文件属性命令</td>
</tr>
<tr>
<td>DEL</td>
<td>删除文件命令</td>
</tr>
<tr>
<td>UNDELETE</td>
<td>恢复删除命令</td>
</tr>
<tr>
<td>VER</td>
<td>查看系统版本号命令</td>
</tr>
<tr>
<td>DATE</td>
<td>查看日期命令</td>
</tr>
</tbody></table>
<h3 id="DOS常用命令例"><a href="#DOS常用命令例" class="headerlink" title="DOS常用命令例"></a>DOS常用命令例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cls  //清屏</span><br><span class="line">cd   //切换目录</span><br><span class="line">cd ..  //进入上一级目录</span><br><span class="line">md test  //创建名为test的文件夹</span><br><span class="line">cd &gt;1.txt  //创建1.txt的文件</span><br><span class="line">rename a.txt b.txt  //将a.txt重命名为b.txt</span><br><span class="line">xcopy b.txt d:\  //将b.txt复制到D盘根目录下</span><br><span class="line">del 1.txt  //删除1.txt文件</span><br></pre></td></tr></table></figure>




<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/01/01/DOS/">https://scholargeek.github.io/2018/01/01/DOS/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>DOS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML简介与基本语法</title>
    <url>/2019/08/28/HTML/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h1><p>　　超文本标记语言（HyperText Markup Language）简称：HTML。是一种用于创建网页的标准标记语言。HTML是一种基础技术，常与CSS、JavaScript一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面。网页浏览器可以读取HTML文件，并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非编程语言。<br>　　HTML元素是构建网站的基石。HTML允许嵌入图像与对象，并且可以用于创建交互式表单，它被用来结构化信息——例如标题、段落和列表等等，也可用来在一定程度上描述文档的外观和语义。HTML的语言形式为尖括号包围的HTML元素（如<html>），浏览器使用HTML标签和脚本来诠释网页内容，但不会将它们显示在页面上。<br>　　HTML可以嵌入如JavaScript的脚本语言，它们会影响HTML网页的行为。网页浏览器也可以引用层叠样式表（CSS）来定义文本和其它元素的外观与布局。维护HTML和CSS标准的组织万维网联盟（W3C）鼓励人们使用CSS替代一些用于表现的HTML元素。</html></p>
<span id="more"></span>

<h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>起始标记、网页标题、文件主体。<br>经典HTML例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>This is a title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><strong>标题</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>大标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>最小标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注释</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释 --&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>水平线</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>换行</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>一个空格</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span><br></pre></td></tr></table></figure>
<p><strong>段落</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>图片标签</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;_url_&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;_some_text_&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>超链接</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>  <span class="attr">href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>链接文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>无序列表</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>你<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>我<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>他<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>有序列表</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;A&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>你<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>我<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>他<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>表格标签</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>列标题3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>表单方法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FORM</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;result.html&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">FORM</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中method即为http请求方法，可以选择使用 get 或 post<br>● get是不安全的，在请求传输过程中数据被放在请求的URL中；而post的所有操作数据对用户完全不可见。<br>● get传送的数据量小，主要因为URL长度限制；而post传送的数据量较大，一般不被限制。</p>
<p>注意：表单组件必须被FORM标签包含，否则登陆清空按钮的操作无效。</p>
<p><strong>表单组件</strong><br>【文本框与按钮】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>用户登陆<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 单行文本框，可添加placeholder=&quot;xxx&quot; 提示文本 --&gt;</span></span><br><span class="line">账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 密码框 --&gt;</span></span><br><span class="line">密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 登陆按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登陆&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 清空按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清空&quot;</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数字文本框，被限制仅能输入数字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>【单项选择按钮】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> /&gt;</span> 男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> <span class="attr">checked</span> /&gt;</span> 女</span><br><span class="line"><span class="comment">&lt;!-- 使男女单选互斥，仅选择一个，必须将name名命名相同 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>【多项选择按钮】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">爱好：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cf&quot;</span> /&gt;</span>吃饭</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sj&quot;</span> /&gt;</span>睡觉</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xx&quot;</span> /&gt;</span>学习</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ddd&quot;</span> /&gt;</span>打豆豆</span><br><span class="line"><span class="comment">&lt;!-- 将一组数据打包须使name名相同；默认选中需添加checked --&gt;</span></span><br></pre></td></tr></table></figure>
<p>【上传框】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>【下拉框】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">籍贯：</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;bj&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;sh&quot;</span> <span class="attr">selected</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;gz&quot;</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>【多行文本框】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">备注：<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;80&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>【浮动窗口】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">&quot;20%&quot;</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./sy.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;wc&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./xc.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;wc&quot;</span>&gt;</span>我的相册<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./rj.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;wc&quot;</span>&gt;</span>我的日记<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;./sy.html&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">name</span>=<span class="string">&quot;wc&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>


<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/08/28/HTML/">https://scholargeek.github.io/2019/08/28/HTML/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化10</title>
    <url>/2019/07/24/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9610/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="给HEXO博客添加-Live2d小人"><a href="#给HEXO博客添加-Live2d小人" class="headerlink" title="给HEXO博客添加 Live2d小人"></a>给HEXO博客添加 Live2d小人</h1><p>Live2D是一种应用于电子游戏的绘图渲染技术，通过一系列的连续图像和人物建模来生成一种类似三维模型的二维图像，缺点是Live 2D人物无法大幅度转身，开发商正设法让该技术可显示360度图像。添加Live2D人物模型到网页中使得页面更加生动有趣，本文将详述如何将Live2d小人添加到Hexo博客中。</p>
<span id="more"></span>
<h2 id="安装live2d模块"><a href="#安装live2d模块" class="headerlink" title="安装live2d模块"></a>安装live2d模块</h2><p>在博客已搭建好之后，使用PowerShell进入博客目录。使用命令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d </span><br></pre></td></tr></table></figure>
<p>安装hexo-helper-live2d模块,以便使用。</p>
<h2 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h2><p>在根目录下的_config.yml添加配置，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line"> enable: true # 是否启动</span><br><span class="line"> scriptFrom: local # 默认</span><br><span class="line"> pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径)</span><br><span class="line"> pluginJsPath: lib/ # 脚本文件相对与插件根目录路径</span><br><span class="line"> pluginModelPath: assets/ # 模型文件相对与插件根目录路径</span><br><span class="line"> tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br><span class="line"> debug: false # 调试, 是否在控制台输出日志</span><br><span class="line"> model:</span><br><span class="line"> use: live2d-widget ## 模型文件</span><br><span class="line"> display:</span><br><span class="line"> position: right # 定位方向 left right top bottom</span><br><span class="line"> width: 150 # 小人宽度</span><br><span class="line"> height: 300 # 小人高度</span><br><span class="line"> hOffset: -15 # 向 偏移</span><br><span class="line"> vOffset: -15 # 像 偏移</span><br><span class="line"> mobile:</span><br><span class="line"> show: true # 手机端是否显示</span><br><span class="line"> react:</span><br><span class="line"> opacity: 0.7 # 模型透明度</span><br></pre></td></tr></table></figure>
<h2 id="选择模型"><a href="#选择模型" class="headerlink" title="选择模型"></a>选择模型</h2><p>可选择的模型如下表：<br>| 模型图片| 命令 |</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/19/52c131ea792aec46.png" alt="chitose">  live2d-widget-model-chitose<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/0005788207b1f4ff.png" alt="epsilon2_1">  live2d-widget-model-epsilon2_1<br> <img src="https://s3.bmp.ovh/imgs/2023/01/19/5420a69a96bb0848.png" alt="gf">  live2d-widget-model-gf<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/a2c92984122ebc93.png" alt="haru/01">  live2d-widget-model-haru&#x2F;01<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/c7529874b0571a16.png" alt="haruto">  live2d-widget-model-haruto<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/50aad6578c5c6f64.png" alt="hibiki">  live2d-widget-model-hibiki<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/1c66642e651fcd6d.png" alt="hijiki">  live2d-widget-model-hijiki<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/b813f92bb40940d7.png" alt="izumi">  live2d-widget-model-izumi<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/e24b1c73d872919d.png" alt="koharu">  live2d-widget-model-koharu<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/7e40a3ada1dd12a2.png" alt="miku">  live2d-widget-model-miku<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/31a18f5006ef48e4.png" alt="ni-j">  live2d-widget-model-ni-j<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/61ea005a7d842cd2.png" alt="nico">  live2d-widget-model-nico<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/8c6363996d3286a1.png" alt="nietzsche">  live2d-widget-model-nietzsche<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/97930b43a220f221.png" alt="nipsilon">  live2d-widget-model-nipsilon<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/feb297255b99db75.png" alt="nito">  live2d-widget-model-nito<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/c2cd7e8a21487780.png" alt="shizuku">  live2d-widget-model-shizuku<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/18dd33bfba9811c7.png" alt="tororo">  live2d-widget-model-tororo<br><img src="https://s3.bmp.ovh/imgs/2023/01/19/ebeb3f3c2cdaf0e2.png" alt="tsumiki">  live2d-widget-model-tsumiki</p>
<h2 id="下载模型并加载"><a href="#下载模型并加载" class="headerlink" title="下载模型并加载"></a>下载模型并加载</h2><p>选择合适的模型后，在PowerShell中使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save live2d-widget-model-xxx</span><br></pre></td></tr></table></figure>
<p>下载模型,如模型chitose即在PowerShell中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm  install  –save live2d-widget-model-chitose</span><br></pre></td></tr></table></figure>
<p>即在\blog\node_modules\ 目录下下载好live2d-widget-model-chitose文件,在根目录下新建<code>live2d_models</code>的文件夹并将下载的模型复制到该文件夹下。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>最后编辑配置文件，打开根目录下的_config.yml，在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model:</span><br><span class="line">use: live2d-widget ## 模型文件</span><br></pre></td></tr></table></figure>
<p>中，修改<code>use:</code>后面的模型文件名称为live2d-widget-model-chitose ,保存即可。</p>
<p><strong>使用 Hexo clean清除游览器缓存，再使用 Hexo g生成网页，最后用 Hexo d 部署，打开网页后就有个小人在屏幕的右下角看你了。</strong></p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/24/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9610/">https://scholargeek.github.io/2019/07/24/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9610/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客部署过程的问题1</title>
    <url>/2019/08/01/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%981/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo博客推送到GitHub上产生的问题"><a href="#Hexo博客推送到GitHub上产生的问题" class="headerlink" title="Hexo博客推送到GitHub上产生的问题"></a>Hexo博客推送到GitHub上产生的问题</h1><p>在博客搭建与部署的过程中发生了一些错误，现在对问题进行描述并提供解决方法。</p>
<span id="more"></span>
<h2 id="ERROR-Deployer-not-found-git"><a href="#ERROR-Deployer-not-found-git" class="headerlink" title="ERROR Deployer not found: git"></a>ERROR Deployer not found: git</h2><p>问题：使用git命令时显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>
<p>解决方法：在Bash或Powershell中输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure>
<h2 id="配置SSH命令"><a href="#配置SSH命令" class="headerlink" title="配置SSH命令"></a>配置SSH命令</h2><p>问题：仅在配置_config.yml中配置了repo: https,但未在Github设置中配置SSH,会在推送博文中产生安全隐患，且每次都需输入用户名及邮箱，十分麻烦。<br>解决方法：配置SSH，在GitBash中输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh //检查是否有.ssh的文件夹</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C “xxx@mail.com” //配置ssh，引号中内容替换为注册时的邮箱地址</span><br></pre></td></tr></table></figure>
<p>三次回车后，即在C\Users\admin.ssh路径中生成了两个文件：id_rsa和id_rsa.pub。<br>再输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval &quot;$(ssh-agent -s)&quot; //添加密钥到ssh-agent</span><br><span class="line"></span><br><span class="line"> ssh-add ~/.ssh/id_rsa        //添加生成的SSH key到ssh-agent</span><br></pre></td></tr></table></figure>
<p>登录Github，点击头像下的settings，添加ssh。<br>将C\Users\admin.ssh路径下的id_rsa.pub文件内容复制到ssh key中去，保存即可。</p>
<p>最后验证：在GitBash中输入ssh -T <a href="mailto:git@github.com">git@github.com</a> 回车后询问是否进行连接，输入yes回车后，若回显为：You’ve successfully authenticated 则配置成功。</p>
<h2 id="显示登陆失败，但输入密码正确"><a href="#显示登陆失败，但输入密码正确" class="headerlink" title="显示登陆失败，但输入密码正确"></a>显示登陆失败，但输入密码正确</h2><p>问题：输入密码无效<br>原因：由于GitHub在21年8月13 后不再支持用户名密码的方式验证，需要创建个人访问令牌(personal access token)<br>解决方法：<br>登陆github网站，在个人选项中依次选择-&gt;settings-&gt;Developer settings(settings 的最下方）-&gt;Personal access tokens-&gt;选择“Generate a personal access token”<br>如下图：<br><img src="https://s3.bmp.ovh/imgs/2023/01/20/322ec5d1a6a653f9.png" alt="GitHub_Token1"><br><img src="https://s3.bmp.ovh/imgs/2023/01/20/73c18451b6309e81.png" alt="GitHub_Token2"><br><img src="https://s3.bmp.ovh/imgs/2023/01/20/7f1281483ac32874.png" alt="GitHub_Token3"><br><img src="https://s3.bmp.ovh/imgs/2023/01/20/c41936664e5d9e15.png" alt="GitHub_Token4"><br>生成Token后复制保存到安全位置，此后推送博文使用Token代替密码。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/08/01/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%981/">https://scholargeek.github.io/2019/08/01/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E8%BF%87%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%981/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化1</title>
    <url>/2019/07/15/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%961/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自动切换Hexo博客的banner图片"><a href="#自动切换Hexo博客的banner图片" class="headerlink" title="自动切换Hexo博客的banner图片"></a>自动切换Hexo博客的banner图片</h1><h2 id="改造默认主题landscape"><a href="#改造默认主题landscape" class="headerlink" title="改造默认主题landscape"></a>改造默认主题landscape</h2><p>   Hexo自带的landscape主题很好，首先呈现在眼前的是300px的banner,很有美感。一个精美的banner会吸引访客,建立对网站的第一印象。静态一张图片长时间显示会很无趣，要是能够有多张图片滚动播放就好了，比如每十分钟换一张图片，那么如何改造landscape主题呢？下面我将具体介绍</p>
<span id="more"></span>
<pre><code>首先添加随机切换图片的脚本，在themes/landscape/layout/_partial/下新建一个ejs文件，将其命名为switch-banner.ejs，其中是用于切换banner图片的Javascript代码，该文件内容如下:
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"> &lt;% if (theme.switch_banner)&#123; %&gt;</span><br><span class="line"> var d = new Date();</span><br><span class="line"> var m = d.getMinutes();</span><br><span class="line"> var num = Math.ceil((m + 1) / (60 / &lt;%- theme.banner_count %&gt;));</span><br><span class="line"> document.getElementById(&quot;banner&quot;).style.backgroundImage = &quot;url(/css/images/banner&quot; + num + &quot;.jpg)&quot;;</span><br><span class="line"> &lt;% &#125; else &#123; %&gt;</span><br><span class="line"> document.getElementById(&quot;banner&quot;).style.backgroundImage = &quot;url(/css/images/banner.jpg)&quot;;</span><br><span class="line"> &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<pre><code>即通过JavaScript的Date对象的getMinutes()来获取当前时间的分钟数，该数为0～59的整数，经过运算映射到图片的文件名的编号。
还需要在主题目录下的配置文件中设置图片数量，即可灵活配置图片张数。即在themes/landscape/_config.yml中添加一行banner_count: 6 请根据实际图片的张数来修改这个数字。
然后然后找来6张不同的banner图片，图片像素值最好和默认的一样为1920X1200，大小最好不超过300K。banner图片要放到themes/landscape/source/css/images/目录下，命名为banner*.jpg，其中的星号是一个数字。6张图片必须连续地使用1～6这6个数字。
再修改布局文件来调用这段脚本：在themes/landscape/layout/_partial/header.ejs的最后一行（&lt;/header&gt;标记）之前加入代码 &lt;%- partial(&#39;switch-banner&#39;) %&gt; 即可。
还需要修改主题配置文件才能开启功能，即在themes/landscape/_config.yml中添加代码switch_banner: true 即可
测试发现上述设置后游览器还会请求原来的旧图片，所以还需要修改CSS。打开文件themes/landscape/source/css/_partial/header.styl 找到#banner这一节，将其中的background: url(banner-url) center #000改成background: center #000 即可。
最后对banner图片进行说明，由于图片尺寸较大，会占用较多的网络带宽，对网页的速度带来影响。所以应该设置一个较高的JPEG压缩比，在Photoshop中将质量参数设为5或者6，使图片的大小控制在100KB左右。

做完上述所有设置即可使Hexo博客landscape主题中的banner背景图片每十分钟切换一次，一个小时可以展示6张图片，滚动播放使博客有趣生动。
</code></pre>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/15/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%961/">https://scholargeek.github.io/2019/07/15/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%961/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化11</title>
    <url>/2019/07/26/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9611/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="给博客添加点击出现爱心的效果"><a href="#给博客添加点击出现爱心的效果" class="headerlink" title="给博客添加点击出现爱心的效果"></a>给博客添加点击出现爱心的效果</h1><p>本文将详述如何使博客网站在用户点击时出现爱心的效果。</p>
<span id="more"></span>

<h2 id="新建JS代码"><a href="#新建JS代码" class="headerlink" title="新建JS代码"></a>新建JS代码</h2><p>在 \blog\themes\landscape\source\js下新建文件 love.js，在 love.js 文件中添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br></pre></td></tr></table></figure>
<h2 id="添加JS代码"><a href="#添加JS代码" class="headerlink" title="添加JS代码"></a>添加JS代码</h2><p>在 \blog\themes\landscape\layout\layout.ejs 文件末尾添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/love.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>完成以上操作后，当我们游览博客点击鼠标时就可以看见爱心的特效了。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/26/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9611/">https://scholargeek.github.io/2019/07/26/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9611/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化12</title>
    <url>/2019/07/26/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9612/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="给博客背景添加动态线条效果"><a href="#给博客背景添加动态线条效果" class="headerlink" title="给博客背景添加动态线条效果"></a>给博客背景添加动态线条效果</h1><p>如果想继续美化博客的背景，可以在背景上添加动态线条，本文将表述如何给博客背景添加动态线条。</p>
<span id="more"></span>
<p>在 \blog\themes\landscape\layout\layout.ejs 文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--动态线条背景--&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;</span><br><span class="line"></span><br><span class="line">color=&quot;220,220,220&quot; opacity=&#x27;0.7&#x27; zIndex=&quot;-2&quot; count=&quot;200&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/26/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9612/">https://scholargeek.github.io/2019/07/26/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9612/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化13</title>
    <url>/2019/07/27/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9613/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="给博客添加背景音乐"><a href="#给博客添加背景音乐" class="headerlink" title="给博客添加背景音乐"></a>给博客添加背景音乐</h1><p>一个成熟的博客网站想变的生动是不能没有音乐的，本文将详述如何将背景音乐播放器添加到侧边栏。</p>
<span id="more"></span>
<h2 id="获取播放器外链"><a href="#获取播放器外链" class="headerlink" title="获取播放器外链"></a>获取播放器外链</h2><p>打开网页版网易云音乐，选择你准备添加的背景音乐，点击生成外链播放器，前提是要有版权，否则无法生成外链播放器，复制底下的HTML代码。</p>
<h2 id="新建JS文件"><a href="#新建JS文件" class="headerlink" title="新建JS文件"></a>新建JS文件</h2><p>在\blog\themes\landscape\layout_widget\ 路径下新建music.ejs文件，将复制的代码放入其中，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;widget-wrap&quot;&gt;</span><br><span class="line"></span><br><span class="line"> &lt;h3 class=&quot;widget-title&quot;&gt;音乐&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line"> &lt;div class=&quot;widget&quot;&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>修改主题的配置文件,在\blog\themes\landscape\ 路径下的_config.yml文件中添加标签，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">widgets:</span><br><span class="line">- music</span><br></pre></td></tr></table></figure>
<p>完成上述设置即可在右侧菜单栏显示音乐播放器。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/27/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9613/">https://scholargeek.github.io/2019/07/27/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9613/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化14</title>
    <url>/2019/07/28/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9614/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="修改博客中导航栏的颜色与字体"><a href="#修改博客中导航栏的颜色与字体" class="headerlink" title="修改博客中导航栏的颜色与字体"></a>修改博客中导航栏的颜色与字体</h1><p>Hexo博客默认主题landscape中的导航栏字体太小，背景色太单调，如果想设置该怎么办呢？本文将详述导航栏颜色与字体的设置。</p>
<span id="more"></span>
<p>打开\blog\themes\landscape\source\css_partial目录下的header.styl 文件，做如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#header</span><br><span class="line"></span><br><span class="line"> height: banner-height</span><br><span class="line"></span><br><span class="line"> position: relative</span><br><span class="line"></span><br><span class="line"> border-bottom: 1px solid color-border</span><br><span class="line"></span><br><span class="line"> &amp;:before, &amp;:after</span><br><span class="line"></span><br><span class="line"> content: &quot;&quot;</span><br><span class="line"></span><br><span class="line"> position: absolute</span><br><span class="line"></span><br><span class="line"> left: 0</span><br><span class="line"></span><br><span class="line"> right: 0</span><br><span class="line"></span><br><span class="line"> height: 55px #此处有修改，更改导航栏高度，默认40px</span><br><span class="line"></span><br><span class="line"> &amp;:before</span><br><span class="line"></span><br><span class="line"> top: 0</span><br><span class="line"></span><br><span class="line"> background: linear-gradient(red, transparent)</span><br><span class="line"></span><br><span class="line">#此处有修改，更改导航栏渐变颜色，默认linear-gradient(rgba(0, 0, 0, 0.2), transparent)</span><br><span class="line"></span><br><span class="line">#main-nav</span><br><span class="line"></span><br><span class="line"> float: left</span><br><span class="line"></span><br><span class="line"> font-size: 18px</span><br><span class="line"></span><br><span class="line">#此处有添加，更改导航栏字体的大小，默认font-size=14px</span><br><span class="line"></span><br><span class="line">.nav-icon</span><br><span class="line"></span><br><span class="line"> @extend $nav-link</span><br><span class="line"></span><br><span class="line"> font-family: font-icon</span><br><span class="line"></span><br><span class="line"> text-align: center</span><br><span class="line"></span><br><span class="line"> font-size: 18px #更改导航栏图标的大小，默认font-size=font-size</span><br></pre></td></tr></table></figure>
<p>按照代码中注释所述按需进行修改即可。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/28/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9614/">https://scholargeek.github.io/2019/07/28/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9614/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化15</title>
    <url>/2019/07/30/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9615/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="给博客导航栏添加日历"><a href="#给博客导航栏添加日历" class="headerlink" title="给博客导航栏添加日历"></a>给博客导航栏添加日历</h1><p>美观的博客一般都有事件日历，如wordpress日历插件一般，使用户一眼就能看出本月有哪些天推送了博文，方便按时间查找文档。本文将详述Hexo博客侧边栏如何添加日历。</p>
<span id="more"></span>
<h2 id="安装日历插件"><a href="#安装日历插件" class="headerlink" title="安装日历插件"></a>安装日历插件</h2><p>使用PowerShell进入博客目录，执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save git://github.com/howiefh/hexo-generator-calendar.git</span><br></pre></td></tr></table></figure>
<p>即可安装calendar插件。</p>
<h2 id="添加JS文件"><a href="#添加JS文件" class="headerlink" title="添加JS文件"></a>添加JS文件</h2><p>此外还需在如下目录添加文件<br>\blog\themes\landscape\layout_widget\calendar.ejs<br>\blog\themes\landscape\source\js\languages.js<br>\blog\themes\landscape\source\js\calendar.js<br>\blog\themes\landscape\source\css_partial\calendar.styl</p>
<p>在\blog\themes\landscape\source\css_variables.styl中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">color-calendar-border = #d1d1d1  color-calendar-post-bg = #007acc  color-calendar-hover-bg = #686868</span><br></pre></td></tr></table></figure>
<p>在\blog\themes\landscape\layout_partial\after-footer.ejs中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;% if (theme.widgets.indexOf(&#x27;calendar&#x27;) != -1)&#123; %&gt;</span><br><span class="line"> &lt;%- js(&#x27;js/languages&#x27;) %&gt;</span><br><span class="line"> &lt;%- js(&#x27;js/calendar&#x27;) %&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> $(function() &#123;</span><br><span class="line"> &lt;% if (typeof theme.calendar.options === &#x27;object&#x27;) &#123; %&gt;</span><br><span class="line"> $(&#x27;#calendar&#x27;).aCalendar(&#x27;&lt;%= theme.calendar.language || config.language %&gt;&#x27;, $.extend(&lt;%- JSON.stringify(theme.calendar.options) %&gt;, &#123;root:&#x27;&lt;%= config.root %&gt;&#x27;, calendarSingle:&lt;%= config.calendar.single %&gt;, calendarRoot:&#x27;&lt;%= config.calendar.root %&gt;&#x27;&#125;));</span><br><span class="line"> &lt;% &#125; else &#123; %&gt;</span><br><span class="line"> $(&#x27;#calendar&#x27;).aCalendar(&#x27;&lt;%= theme.calendar.language || config.language %&gt;&#x27;, &#123;root:&#x27;&lt;%= config.root %&gt;&#x27;, calendarSingle:&lt;%= config.calendar.single %&gt;, calendarRoot:&#x27;&lt;%= config.calendar.root %&gt;&#x27;&#125;);</span><br><span class="line"> &lt;% &#125; %&gt;</span><br><span class="line">  &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<h2 id="设置配置文件"><a href="#设置配置文件" class="headerlink" title="设置配置文件"></a>设置配置文件</h2><p>在博客根目录配置文件_config.yml中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">calendar:</span><br><span class="line"> single: true</span><br><span class="line"> root: calendar/</span><br></pre></td></tr></table></figure>
<p>在主题\blog\themes\landscape目录下的配置文件config.yml中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">calendar:</span><br><span class="line"> language: zh-CN</span><br><span class="line"> options:</span><br><span class="line"> months: [&#x27;January&#x27;, &#x27;February&#x27;, &#x27;March&#x27;, &#x27;April&#x27;, &#x27;May&#x27;, &#x27;June&#x27;, &#x27;July&#x27;, &#x27;August&#x27;, &#x27;September&#x27;, &#x27;October&#x27;, &#x27;November&#x27;, &#x27;December&#x27;]</span><br><span class="line"> dayOfWeekShort: [&#x27;S&#x27;, &#x27;M&#x27;, &#x27;T&#x27;, &#x27;W&#x27;, &#x27;T&#x27;, &#x27;F&#x27;, &#x27;S&#x27;]</span><br><span class="line"> dayOfWeek: [&#x27;Sunday&#x27;, &#x27;Monday&#x27;, &#x27;Tuesday&#x27;, &#x27;Wednesday&#x27;, &#x27;Thursday&#x27;, &#x27;Friday&#x27;, &#x27;Saturday&#x27;]</span><br><span class="line"> postsMonthTip: &#x27;Posts published in LMM yyyy&#x27;</span><br><span class="line">   titleFormat: &#x27;yyyy LMM&#x27;</span><br><span class="line"> titleLinkFormat: &#x27;archives/yyyy/MM/&#x27;</span><br><span class="line"> headArrows: &#123;previous: &#x27;&lt;span class=&quot;cal-prev&quot;&gt;&lt;/span&gt;&#x27;, next: &#x27;&lt;span class=&quot;cal-next&quot;&gt;&lt;/span&gt;&#x27;&#125;</span><br><span class="line"> footArrows: &#123;previous: &#x27; &#x27;, next: &#x27; &#x27;&#125;</span><br><span class="line"> weekOffset: 0</span><br><span class="line"> calendarSingle: false</span><br><span class="line">  calendarRoot: &#x27;calendar/&#x27;</span><br><span class="line"> calendarUrl: &#x27;calendar.json&#x27;</span><br></pre></td></tr></table></figure>
<p>完成上述设置后，博客的侧边栏中就添加好了日历。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/30/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9615/">https://scholargeek.github.io/2019/07/30/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9615/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化16</title>
    <url>/2019/07/31/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9616/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="给博客中导航栏添加GitHub快捷链接"><a href="#给博客中导航栏添加GitHub快捷链接" class="headerlink" title="给博客中导航栏添加GitHub快捷链接"></a>给博客中导航栏添加GitHub快捷链接</h1><p>技术博客的内容一般与GitHub有密切联系，给博客导航栏添加快捷按钮十分方便开发者。<br>本文将详述如何给导航栏添加快捷链接。</p>
<span id="more"></span>
<ol>
<li><p>首先打开<a href="https://tholman.com/github-corners/">https://tholman.com/github-corners/</a> 选择合适的样式并复制源码</p>
</li>
<li><p>把复制的源码粘贴到\blog\themes\landscape\layout\ layout.ejs 中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>下方，保存文件即可。</p>
</li>
</ol>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/31/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9616/">https://scholargeek.github.io/2019/07/31/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%9616/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化2</title>
    <url>/2019/07/16/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%962/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编辑Hexo博客侧边栏与底边栏"><a href="#编辑Hexo博客侧边栏与底边栏" class="headerlink" title="编辑Hexo博客侧边栏与底边栏"></a>编辑Hexo博客侧边栏与底边栏</h1><p>本文将详述如何修改菜单栏、分类栏、标签栏和底边栏，以达到美化博客的效果。</p>
<span id="more"></span>

<h2 id="编辑默认主题的菜单栏"><a href="#编辑默认主题的菜单栏" class="headerlink" title="编辑默认主题的菜单栏"></a>编辑默认主题的菜单栏</h2><pre><code>菜单栏在页面之顶，编辑blog\themes\landscape\_config.yml文件，设置其menu：后的标识符，且创建相应的Page文件即可，（快速创建菜单文件可以使用Hexo Admin插件）即使用游览器访问[http://localhost:4000/admin/#/pages](http://localhost:4000/admin/#/pages)即可添加菜单栏。
</code></pre>
<h2 id="给默认主题分类栏添加QQ空间Link友链"><a href="#给默认主题分类栏添加QQ空间Link友链" class="headerlink" title="给默认主题分类栏添加QQ空间Link友链"></a>给默认主题分类栏添加QQ空间Link友链</h2><pre><code>分类栏在页面之侧，编辑blog\themes\landscape\_config.yml文件，设置其Sidebar的功能。其中sidebar: right 即将分类栏放在右侧，其widgets:之后设置添加分类的标识符。如下设置：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">widgets:</span><br><span class="line">- category</span><br><span class="line">- archive</span><br><span class="line">- recent_posts</span><br><span class="line">- tag</span><br><span class="line">- tagcloud</span><br><span class="line">- link</span><br></pre></td></tr></table></figure>
<pre><code>如上添加了link分类，但需要创建blog\themes\landscape\layout\_widget\link.ejs 文件，编辑如下内容以便引用：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;widget-wrap&quot;&gt;</span><br><span class="line"> &lt;h3 class=&quot;widget-title&quot;&gt;LINKS&lt;/h3&gt;</span><br><span class="line"> &lt;div class=&quot;widget&quot;&gt;</span><br><span class="line">  &lt;ul class=&quot;entry&quot;&gt;</span><br><span class="line"> &lt;li&gt;&lt;a href=&quot;https://XXX&quot; title=&quot;我的QQ空间&quot;&gt;QQ空间&lt;/a&gt;：Do what we want&lt;/li&gt;</span><br><span class="line"> &lt;/ul&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>在 href&#x3D;”<a href="https://xxx/">https://XXX</a>“ 中将XXX更改为自己的QQ空间地址即可。</p>
<h2 id="编辑标签栏使文章归类"><a href="#编辑标签栏使文章归类" class="headerlink" title="编辑标签栏使文章归类"></a>编辑标签栏使文章归类</h2><pre><code>标签栏在分类栏**Categories** 之中。编辑blog\_config.yml，设置其中# Category &amp; Tag之后的标识符，如下：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default_category: default</span><br><span class="line">category_map:</span><br><span class="line">  默认分类: default</span><br><span class="line">  日志: Log</span><br><span class="line">  教程: Tutorial</span><br><span class="line">  编程: Programming</span><br><span class="line">  DIY: Doityouself</span><br></pre></td></tr></table></figure>
<pre><code>设置好后，须在每一篇文章的首部标识其所属的标签，方可指向标签栏，至少有一篇文章包含设置的标签，方可显示在标签栏中。
    编辑首部如下：
</code></pre>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 日志一</span><br><span class="line">author: DSL</span><br><span class="line">date: 2019-07-16 12:33:39</span><br><span class="line">categories: 日志</span><br><span class="line">tags:</span><br></pre></td></tr></table></figure>
<pre><code>其中categories: 之后即为所属标签，产生的效果即在标签栏中显示有 日志 并指向含有 日志一 的归类网页。
</code></pre>
<h2 id="编辑底边栏中的内容和链接"><a href="#编辑底边栏中的内容和链接" class="headerlink" title="编辑底边栏中的内容和链接"></a>编辑底边栏中的内容和链接</h2><pre><code>底边栏在页面之底，修改blog\_config.yml中的作者和blog\themes\landscape\layout\_partial\footer.ejs中
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">href=&quot;https://scholargeek.github.io/&quot; target=&quot;_blank&quot;&gt;DSL&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<pre><code>的代码即可。
</code></pre>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/16/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%962/">https://scholargeek.github.io/2019/07/16/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%962/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化3</title>
    <url>/2019/07/17/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%963/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使Hexo博客根据文章标识自动添加目录"><a href="#使Hexo博客根据文章标识自动添加目录" class="headerlink" title="使Hexo博客根据文章标识自动添加目录"></a>使Hexo博客根据文章标识自动添加目录</h1><p>Hexo博客系统的核心支持生成目录（Table of Contents），但其默认的主题Landscape并不支持目录的显示。本文将详述如何使博文自动添加目录</p>
<span id="more"></span>
<h2 id="如何自动生成目录"><a href="#如何自动生成目录" class="headerlink" title="如何自动生成目录"></a>如何自动生成目录</h2><pre><code>只需对Landscape的主题文件简单修改并添加目录的CSS样式，就可以在文章前面显示友好的目录了。
首先要编辑文章显示页面的模板，也就是themes/landscape/layout/_partial/article.ejs文件。为了将目录生成在正文之前，首先在这个文件中找到&lt;%- post.content %&gt;，并在这一行之前加入如下代码：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Table of Contents --&gt;</span><br><span class="line">&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt;</span><br><span class="line"> &lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt;</span><br><span class="line"> &lt;strong class=&quot;toc-title&quot;&gt;文章目录&lt;/strong&gt;</span><br><span class="line"> &lt;%- toc(post.content) %&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<pre><code>但仅仅如此，显示并不美观。接着修改themes/landscape/source/css/_partial/article.styl文件，在文件内容的最后，添加如下代码：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*toc*/</span><br><span class="line">.toc-article</span><br><span class="line"> background #eee</span><br><span class="line"> border 1px solid #bbb</span><br><span class="line"> border-radius 10px</span><br><span class="line"> margin 1.5em 0 0.3em 1.5em</span><br><span class="line"> padding 1.2em 1em 0 1em</span><br><span class="line"> max-width 28%</span><br><span class="line">.toc-title</span><br><span class="line"> font-size 120%</span><br><span class="line">#toc</span><br><span class="line"> line-height 1em</span><br><span class="line"> font-size 0.9em</span><br><span class="line"> float right</span><br><span class="line"> .toc</span><br><span class="line"> padding 0</span><br><span class="line"> margin 1em</span><br><span class="line"> line-height 1.8em</span><br><span class="line"> li</span><br><span class="line"> list-style-type none</span><br><span class="line"> .toc-child</span><br><span class="line"> margin-left 1em</span><br></pre></td></tr></table></figure>
<pre><code>代码释义：toc-article指定了目录整个&lt;div&gt;的背景色、边框色、倒角半径、各种间距以及最大的宽度。注意这里最好指定目录的最大宽度，我将其设为了28%，也就是文章正文那个框的宽度的28%，也可以设为一个固定的长度，为了能适配各种不同尺寸的屏幕，最好还是设置为百分比。如果不指定最大宽度，遇到比较长的标题时，生成的目录会非常难看。toc-title指的就是“文章目录”那四个字，这四个字要比其他字大一些，将其字号设为其他字的120%。#toc.toc指定了目录列表的一些细节，将font-size设为0.9em会让目录的字比文章的字稍小一些。最后的.toc-child指定了二级目录的缩进量。
</code></pre>
<p>如果想使Markdown文件的博文生成目录，则需要在编辑MD文章开头的front-matter（—之前的区域）中添加一句toc: true 即可为此篇文章添加目录。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/17/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%963/">https://scholargeek.github.io/2019/07/17/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%963/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化4</title>
    <url>/2019/07/18/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%964/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自动使每篇文章附带版权信息"><a href="#自动使每篇文章附带版权信息" class="headerlink" title="自动使每篇文章附带版权信息"></a>自动使每篇文章附带版权信息</h1><p>现今大多数网站的内容都有版权保护，如何给自己的Hexo博客网站的每篇文章添加版权信息呢？本文将详述如何自动为博文添加版权。</p>
<span id="more"></span>
<h2 id="在JS中添加自动附带版权的功能"><a href="#在JS中添加自动附带版权的功能" class="headerlink" title="在JS中添加自动附带版权的功能"></a>在JS中添加自动附带版权的功能</h2><p>在blog\scripts\tail-copyright.js中编辑如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Add a tail to every post from tail.md</span><br><span class="line">// Great for adding copyright info</span><br><span class="line"></span><br><span class="line">var fs = require(&#x27;fs&#x27;);</span><br><span class="line">hexo.extend.filter.register(&#x27;before_post_render&#x27;, function(data)&#123;</span><br><span class="line"> if(data.copyright == false) return data;</span><br><span class="line"> var file_content = fs.readFileSync(&#x27;tail.md&#x27;);</span><br><span class="line"> if(file_content &amp;&amp; data.content.length &gt; 50)</span><br><span class="line"> &#123;</span><br><span class="line"> data.content += file_content;</span><br><span class="line"> var permalink = &#x27;\n本文永久链接：&#x27; + data.permalink;</span><br><span class="line"> data.content += permalink;</span><br><span class="line"> &#125;</span><br><span class="line"> return data;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>脚本功能会自动检查文章的长度，当文章小于50字时自动取消追加版权信息。</p>
<h2 id="编辑版权信息的内容"><a href="#编辑版权信息的内容" class="headerlink" title="编辑版权信息的内容"></a>编辑版权信息的内容</h2><p>在\blog\tail.md中编辑版权信息，内容如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">-------------</span><br><span class="line"><span class="strong">**版权声明**</span></span><br><span class="line">![](<span class="link">/images/cc.png</span>)</span><br><span class="line">[<span class="string">Scholar&#x27;s Blog</span>](<span class="link">https://scholargeek.github.io/</span>) by [<span class="string">scholargeek</span>](<span class="link">https://scholargeek.github.io/About/</span>) is licensed under a [<span class="string">Creative Commons BY-NC-ND 4.0 International License</span>](<span class="link">http://creativecommons.org/licenses/by-nc-nd/4.0/</span>). </span><br><span class="line">由[<span class="string">董仕麟</span>](<span class="link">https://scholargeek.github.io/About/</span>)创作并维护的[<span class="string">scholargeek</span>](<span class="link">https://scholargeek.github.io/</span>)博客采用[<span class="string">创作共用保留署名-非商业-禁止演绎4.0国际许可证</span>](<span class="link">http://creativecommons.org/licenses/by-nc-nd/4.0/</span>)。</span><br><span class="line">本文首发于[<span class="string">Scholar&#x27;s Blog</span>](<span class="link">https://scholargeek.github.io/</span>)博客，版权所有，侵权必究。</span><br></pre></td></tr></table></figure>
<p>最后在\source\images夹中添加cc.png图片即可引用版权信息图片。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/18/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%964/">https://scholargeek.github.io/2019/07/18/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%964/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化6</title>
    <url>/2019/07/20/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%966/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="给博客添加RSS"><a href="#给博客添加RSS" class="headerlink" title="给博客添加RSS"></a>给博客添加RSS</h1><p>简易信息聚合（也叫聚合内容）是一种基于XML的标准，在互联网上被广泛采用的内容包装和投递协议。RSS(Really Simple Syndication)是一种描述和同步网站内容的格式，是使用最广泛的XML应用。<br>网络用户可以在客户端借助于支持RSS的聚合工具软件，在不打开网站内容页面的情况下阅读支持RSS输出的网站内容。<br>本文将详述如何给博客添加RSS功能。</p>
<span id="more"></span>
<p>1.安装Feed插件；使用Powershell进入\blog目录，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure>
<p>安装好feed插件，就可以生成RSS xml文件了。</p>
<p>2.在根目录配置文件中添加功能；即在\blog_config.yml文件中添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">plugins:</span><br><span class="line"> hexo-generator-feed</span><br><span class="line"></span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line"> type: atom</span><br><span class="line"> path: atom.xml</span><br><span class="line"> limit: 20</span><br></pre></td></tr></table></figure>
<p>保存文件即可。</p>
<p>显示的效果即博客右上角出现了RSS订阅的按钮。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/20/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%966/">https://scholargeek.github.io/2019/07/20/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%966/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化5</title>
    <url>/2019/07/19/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%965/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使博文自带分享栏"><a href="#使博文自带分享栏" class="headerlink" title="使博文自带分享栏"></a>使博文自带分享栏</h1><p>许多网站内容都允许分享，本文将详述如何给每篇博文附带分享栏功能。</p>
<span id="more"></span>
<p>首先获取百度分享源码，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;% if (!index)&#123; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;bdsharebuttonbox&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;_bds_more&quot; data-cmd=&quot;more&quot;&gt;分享本文&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_tsina&quot; data-cmd=&quot;tsina&quot; title=&quot;分享到新浪微博&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_renren&quot; data-cmd=&quot;renren&quot; title=&quot;分享到人人网&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_douban&quot; data-cmd=&quot;douban&quot; title=&quot;分享到豆瓣网&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_qzone&quot; data-cmd=&quot;qzone&quot; title=&quot;分享到QQ空间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_fbook&quot; data-cmd=&quot;fbook&quot; title=&quot;分享到Facebook&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_twi&quot; data-cmd=&quot;twi&quot; title=&quot;分享到Twitter&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_mail&quot; data-cmd=&quot;mail&quot; title=&quot;分享到邮件分享&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_print&quot; data-cmd=&quot;print&quot; title=&quot;分享到打印&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_copy&quot; data-cmd=&quot;copy&quot; title=&quot;分享到复制网址&quot;&gt;&lt;/a&gt;&lt;a class=&quot;bds_count&quot; data-cmd=&quot;count&quot;&gt;&lt;/a&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;window._bd_share_config=&#123;&quot;common&quot;:&#123;&quot;bdSnsKey&quot;:&#123;&#125;,&quot;bdText&quot;:&quot;&quot;,&quot;bdMini&quot;:&quot;2&quot;,&quot;bdMiniList&quot;:false,&quot;bdPic&quot;:&quot;&quot;,&quot;bdStyle&quot;:&quot;2&quot;,&quot;bdSize&quot;:&quot;24&quot;&#125;,&quot;share&quot;:&#123;&#125;&#125;;with(document)0[(getElementsByTagName(&#x27;head&#x27;)[0]||body).appendChild(createElement(&#x27;script&#x27;)).src=&#x27;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&#x27;+~(-new Date()/36e5)];&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>将其保存到blog\themes\landscape\layout_partial\post\baidu-share.ejs中</p>
<p>再到blog\themes\landscape\layout_partial\duoshuo-comment.ejs文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;section id=&quot;comments&quot;&gt;</span><br><span class="line"> &lt;div class=&quot;ds-thread&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var duoshuoQuery = &#123;short_name:&quot;&lt;%- config.duoshuo_shortname %&gt;&quot;&#125;;</span><br><span class="line"></span><br><span class="line"> (function() &#123;</span><br><span class="line"> var ds = document.createElement(&#x27;script&#x27;);</span><br><span class="line"> ds.type = &#x27;text/javascript&#x27;;ds.async = true;</span><br><span class="line"> ds.src = &#x27;http://static.duoshuo.com/embed.js&#x27;;</span><br><span class="line"> ds.charset = &#x27;UTF-8&#x27;;</span><br><span class="line"> (document.getElementsByTagName(&#x27;head&#x27;)[0]</span><br><span class="line"> || document.getElementsByTagName(&#x27;body&#x27;)[0]).appendChild(ds);</span><br><span class="line"> &#125;)();</span><br><span class="line"></span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p>最后编辑主题配置文件，即在blog\themes\landscape_config.yml文件中，添加<br>baidu_share: true<br>即可实现在博文下方附带分享栏。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/19/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%965/">https://scholargeek.github.io/2019/07/19/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%965/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化7</title>
    <url>/2019/07/21/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%967/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo博客Landscape主题的字体和JS库的优化"><a href="#Hexo博客Landscape主题的字体和JS库的优化" class="headerlink" title="Hexo博客Landscape主题的字体和JS库的优化"></a>Hexo博客Landscape主题的字体和JS库的优化</h1><p>本文将详述如何优化Hexo博客默认主题的jQuery库和字体</p>
<span id="more"></span>
<h2 id="jQuery库的优化"><a href="#jQuery库的优化" class="headerlink" title="jQuery库的优化"></a>jQuery库的优化</h2><p>目的：将jQuery替换成百度提供的服务，且在百度的服务暂时不可用时，能够以网站上自带的jQuery作为备份服务。<br>方法：<br>1.修改blog\themes\landscape\layout_partial&#x2F;after-footer.ejs文件，将17行的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>替换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">//&lt;![CDATA[</span><br><span class="line">if (typeof jQuery == &#x27;undefined&#x27;) &#123;</span><br><span class="line"> document.write(unescape(&quot;%3Cscript src=&#x27;/js/jquery-2.0.3.min.js&#x27; type=&#x27;text/javascript&#x27;%3E%3C/script%3E&quot;));</span><br><span class="line">&#125;</span><br><span class="line">// ]]&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2.去jQuery官方下载合适版本的jQuery并将其放到themes&#x2F;landscape&#x2F;source&#x2F;js&#x2F;目录下，将其命名为jquery-2.0.3.min.js 最后将该文件开头处的 <del>&#x2F;&#x2F;@ sourceMappingURL&#x3D;jquery-2.0.3.min.map</del> 这一行代码删去，否则会导致博客无法生成。</p>
<h2 id="字体优化"><a href="#字体优化" class="headerlink" title="字体优化"></a>字体优化</h2><p>目的：优化博客字体，使页面在多个平台上自动显示较合适的字体。<br>方法：1.修改themes&#x2F;landscape&#x2F;source&#x2F;css&#x2F;_variables.styl这一文件，将其中第22行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">font-sans = &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif</span><br></pre></td></tr></table></figure>
<p>替换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">font-sans = &quot;Helvetica Neue&quot;, &quot;Helvetica&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans CN&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif</span><br></pre></td></tr></table></figure>
<p>2.放弃Google的Source Code Pro等宽字体，修改themes&#x2F;landscape&#x2F;source&#x2F;css&#x2F;_variables.styl文件，将其中第24行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">font-mono = &quot;Source Code Pro&quot;, Consolas, Monaco, Menlo, Consolas, monospace</span><br></pre></td></tr></table></figure>
<p>替换为<br>    font-mono &#x3D; Consolas, Monaco, Menlo, monospace<br>3.最后删除引用Google字体的代码，编辑文件themes&#x2F;landscape&#x2F;layout&#x2F;_partial&#x2F;after-footer.ejs，将其中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;http://fonts.googleapis.com/css?family=Source+Code+Pro&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>删除即可。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/21/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%967/">https://scholargeek.github.io/2019/07/21/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%967/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化9</title>
    <url>/2019/07/23/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%969/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何在静态博客首页中只显示摘要信息"><a href="#如何在静态博客首页中只显示摘要信息" class="headerlink" title="如何在静态博客首页中只显示摘要信息"></a>如何在静态博客首页中只显示摘要信息</h1><p>默认情况下hexo博客的首页显示的是完整的文章，而文章比较长的时候这无疑会带来诸多不遍。<br>如果只显示摘要信息，只要在文章正文里面加入一个<span id="more"></span>这样的占位符即可。注意：这个占位符只能另起一行，不能放在其他行内。<br>即在该占位符之前的为摘要信息，其之后的内容则隐藏了，显示为Read More按钮。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/23/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%969/">https://scholargeek.github.io/2019/07/23/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%969/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客默认主题的修改与美化8</title>
    <url>/2019/07/22/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%968/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设置网站的图标Favicon"><a href="#设置网站的图标Favicon" class="headerlink" title="设置网站的图标Favicon"></a>设置网站的图标Favicon</h1><p><strong>Favicon</strong>是_favorites icon_的缩写，亦被称为<strong>website icon</strong>（网页图标）。<br>本文将详述博客网站如何设置网页图标。</p>
<span id="more"></span>

<p>首先选择合适的图片转换为.ico格式，可在<a href="http://tool.lu/favicon/">http://tool.lu/favicon/</a> 在线转换格式，当然也可以使用图片编辑工具转换，最后得到favicon.ico图标文件，放入blog\source文件夹内即可。<br>然后编辑主题配置文件blog\themes\landscape_config.yml 添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favicon: /favicon.ico</span><br></pre></td></tr></table></figure>
<p>即完成了网页图标的添加。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/22/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%968/">https://scholargeek.github.io/2019/07/22/Hexo%E5%8D%9A%E5%AE%A2%E9%BB%98%E8%AE%A4%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E7%BE%8E%E5%8C%968/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA学习</title>
    <url>/2019/02/28/JAVA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JAVA简介"><a href="#JAVA简介" class="headerlink" title="JAVA简介"></a>JAVA简介</h1><p>　　Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。<br>　　任职于Sun微系统的詹姆斯·高斯林等人于1990年代初开发Java语言的雏形，最初被命名为Oak，目标设置在家用电器等小型系统的编程语言，应用在电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些智能化家电的市场需求没有预期的高，Sun微系统放弃了该项计划。随着1990年代互联网的发展，Sun微系统看见Oak在互联网上应用的前景，于是改造了Oak，于1995年5月以Java的名称正式发布。Java伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。</p>
<span id="more"></span>
<p>　　Java编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装&#x2F;拆箱特性。Sun微系统对Java语言的解释是：“Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全、与系统无关、可移植、高性能、多线程和动态的语言”。Java不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2发布后，Java的执行速度有了大幅提升。与传统类型不同，Sun微系统在推出Java时就将其作为开放的技术。全球的Java开发公司被要求所设计的Java软件必须兼容。“Java语言靠群体的力量而非公司的力量”是Sun微系统的口号之一，并获得了广大软件开发商的认同。这与微软公司所倡导的注重精英和封闭式的模式完全不同，此外，微软公司后来推出了与之竞争的.NET平台以及模仿Java的C#语言。后来Sun微系统被甲骨文公司并购，Java也随之成为甲骨文公司的产品。目前，移动操作系统Android大部分的代码采用Java编程语言编程。</p>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p><img src="https://s3.bmp.ovh/imgs/2024/04/13/1f145e2cfcd2fe1c.png" alt="Java_logo"></p>
<p><img src="https://s3.bmp.ovh/imgs/2024/04/13/23e840de9958cd13.jpg" alt="James_Gosling"></p>
<p>设计者:詹姆斯·高斯林、太阳计算机系统公司<br>发行时间:1995年<br>类型系统:静态、安全、强类型、标明类型<br>许可证:GNU通用公共许可协议、JCP<br>文件扩展名:.java、.class、.jar<br>官方网站:<a href="https://www.java.com/">https://www.java.com/</a></p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><h3 id="开放源代码项目"><a href="#开放源代码项目" class="headerlink" title="开放源代码项目"></a>开放源代码项目</h3><p>　　2006年Sun微系统在JavaOne公布Java 开放源代码项目，并推出OpenJDK计划。Java虚拟机、Java编译器和Java类库以GNU通用公共许可证公开。</p>
<h3 id="版本历史"><a href="#版本历史" class="headerlink" title="版本历史"></a>版本历史</h3><p>●1995年5月23日，Java语言诞生<br>●1996年1月，第一个JDK-JDK1.0诞生<br>●1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术<br>●1996年9月，约8.3万个网页应用了JAVA技术来制作<br>●1997年2月18日，JDK1.1发布<br>●1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录<br>●1997年9月，JavaDeveloperConnection社区成员超过十万<br>●1998年2月，JDK1.1被下载超过2,000,000次<br>●1998年12月8日，JAVA2企业平台J2EE发布<br>●1999年6月，Sun微系统发布Java的三个版本：标准版（J2SE）、企业版（J2EE）和微型版（J2ME）<br>●2000年5月8日，JDK1.3发布<br>●2000年5月29日，JDK1.4发布<br>●2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机<br>●2001年9月24日，J2EE1.3发布<br>●2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升<br>●2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0<br>●2005年6月，JavaOne大会召开，Sun微系统公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字“2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME<br>●2006年12月，Sun微系统发布JRE6.0<br>●2009年12月，Sun微系统发布Java EE 6<br>●2010年11月，由于Oracle公司对于Java社群的不友善，因此Apache扬言将退出JCP<br>●2011年7月28日，Oracle公司发布Java SE 7<br>●2014年3月18日，Oracle公司发布Java SE 8<br>●2017年9月21日，Oracle公司发布Java SE 9<br>●2018年3月21日，Oracle公司发布Java SE 10<br>●2018年9月25日，Oracle公司发布Java SE 11 (LTS)<br>●2019年3月，Oracle公司发布Java SE 12<br>●2019年9月，Oracle公司发布Java SE 13<br>●2020年3月，Oracle公司发布Java SE 14<br>●2020年9月，Oracle公司发布Java SE 15<br>●2021年3月，Oracle公司发布Java SE 16<br>●2021年9月，Oracle公司发布Java SE 17<br>●2022年3月，Oracle公司发布Java SE 18<br>●2022年9月，Oracle公司发布Java SE 19<br>●2023年3月，Oracle公司发布Java SE 20</p>
<h3 id="版本使用"><a href="#版本使用" class="headerlink" title="版本使用"></a>版本使用</h3><p>目前Java提供以下三个版本：<br>●Java Platform, Enterprise Edition（Java EE：Java平台企业版）[常用于Web方向的网站开发]<br>●Java Platform, Standard Edition（Java SE：Java平台标准版）[用于桌面应用的开发，是其他版本的基础]<br>●Java Platform, Micro Edition（Java ME：Java平台微型版）[面向嵌入式等设备应用的开发]</p>
<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><p>Java可以实现以下五个目的：<br>●应当使用面向对象程序设计方法学<br>●应当允许同一程序在不同的计算机平台执行<br>●应当包括内置的对计算机网络的支持<br>●应当被设计成安全地执行远端代码<br>●应当易于使用，并借鉴以前那些面向对象语言（如C++）的长处。</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>　　Java的特点之一就是面向对象，是程序设计方法的一种。“面向对象程序设计语言”的核心之一就是开发者在设计软件的时候可以使用自定义的类型和关联操作。代码和数据的实际集合体叫做“对象”。一个对象可以想象成绑定了很多“行为（代码）”和“状态（数据）”的物体。对于数据结构的改变需要和代码进行通信然后操作，反之亦然。面向对象设计让大型软件工程的计划和设计变得更容易管理，能增强工程的健康度，减少失败工程的数量。</p>
<h3 id="跨平台性"><a href="#跨平台性" class="headerlink" title="跨平台性"></a>跨平台性</h3><p>　　跨平台性是Java主要的特性之一，跨平台使得用Java语言编写的程序可以在编译后不用经过任何更改，就能在任何硬件设备条件下运行。这个特性经常被称为“一次编译，到处运行”。</p>
<h3 id="自动垃圾回收-Garbage-Collection"><a href="#自动垃圾回收-Garbage-Collection" class="headerlink" title="自动垃圾回收(Garbage Collection)"></a>自动垃圾回收(Garbage Collection)</h3><p>　　C++语言被用户诟病的原因之一是大多数C++编译器不支持垃圾收集机制。通常使用C++编程的时候，程序员于程序中初始化对象时，会在主机存储器堆栈上分配一块存储器与地址，当不需要此对象时，进行析构或者删除的时候再释放分配的存储器地址。如果对象是在堆栈上分配的，而程序员又忘记进行删除，那么就会造成存储器泄漏（Memory Leak）。长此以往，程序运行的时候可能会生成很多不清除的垃圾，浪费了不必要的存储器空间。而且如果同一存储器地址被删除两次的话，程序会变得不稳定，甚至崩溃。因此有经验的C++程序员都会在删除之后将指针重置为NULL，然后在删除之前先判断指针是否为NULL。C++中也可以使用“智能指针”（Smart Pointer）或者使用C++托管扩展编译器的方法来实现自动化存储器释放，智能指针可以在标准类库中找到，而C++托管扩展被微软的Visual C++ 7.0及以上版本所支持。智能指针的优点是不需引入缓慢的垃圾收集机制，而且可以不考虑线程安全的问题，但是缺点是如果不善使用智能指针的话，性能有可能不如垃圾收集机制，而且不断地分配和释放存储器可能造成存储器碎片，需要手动对堆进行压缩。除此之外，由于智能指针是一个基于模板的功能，所以没有经验的程序员在需要使用多态特性进行自动清理时也可能束手无策。<br>　　Java语言则不同，上述的情况被自动垃圾收集功能自动处理。对象的建立和放置都是在存储器堆栈上面进行的。当一个对象没有任何引用的时候，Java的自动垃圾收集机制就发挥作用，自动删除这个对象所占用的空间，释放存储器以避免存储器泄漏。注意程序员不需要修改finalize方法，自动垃圾收集也会发生作用。但是存储器泄漏并不是就此避免了，当程序员疏忽大意地忘记解除一个对象不应该有的引用时，存储器泄漏仍然不可避免。<br>　　不同厂商、不同版本的JVM中的存储器垃圾回收机制并不完全一样，通常越新版本的存储器回收机制越快，IBM、BEA、Sun微系统等等开发JVM的公司都曾宣称过自己制造出了世界上最快的JVM，JVM性能的世界纪录也在不断的被打破并提高。IBM有一篇有关Java存储器回收机制比不激活垃圾收集机制的C++存储器处理快数倍的技术文章，而著名的Java技术书籍《Java编程思想》（Thinking in Java）也有一段论述Java存储器及性能达到甚至超过C++的章节。</p>
<h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p>　　Java是编译型语言与解释型语言的结合体。Java程序运行时，必须经过编译和运行两个步骤。首先对后缀名为.java的源文件进行编译，生成后缀名为.class的字节码文件。然后java虚拟机对字节码文件进行解释执行，并将结果显示出来。<br>　　编译运行过程如下：<br>①编写Hello World.java文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②使用“javac Hello World.java”命令运行Java编译器编译HelloWorld.java文件，编译结束后生成一个名为HelloWorld.class的字节码文件。<br>③使用“java HelloWorld”命令运行Java虚拟机，Java虚拟机首先将编译好的字节码文件加载到内存，这个过程称为类加载，由类加载器完成。然后Java虚拟机针对加载到内存中的Java类进行解释执行，输出运行结果。</p>
<p><img src="https://s3.bmp.ovh/imgs/2024/04/13/01c5cff4191ff4bb.png" alt="JAVA运行机制"><br>　　整个过程Java程序是由虚拟机负责解释执行的，而并非操作系统。这样就可以实现Java程序的跨平台，即在不同的操作系统上安装不同版本的Java虚拟机就可以运行相同的Java程序编译好的字节码文件。</p>
<h3 id="JVM-Java-Virtual-Machine"><a href="#JVM-Java-Virtual-Machine" class="headerlink" title="JVM(Java Virtual Machine)"></a>JVM(Java Virtual Machine)</h3><p>1.JVM即Java虚拟机，是Java字节码执行的引擎，为java程序的执行提供必要的支持，能优化java字节码，使之转换成效率更高的机器指令。程序员编写的程序最终都要在JVM上执行，JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的。<br>2.ClassLoader是java运行时一个重要的系统组件，负责在运行时查找和装入类文件的类。<br>3.JVM屏蔽了与具体操作系统平台相关的信息，从而实现了java程序只需生成在JVM上运行的字节码文件(class文件)，就可以在多种平台上不加修改地运行。不同平台对应着不同的JVM，在执行字节码时，JVM负责将每一条要执行的字节码送给解释器，解释器再将其翻译成特定平台环境的机器指令并执行。java语言最重要的特点就是跨平台运行，使用JVM就是为了支持与操作系统无关，实现跨平台运行。</p>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>1.是JVM实现的一部分，包括bootstrapclassloader（启动类加载器）<br>2.ClassLoader在JVM运行的时候加载java核心的API，通过java程序实现两个ClassLoader:<br>①ExtClassLoader，它的作用是用来加载java的扩展API，也就是lib\ext类；<br>②AppClassLoader，用来加载用户机器上CLASSPATH设置目录中的Class.<br>3.ClassLoader加载流程：当运行一个程序的时候，JVM启动，运行bootstrapclassloader，该ClassLoader加载java核心API，然后调用ExtClassLoader加载扩展API，最后AppClassLoader加载CLASSPATH目录下定义的Class.</p>
<h3 id="JRE-Java-Runtime-Environment"><a href="#JRE-Java-Runtime-Environment" class="headerlink" title="JRE(Java Runtime Environment)"></a>JRE(Java Runtime Environment)</h3><p>JRE即java运行时环境，它是java程序运行所必须的环境集合，主要由java虚拟机、java平台核心类和若干支持文件组成。其不包含开发工具、编译器、调试器以及其他工具。<br>　　在执行java程序的时候，操作系统会按照下面顺序寻找JRE环境。<br>①先查找当前目录下有没有JRE<br>②再查找父目录下有没有JRE<br>③接着在环境变量PATH制定的路径中查找JRE<br>④注册表查看CurrentVersion的键值指向哪个JRE<br>　　JRE自带的基础类库主要在JRE\LIB\rt.jar文件中。在程序运行时，JRE由ClassLoader(类加载器)负责查找和加载程序引用到的基类库和其他类库。基础类库，Classloader会自动到rt.jar的位置；其他的类库，ClassLoader在环境变量CLASSPATH制定的路径中搜索。</p>
<h3 id="JDK-Java-Development-Kit"><a href="#JDK-Java-Development-Kit" class="headerlink" title="JDK(Java Development Kit)"></a>JDK(Java Development Kit)</h3><p>JDK即java开发工具包。JDK是java的核心，它包括java运行环境、一系列java工具和java基础的类库（rt.jar）。JDK包含JRE的全部内容外，还包含开发者用以编译、调试和运行java程序的工具。</p>
<h3 id="JDK，JRE和JVM之间的关系"><a href="#JDK，JRE和JVM之间的关系" class="headerlink" title="JDK，JRE和JVM之间的关系"></a>JDK，JRE和JVM之间的关系</h3><p>JDK包含了JRE和JVM，JRE包含了JVM。JDK是开发Java程序必备的工具，而JRE则是Java程序运行的必备环境。<br><img src="https://s3.bmp.ovh/imgs/2024/04/13/5c5a1870d15ff647.png" alt="JDK,JRE,JVM之间的关系"></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>●大小写敏感：Java是大小写敏感的，这就意味着标识符<code>Hello</code>与<code>hello</code>是不同的。<br>●类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如<code>MyFirstJavaClass</code>。<br>●方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写，例如<code>myFirstJavaMethod</code>。<br>●源文件名：源文件名必须和文件内名字唯一且公开(由public 关键词修饰)的类名相同。当保存文件的时候，你应该使用该类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为<code>.java</code>。（如果文件名和类名不相同则会导致编译错误）。<br>●主方法入口：所有的Java程序由<code>public static void main(String[] args)</code>方法开始执行。</p>
<h2 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h2><p>这些关键字不能用于常量、变量、和任何标识符的名称。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>访问控制</td>
<td>private</td>
<td>私有的</td>
</tr>
<tr>
<td>protected</td>
<td>受保护的</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>公共的</td>
<td></td>
</tr>
<tr>
<td>类、方法和变量修饰符</td>
<td>abstract</td>
<td>声明抽象</td>
</tr>
<tr>
<td>class</td>
<td>类</td>
<td></td>
</tr>
<tr>
<td>extends</td>
<td>扩充,继承</td>
<td></td>
</tr>
<tr>
<td>final</td>
<td>最终值,不可改变的</td>
<td></td>
</tr>
<tr>
<td>implements</td>
<td>实现（接口）</td>
<td></td>
</tr>
<tr>
<td>interface</td>
<td>接口</td>
<td></td>
</tr>
<tr>
<td>native</td>
<td>本地，原生方法（非Java实现）</td>
<td></td>
</tr>
<tr>
<td>new</td>
<td>新,创建</td>
<td></td>
</tr>
<tr>
<td>static</td>
<td>静态</td>
<td></td>
</tr>
<tr>
<td>strictfp</td>
<td>严格,精准</td>
<td></td>
</tr>
<tr>
<td>synchronized</td>
<td>线程,同步</td>
<td></td>
</tr>
<tr>
<td>transient</td>
<td>短暂</td>
<td></td>
</tr>
<tr>
<td>volatile</td>
<td>易失</td>
<td></td>
</tr>
<tr>
<td>程序控制语句</td>
<td>break</td>
<td>跳出循环</td>
</tr>
<tr>
<td>case</td>
<td>定义一个值以供switch选择</td>
<td></td>
</tr>
<tr>
<td>continue</td>
<td>继续</td>
<td></td>
</tr>
<tr>
<td>default</td>
<td>默认</td>
<td></td>
</tr>
<tr>
<td>do</td>
<td>运行</td>
<td></td>
</tr>
<tr>
<td>else</td>
<td>否则</td>
<td></td>
</tr>
<tr>
<td>for</td>
<td>循环</td>
<td></td>
</tr>
<tr>
<td>if</td>
<td>如果</td>
<td></td>
</tr>
<tr>
<td>instanceof</td>
<td>实例</td>
<td></td>
</tr>
<tr>
<td>return</td>
<td>返回</td>
<td></td>
</tr>
<tr>
<td>switch</td>
<td>根据值选择执行</td>
<td></td>
</tr>
<tr>
<td>while</td>
<td>循环</td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>assert</td>
<td>断言表达式是否为真</td>
</tr>
<tr>
<td>catch</td>
<td>捕捉异常</td>
<td></td>
</tr>
<tr>
<td>finally</td>
<td>有没有异常都执行</td>
<td></td>
</tr>
<tr>
<td>throw</td>
<td>抛出一个异常对象</td>
<td></td>
</tr>
<tr>
<td>throws</td>
<td>声明一个异常可能被抛出</td>
<td></td>
</tr>
<tr>
<td>try</td>
<td>捕获异常</td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>引入</td>
</tr>
<tr>
<td>package</td>
<td>包</td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>布尔型</td>
</tr>
<tr>
<td>byte</td>
<td>字节型</td>
<td></td>
</tr>
<tr>
<td>char</td>
<td>字符型</td>
<td></td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点</td>
<td></td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>长整型</td>
<td></td>
</tr>
<tr>
<td>short</td>
<td>短整型</td>
<td></td>
</tr>
<tr>
<td>null</td>
<td>空</td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>父类,超类</td>
</tr>
<tr>
<td>this</td>
<td>本类</td>
<td></td>
</tr>
<tr>
<td>void</td>
<td>无返回值</td>
<td></td>
</tr>
<tr>
<td>保留关键字</td>
<td>goto</td>
<td>是关键字，但不能使用</td>
</tr>
<tr>
<td>const</td>
<td>是关键字，但不能使用</td>
<td></td>
</tr>
</tbody></table>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/02/28/JAVA/">https://scholargeek.github.io/2019/02/28/JAVA/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript学习</title>
    <url>/2023/03/06/JavaScript/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h1><p>　　JavaScript（缩写为JS）是一门基于原型和头等函数的多范式高级解释型编程语言，它支持面向对象程序设计、指令式编程和函数式编程。它提供方法来操控文本、数组、日期以及正则表达式等。不支持I&#x2F;O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。它由Ecma通过ECMAScript实现语言的标准化。目前，它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、Firefox、Safari和Opera）所支持。</p>
<span id="more"></span>
<p>　　JavaScript与Java在名字和语法上都很相似，但这两门编程语言从设计之初就有很大不同。JavaScript在语言设计上主要受到了Self（一种基于原型的编程语言）和Scheme（一门函数式编程语言）的影响，在语法结构上它和C语言很相似（如if条件语句、switch语句、while循环和do-while循环等）。对于客户端来说，JavaScript通常被实现为一门解释语言，但如今它已经可以被即时编译（JIT）。随着HTML5和CSS3语言标准的推行，它还可以用于游戏、桌面和移动应用程序的开发，以及在服务器端网络环境运行（如Node.js）。</p>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>编程范型:事件驱动、函数式、指令式<br>设计者:布兰登·艾克及ECMAScript规范的其他关键贡献者<br>发行时间:1995年12月4日<br>类型系统:动态类型、鸭子类型<br>文件扩展名:.js、.cjs、.mjs<br>官方网站:<a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262">https://www.ecma-international.org/publications-and-standards/standards/ecma-262</a></p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><h3 id="始于网景"><a href="#始于网景" class="headerlink" title="始于网景"></a>始于网景</h3><p>　　1993年，美国国家超级计算机应用中心(NCSA)发表了NCSA Mosaic，这是最早流行的图形接口网页浏览器，它在万维网的普及上发挥了重要作用。1994年，Mosaic的主要开发人员创立了Netscape公司，并雇用了许多原来的NCSA Mosaic开发者用来开发Netscape Navigator，该公司的目标是取代NCSA Mosaic成为世界第一的网页浏览器。在四个月内，已经占据了四分之三的浏览器市场，并成为1990年代互联网的主要浏览器。<br>　　在网络发展的这些年，网页只能是静态的，缺乏在浏览器中加载网页后的动态行为能力。公司的创始人马克·安德森认为HTML需要一种胶水语言，让网页设计师和兼职程序员可以很容易地使用它来组装图片和插件之类的组件，且代码可以直接编写在网页标记中。1995年，网景招募了布兰登·艾克，目标是把Scheme语言嵌入到Netscape Navigator浏览器中。但更早之前，网景已经跟昇阳合作，计划在Netscape Navigator中嵌入Java语言，这时网景内部产生激烈的争论，网景公司管理层很快决定，最佳的方案是由艾克设计一种新的语言，其语法类似于Java，而不像Scheme或其他现存的脚本语言。为了在其他竞争提案中捍卫JavaScript这个想法，公司需要有一个可以运作的原型。艾克在1995年5月仅花了十天时间就把原型设计出来了。最初命名为Mocha，1995年9月在Netscape Navigator 2.0的Beta版中改名为LiveScript，同年12月，Netscape Navigator 2.0 Beta 3中部署时被重命名为JavaScript。当时网景公司与昇阳电脑公司组成的开发联盟为了让这门语言搭上Java这个编程语言“热词”，因此将其临时改名为JavaScript，日后这成为大众对这门语言有诸多误解的原因之一。</p>
<h3 id="微软采纳"><a href="#微软采纳" class="headerlink" title="微软采纳"></a>微软采纳</h3><p>　　微软公司于1995年首次推出Internet Explorer，引发了与Netscape的浏览器大战。微软对Netscape Navigator解释器进行了逆向工程，创建了JScript，以与处于市场领导地位的网景产品同台竞争。JScript也是一种JavaScript实现，这两个JavaScript语言版本在浏览器端共存意味着语言标准化的缺失。发展初期，JavaScript的标准并未确定，同期就有网景的JavaScript和微软的JScript。除此之外，微软也在网页技术上加入了不少专属对象，使不少网页使用非微软平台及浏览器无法正常显示。这导致在浏览器大战期间网页设计者通常会把“用Netscape可达到最佳效果”或“用IE可达到最佳效果”的标志放在主页。</p>
<h3 id="标准化与增长"><a href="#标准化与增长" class="headerlink" title="标准化与增长"></a>标准化与增长</h3><p>　　1996年11月，网景正式向ECMA（欧洲计算机制造商协会）提交语言标准。1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262。JavaScript成为了ECMAScript最著名的实现之一。除此之外，ActionScript和JScript也都是ECMAScript规范的实现语言。尽管JavaScript作为给非程序人员的脚本语言，而非作为给程序人员的编程语言来推广和宣传，但是JavaScript具有非常丰富的特性。<br>　　在21世纪初Internet Explorer占主导地位期间，客户端脚本停滞不前。这在2004年开始改变，当时Netscape的继任者Mozilla发布了Firefox浏览器。Firefox受到许多人的好评，从Internet Explorer获得了巨大的市场份额。2005年，Mozilla加入了ECMA International，并开始研究ECMAScript for XML（E4X）标准。这导致Mozilla与Macromedia（后来被Adobe Systems收购）合作，他们正在用基于ECMAScript 4草案的ActionScript 3语言实现E4X。目标是将ActionScript 3标准化为新的ECMAScript 4。为此，Adobe Systems将Tamarin实现作为开源项目发布。然而，Tamarin和ActionScript 3与既定的客户端脚本太不同，如果没有微软的合作，ECMAScript 4从未获取成果。与此同时，与ECMA工作无关的开源社区正在发生非常重要的发展。2005年，Jesse James Garrett发布了一份白皮书，其中他创造了Ajax一词，并描述了一套技术，其中JavaScript是骨干，用于创建可以在后台加载数据的Web应用程序，避免了重新加载整页的需要。这引发了JavaScript的复兴时期，由开源库和围绕它们形成的社区带头。创建了许多新库，包括jQuery、Prototype、Dojo Toolkit和MooTools。<br>　　谷歌于2008年首次推出Chrome浏览器，其V8 JavaScript引擎比竞争对手更快。关键的创新是及时编译（JIT），因此其他浏览器供应商需要为JIT彻底改革他们的引擎。<br>　　2008年7月，这些不同的团体聚集在一起，在奥斯陆举行会议。这导致在2009年初达成了最终协议，将所有相关工作结合起来，推动语言向前发展。使得2009年12月发布了ECMAScript 5标准。</p>
<h3 id="走向成熟"><a href="#走向成熟" class="headerlink" title="走向成熟"></a>走向成熟</h3><p>　　关于该语言雄心勃勃的工作持续了数年，最终随着 2015 年ECMAScript 6的发布而正式形成了广泛的补充和改进。Ryan Dahl在 2009 年创建的Node.js引发了 Web 浏览器之外 JavaScript 使用的显着增加。Node 结合了V8引擎、事件循环和I&#x2F;O API，从而提供了独立的 JavaScript 运行时系统。截至 2018 年，Node 已被数百万开发人员使用，并且npm拥有世界上所有包管理器中最多的模块。<br>　　ECMAScript 草案规范目前在GitHub上公开维护，并通过定期的年度快照生成版本。对语言的潜在修订通过全面的提案流程进行审查。<br>　　当前的 JavaScript 生态系统拥有许多库和框架、已建立的编程实践以及在 Web 浏览器之外大量使用 JavaScript。另外，随着单页应用程序和其他大量使用 JavaScript 的网站的兴起，已经创建了多个转译器来帮助开发过程。</p>
<h3 id="版本历史"><a href="#版本历史" class="headerlink" title="版本历史"></a>版本历史</h3><p><img src="https://s3.bmp.ovh/imgs/2024/04/18/3014076381f97729.png" alt="Javascript版本历史"><br>注：JavaScript最初开发于1996年，被使用于Netscape Navigator网页浏览器。同年微软在Internet Explorer发布了一个实现。由于商标问题，这项实现被命名为JScript。1997年，JavaScript已经被网景公司提交给ECMA制定为标准，称之为ECMAScript，标准编号ECMA-262。使用显式版本号声明对语言的引用，作为一项Mozilla的特性，已在较新版本中被移除（至少为Firefox 59）。Firefox 4是最后一个需要显式地在引用时声明明确版本号的版本(1.8.5)。</p>
<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><p>完整的JavaScript包括：<br>●ECMAScript: 描述了该语言的语法和基本对象<br>●文档对象模型(DOM): 描述处理网页内容的方法和接口<br>●浏览器对象模型(BOM): 描述与浏览器进行交互的方法和接口</p>
<p>JavaScript的基本特点如下：<br>●是一种解释性脚本语言(代码不进行预编译)<br>●主要用来向HTML页面添加交互行为<br>●可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离</p>
<p>JavaScript常用来完成以下任务：<br>●嵌入动态文本于HTML页面<br>●对浏览器事件作出响应<br>●读写HTML元素<br>●在数据被提交到服务器之前验证数据<br>●检测访客的浏览器信息<br>●控制Cookie，包括创建和修改等</p>
<p>　　不同于服务器端脚本语言（如PHP和ASP），JavaScript主要被作为客户端脚本语言在用户的浏览器上运行，不需要服务器的支持。所以在早期程序员比较青睐于JavaScript以减少对服务器的负担，而与此同时在安全性上出现了问题。随着服务器变得强大，现在的程序员更喜欢运行于服务端的脚本以保证安全，但JavaScript仍然以其跨平台、容易上手等优势大行其道。同时，有些特殊功能（如AJAX）必须依赖JavaScript在客户端提供支持。随着引擎（如V8）和框架（如Node.js）的发展，以及事件驱动和异步IO等特性，JavaScript也被逐渐用来编写服务器端程序。</p>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>在游览器上输出Hello World。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> <span class="variable constant_">HTML</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>简单的JavaScript Hello World<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Hello, world!&quot;</span>);   <span class="comment">// 直接插入网页中显示</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">alert</span>(<span class="string">&quot;Hello, world!&quot;</span>);            <span class="comment">// 弹窗显示</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);      <span class="comment">// 在控制台(console)里显示，需要先开启开发工具控制台</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">　　　　HTML内容……</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>


<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2023/03/06/JavaScript/">https://scholargeek.github.io/2023/03/06/JavaScript/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux简介及应用</title>
    <url>/2018/08/28/Linux/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h1><p>　　Linux是一种自由和开放源码的类UNIX操作系统。其操作系统的内核由林纳斯·托瓦兹(Linus Torvalds)在1991年10月5日首次发布，内核加上用户空间的应用程序即组成了Linux操作系统。Linux也是自由软件和开放源代码软件发展中最著名的例子。只要遵循GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用Linux的所有底层源代码，也可以自由地修改和再发布。除了一部分专家之外，大多数人都是直接使用Linux 发行版，而非自己选择每一样组件或自行设置。</p>
<span id="more"></span>

<p>　　Linux严格意义上是指操作系统的内核，因操作系统中包含了许多用户图形接口和其他实用工具。如今Linux常用来指基于Linux的完整操作系统，内核则改以Linux内核称之。由于这些支持用户空间的系统工具和库主要由理查德·斯托曼于1983年发起的GNU计划提供，自由软件基金会提议将其组合系统命名为GNU&#x2F;Linux，但Linux不属于GNU计划，这个名称并没有得到社群的一致认同。<br>　　Linux最初是作为支持英特尔x86架构的个人电脑中一个自由操作系统。目前Linux已经被移植到更多的计算机硬件平台，远远超出其他任何操作系统。Linux可以运行在服务器和其他大型平台之上，如大型计算机和超级计算机。世界上500个最快的超级计算机已100％运行Linux发行版或变种。Linux也广泛应用在嵌入式系统上，如手机（Mobile Phone）、平板电脑（Tablet）、路由器（Router）、电视（TV）和电子游戏机等。在移动设备上广泛使用的Android操作系统就是建立在Linux内核之上。<br>　　通常情况下，Linux被打包成供个人计算机和服务器使用的Linux发行版。一些流行的主流Linux发行版，包括Debian（及其派生版本Ubuntu、Linux Mint）、Fedora（及其相关版本Red Hat Enterprise Linux）和openSUSE等。Linux发行版包含Linux内核和支撑内核的实用程序和库，通常还带有大量可以满足各类需求的应用程序。个人计算机使用的Linux发行版通常包含X Window和一个相应的桌面环境，如GNOME或KDE。桌面Linux操作系统常用的应用程序，包括Firefox网页浏览器、LibreOffice办公软件、GIMP图像处理工具等。由于Linux是自由软件，任何人都可以创建一个符合自己需求的Linux发行版。</p>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p><img src="https://s3.bmp.ovh/imgs/2024/01/23/951e240043419af2.png" alt="Tux"></p>
<center>官方的吉祥物:Tux(于1996年由Larry Ewing创造)</center>

<p><img src="https://s3.bmp.ovh/imgs/2024/01/23/8aa0fb1bfab7f61c.jpg" alt="Linus_Torvalds"></p>
<center>开发者:林纳斯·托瓦兹</center>

<p>编程语言:C语言、少量汇编语言、Rust语言(自6.1版开始)<br>操作系统家族:类Unix系统<br>源码模式:自由及开放源代码软件<br>首次发布版本:1991年的0.01版（代号“Freax”）<br>市场取向:桌面、服务器、嵌入式设备、移动设备<br>支持平台:Alpha, ARC, ARM, C6x, H8&#x2F;300, Hexagon, Itanium, m68k, Microblaze, MIPS, Nios II, OpenRISC,PA-RISC, PowerPC, RISC-V, s390, SuperH、SPARC, Unicore32、x86(含x86-64), Xtensa等<br>内核类别:宏内核<br>默认用户界面:命令行、图形界面（X窗口系统，Wayland）等<br>官方网站:<a href="https://www.kernel.org/">https://www.kernel.org/</a></p>
<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><h2 id="UNIX渊源"><a href="#UNIX渊源" class="headerlink" title="UNIX渊源"></a>UNIX渊源</h2><pre><code>UNIX操作系统是美国AT&amp;T公司贝尔实验室于1969年完成的操作系统。最早由肯·汤普逊（Ken Thompson），丹尼斯·里奇（Dennis Ritchie），道格拉斯·麦克罗伊（Douglas McIlroy），和乔伊·欧桑纳于1969年在AT&amp;T贝尔实验室开发。于1971年首次发布，最初是完全用汇编语言编写。在1973年用一个重要的开拓性的方法，Unix被丹尼斯·里奇用编程语言C（内核和I/O例外）重新编写。高级语言编写的操作系统具有更佳的兼容性，能更容易地移植到不同的计算机平台。
</code></pre>
<p>　　1983年，理查德·马修·斯托曼创立GNU计划。这个计划的目标是为了发展一个完全自由的类Unix操作系统。自1984年发起这个计划以来，在1985年，理查德·马修·斯托曼发起自由软件基金会并且在1989年撰写GPL。1990年代早期，GNU开始大量地产生或收集各种系统所必备的组件，如函式库、编译器、调试工具、文本编辑器，以及Unix的用户界面（Unix shell）；但是一些底层环境，如硬件驱动、守护进程、系统内核（kernel）仍然不完整和陷于停顿，GNU计划中是在Mach微内核的架构之上开发系统内核，也就是所谓的GNU Hurd，但是这个基于Mach的设计异常复杂，发展进度则相对缓慢。林纳斯·托瓦兹曾说过如果GNU内核在1991年时可以用，他不会自己去写一个。</p>
<h2 id="创立"><a href="#创立" class="headerlink" title="创立"></a>创立</h2><p>　　1991年，林纳斯·托瓦兹在赫尔辛基大学上学时就对操作系统很好奇。他对MINIX只允许在教育上使用很不满（因在当时MINIX限制任何商业使用），于是他便开始写他自己的操作系统，这就是后来的Linux内核。<br>　　林纳斯·托瓦兹开始在MINIX上开发Linux内核，为MINIX写的软件也可以在Linux内核上使用。后来使用GNU软件代替MINIX的软件，因为使用从GNU系统来的源代码可以自由使用，这对Linux的发展有益。使用GNU GPL协议的源代码可以被其他项目所使用，只要这些项目使用同样的协议发布。为了让Linux可以在商业上使用，林纳斯·托瓦兹决定更改他原来的协议（原协议限制商业使用），以GNU GPL协议来代替。之后许多开发者致力融合GNU元素到Linux中，做出一个有完整功能的、自由的操作系统。</p>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>　　Linux的第一个版本在1991年9月被大学FTP server管理员Ari Lemmke发布在互联网上，最初Torvalds称这个内核的名称为”Freax”，意思是自由(“free”)和奇异(“freak”)的结合词，并且附上”X”这个常用的字母，以配合所谓的类Unix的系统。但是FTP服务器管理员嫌“Freax”的名称不好听，把内核的称呼改成“Linux”，当时仅有10000行代码，仍必须执行于Minix操作系统之上，并且必须使用硬盘引导；随后在10月份第二个版本（0.02版）发布，同时这位芬兰赫尔辛基的大学生在comp.os.minix上发布一则消息:<br>    Hello everybody out there using minix- I’m doing a (free) operation system (just a hobby, won’t be big and professional like gnu) for 386(486) AT clones.<br>　　Linux的标志和吉祥物是一只名字叫做Tux的企鹅。标志的由来是因为林纳斯在澳洲时曾被一座动物园里的小蓝企鹅咬了一口，便选择企鹅作为Linux的标志;但更容易被接受的说法是：企鹅代表南极，而南极又是全世界所共有的一块陆地，即代表Linux是所有人的Linux。</p>
<h2 id="发展现状"><a href="#发展现状" class="headerlink" title="发展现状"></a>发展现状</h2><p>　　1994年3月，Linux1.0版正式发布，Marc Ewing成立Red Hat软件公司，成为最著名的Linux经销商之一。早期Linux的引导管理程序(boot loader)使用LILO(Linux Loader)，早期的LILO存在着一些缺陷，例如无法识别1024柱面以后的硬盘空间，后来的GRUB(GRand Unified Bootloader)克服这些缺点，具有“动态搜索内核文件”的功能，可以让用户在引导的时候，自行编辑引导设置系统文件，透过ext2或ext3文件系统中加载Linux Kernel（GRUB通过不同的文件系统驱动可以识别几乎所有Linux支持的文件系统，因此可以使用很多文件系统来格式化内核文件所在的扇区，并不局限于ext文件系统）。<br>　　目前由Linus Torvalds带领下，众多开发人员共同参与开发和维护Linux内核。理查德·斯托曼领导的自由软件基金会，继续提供大量支持Linux内核的GNU组件。一些个人和企业开发的第三方的非GNU组件也提供对Linux内核的支持，这些第三方组件包括大量的作品，有内核模块和用户应用程序和库等内容。Linux社区或企业都推出一些重要的Linux发行版，包括Linux内核、GNU组件、非GNU组件，以及其他形式的软件包管理系统软件。</p>
<h2 id="Linux发行版发展图"><a href="#Linux发行版发展图" class="headerlink" title="Linux发行版发展图"></a>Linux发行版发展图</h2><p>　　<img src="https://s3.bmp.ovh/imgs/2024/01/23/5976ccb15be750d6.png" alt="Linux发行版发展图"></p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>　　Linux内核支持各种硬件架构，为软件提供公共平台。基于Linux的系统是一个模块化的类Unix操作系统。Linux操作系统的大部分设计思想来源于20世纪70年代到80年代的Unix操作系统所建立的基本设计思想。Linux系统使用宏内核，由Linux内核负责处理进程控制、网络，以及外围设备和文件系统的访问。在系统运行的时候，设备驱动程序要么与内核直接集成，要么以加载模块形式添加。<br>　　Linux具有设备独立性，它内核具有高度适应能力，给系统提供更高级的功能。GNU用户界面组件是大多数Linux操作系统的重要组成部分，提供常用的C函数库，Shell，还有许多常见的Unix实用工具，可以完成许多基本的操作系统任务。大多数Linux系统使用的图形用户界面建立在X窗口系统之上，由X窗口(XWindow)系统通过软件工具及架构协议来建立操作系统所用的图形用户界面。</p>
<h2 id="Linux操作系统包含的一些组件"><a href="#Linux操作系统包含的一些组件" class="headerlink" title="Linux操作系统包含的一些组件"></a>Linux操作系统包含的一些组件</h2><p>　　启动程序：例如GRUB或LILO。该程序在计算机开机启动的时候运行，并将Linux内核加载到内存中。<br>　　init程序：init是由Linux内核创建的第一个进程，称为根进程，所有的系统进程都是它的子进程，即所有的进程都是通过init启动。init启动的进程如系统服务和登录提示。<br>　　软件库包(含代码)：可以通过运行的进程在Linux系统上使用ELF格式来执行文件，负责管理库使用的动态链接器是“ld-linux.so”。Linux系统上最常用的软件库是GNU C库。<br>　　用户界面程序：如命令行Shell或窗口环境。</p>
<h1 id="Linux的应用"><a href="#Linux的应用" class="headerlink" title="Linux的应用"></a>Linux的应用</h1><p>　　今天各种场合都有使用各种Linux发行版，从嵌入式设备到超级计算机（Super Computer），并且在服务器领域确定了地位，通常服务器使用LAMP组合。基于其低廉成本与高度可设置性，Linux常常被应用于嵌入式系统，例如机顶盒、移动电话及移动设备等。在移动电话上，基于Linux的Android已经成为IOS的主要竞争者；而在移动设备上，则成为Windows CE与Palm OS之外另一个选择。目前流行的TiVo数字摄影机使用了经过定制后的Linux。此外，有不少硬件式的网络防火墙及路由器，例如部分LinkSys的产品，其内部都是使用Linux来驱动、并采用了操作系统提供的防火墙及路由功能。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/08/28/Linux/">https://scholargeek.github.io/2018/08/28/Linux/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统目录结构</title>
    <url>/2018/09/01/Linux2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><p>登录系统后，在命令行中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /</span><br></pre></td></tr></table></figure>
<p>即可显示根目录下的所有文件及目录<br><img src="https://s3.bmp.ovh/imgs/2024/01/26/f0605847b8fe2e49.png" alt="Linux系统根目录"></p>
<span id="more"></span>

<p>树状目录结构如下：<br><img src="https://s3.bmp.ovh/imgs/2024/01/26/036b590e0e8313e8.png" alt="Linux系统根目录结构"></p>
<h2 id="目录解释"><a href="#目录解释" class="headerlink" title="目录解释"></a>目录解释</h2><p>&#x2F;bin：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着经常使用的命令。</p>
<p>&#x2F;boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
<p>&#x2F;dev ：dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p>
<p>&#x2F;etc：etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
<p>&#x2F;home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p>
<p>&#x2F;lib：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p>
<p>&#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后此处就生成了一些文件。</p>
<p>&#x2F;media：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p>
<p>&#x2F;mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p>
<p>&#x2F;opt：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
<p>&#x2F;proc：proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：<br>    echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all<br>&#x2F;root：该目录为系统管理员，也称作超级权限者的用户主目录。</p>
<p>&#x2F;sbin：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>
<p>&#x2F;selinux：这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
<p>&#x2F;srv：该目录存放一些服务启动之后需要提取的数据。</p>
<p>&#x2F;sys：这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
<p>&#x2F;tmp：tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p>
<p>&#x2F;usr：usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>
<p>&#x2F;usr&#x2F;bin：系统用户使用的应用程序。</p>
<p>&#x2F;usr&#x2F;sbin：超级用户使用的比较高级的管理程序和系统守护程序。</p>
<p>&#x2F;usr&#x2F;src：内核源代码默认的放置目录。</p>
<p>&#x2F;var：var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
<p>&#x2F;run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p>
<h2 id="重要目录"><a href="#重要目录" class="headerlink" title="重要目录"></a>重要目录</h2><p><strong>Linux 系统中有些目录是非常重要的，需要注意以避免误删除或者随意更改内部文件。</strong><br>&#x2F;etc： 此为系统配置文件目录，如果更改该目录下的某个文件可能会导致系统不能启动。<br>&#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;sbin: 这些是系统预设执行文件所放置的目录，比如 ls 就是在 &#x2F;bin&#x2F;ls 目录下的。<br>需要注意 &#x2F;bin、&#x2F;usr&#x2F;bin 是给系统用户使用的指令（除 root 外的通用用户），而&#x2F;sbin, &#x2F;usr&#x2F;sbin 则是给 root 使用的指令。<br>&#x2F;var： 是非常重要的目录，系统上每个程序都会生成相应的日志，而这些日志就被记录到此目录下，具体在 &#x2F;var&#x2F;log 目录下，另外 mail 的预设放置也是在此。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/09/01/Linux2/">https://scholargeek.github.io/2018/09/01/Linux2/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2018/08/30/Linux1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p><strong>Linux命令行界面中的常用命令如下：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls (list files) //列出目录及文件名</span><br><span class="line">cd (change directory)  //切换目录</span><br><span class="line">pwd (print work directory)  //显示当前目录</span><br><span class="line">mkdir (make directory)  //创建一个新目录</span><br><span class="line">rmdir (remove directory)  //删除一个空目录</span><br><span class="line">cp (copy file)  //复制文件或目录</span><br><span class="line">rm (remove)  //删除文件或目录</span><br><span class="line">mv (move file)  //移动文件与目录或修改文件目录名称</span><br><span class="line">ip addr //显示本机ip地址</span><br><span class="line">su root //切换用户为管理员</span><br><span class="line">clear //清屏</span><br><span class="line">ls -al //显示当前目录文件详情</span><br><span class="line">touch a.txt //新建文件</span><br><span class="line">rm -rf a.txt //强制删除文件</span><br><span class="line">mv a.txt b.txt  //修改文件名</span><br><span class="line">cat a.txt  //查看文本文件内容</span><br></pre></td></tr></table></figure>
<p><strong>Linux命令行下vim编辑器命令如下：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi a.txt  //使用vim编辑器打开文本文件</span><br><span class="line">//按下I键（Insert）即可进入编辑状态方可写入字符</span><br><span class="line">//按下Esc键 即可退出编辑状态进入只读状态</span><br><span class="line">:wq  //保存并退出（在只读状态下）</span><br><span class="line">:q!  //不保存退出</span><br></pre></td></tr></table></figure>
<p>注：可以使用Tab键将部分命令自动补全。</p>
<span id="more"></span>

<h1 id="Linux命令大全"><a href="#Linux命令大全" class="headerlink" title="Linux命令大全"></a>Linux命令大全</h1><p>Linux命令包括：文件管理命令、磁盘管理命令、进程管理命令、网络管理命令、用户管理命令、备份和压缩命令、系统管理命令、打印管理命令、库应用命令、开发应用命令等。</p>
<h2 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls：显示文件名</span><br><span class="line">  cat：显示文本文件内容</span><br><span class="line">  rm：删除文件</span><br><span class="line">  less：分屏显示文件</span><br><span class="line">  cp：复制文件</span><br><span class="line">  mv：更改文件名</span><br><span class="line">  grep：查找字符串</span><br><span class="line">  head：显示文件头部</span><br><span class="line">  tail：显示文件尾部</span><br><span class="line">  sort：按顺序显示文件内容</span><br><span class="line">  uniq：忽略文件中的重复行</span><br><span class="line">  diff：比较两个文件</span><br><span class="line">  diffstat：diff 结果的统计信息</span><br><span class="line">  file：测试文件内容</span><br><span class="line">  echo：显示文本</span><br><span class="line">  date：显示日期和时间</span><br><span class="line">  script：记录 Linux 会话信息</span><br><span class="line">  apropos：搜索关键字</span><br><span class="line">  locate：搜索文件</span><br><span class="line">  mkdir：创建目录</span><br><span class="line">  rmdir：删除目录</span><br><span class="line">  chattr：改变文件的属性</span><br><span class="line">  cksum：文件的 CRC 校验</span><br><span class="line">  cmp：比较文件差异</span><br><span class="line">  split：分割文件</span><br><span class="line">  dirname：显示文件除名字外的路径</span><br><span class="line">  find：查找目录或者文件</span><br><span class="line">  findfs：通过列表或用户 ID 查找文件系统</span><br><span class="line">  ln：链接文件或目录</span><br><span class="line">  lndir：链接目录内容</span><br><span class="line">  lsattr：显示文件属性</span><br><span class="line">  od：输出文件内容</span><br><span class="line">  paste：合并文件的列</span><br><span class="line">  stat：显示 inode 内容</span><br><span class="line">  tee：读取标准输入到标准输出并可保存为文件</span><br><span class="line">  tmpwatch：删除临时文件</span><br><span class="line">  touch：更新文件目录时间</span><br><span class="line">  tree：以树状图显示目录内容</span><br><span class="line">  umask：指定在建立文件时预设的权限掩码</span><br><span class="line">  chmod：设置文件或目录的访问权限</span><br><span class="line">  chgrp：改变文件或目录所属的群组</span><br><span class="line">  chown：改变文件的拥有者或群组</span><br><span class="line">  more：查看文件的内容</span><br><span class="line">  md5sum：MD5 函数值计算和检查</span><br><span class="line">  awk：模式匹配语言</span><br><span class="line">  wc：输出文件中的行数、单词数、字节数</span><br><span class="line">  comm：比较排序文件</span><br><span class="line">  join：将两个文件中指定栏位内容相同的行连接起来</span><br><span class="line">  fmt：编排文本文件</span><br><span class="line">  tr：转换字符</span><br><span class="line">  col：过滤控制字符</span><br><span class="line">  colrm：删除指定的行</span><br><span class="line">  fold：限制文件列宽</span><br><span class="line">  iconv：转换给定文件的编码</span><br><span class="line">  dc：任意精度的计算器</span><br><span class="line">  expr：求表达式变量的值</span><br><span class="line">  strings：显示文件中的可打印字符</span><br><span class="line">  xargs：从标准输入读入参数</span><br><span class="line">  sum：计算文件的校验和，以及文件占用的块数</span><br><span class="line">  setfacl：设定文件访问控制列表</span><br><span class="line">  getfacl：获取文件访问控制列表</span><br><span class="line">  chacl：更改文件或目录的访问控制列表</span><br></pre></td></tr></table></figure>
<h2 id="磁盘管理命令"><a href="#磁盘管理命令" class="headerlink" title="磁盘管理命令"></a>磁盘管理命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df：显示报告文件系统磁盘使用信息</span><br><span class="line">   du：显示目录或者文件所占的磁盘空间</span><br><span class="line">   dd：磁盘操作</span><br><span class="line">   fdisk：磁盘分区</span><br><span class="line">   mount：挂载文件系统</span><br><span class="line">   umount：卸载文件系统</span><br><span class="line">   mkfs：建立各种文件系统</span><br><span class="line">   mkfs.ext2：建立一个 Ext2/Ext3 文件系统</span><br><span class="line">   mkbootdisk：建立启动盘</span><br><span class="line">   fsck：检查文件系统</span><br><span class="line">   blockdev：从命令行调用区块设备控制程序</span><br><span class="line">   hdparm：设置磁盘参数</span><br><span class="line">   mkswap：建立交换分区</span><br><span class="line">   swapon：使用交换空间</span><br><span class="line">   swapoff：关闭系统交换分区</span><br><span class="line">   sync：写入磁盘</span><br><span class="line">   e2label：设置卷标</span><br><span class="line">   badblocks：检查磁盘</span><br><span class="line">   quota：显示磁盘已使用的空间与限制</span><br><span class="line">   quotacheck：检查磁盘的使用空间与限制</span><br><span class="line">   quotaoff：关闭磁盘空间限制</span><br><span class="line">   quotaon：开启磁盘空间限制</span><br><span class="line">   quotastats：显示磁盘空间限制</span><br><span class="line">   repquota：检查磁盘空间限制的状态</span><br><span class="line">   mdadm：RAID 设置工具</span><br><span class="line">   tune2fs：文件系统调整</span><br><span class="line">   mkisofs：建立 ISO 9660 映象文件</span><br><span class="line">   cfdisk：磁盘分区</span><br><span class="line">   sfdisk：硬盘分区工具程序</span><br><span class="line">   parted：磁盘分区工具</span><br><span class="line">   mkinitrd：建立要载入 ramdisk 的映象文件</span><br><span class="line">   ssm：命令行集中存储管理工具</span><br></pre></td></tr></table></figure>
<h2 id="进程管理命令"><a href="#进程管理命令" class="headerlink" title="进程管理命令"></a>进程管理命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">accton：打开或关闭进程统计</span><br><span class="line">   lastcomm：显示以前使用过的命令的信息</span><br><span class="line">   sa：报告、清理并维护进程统计文件</span><br><span class="line">   at：定时运行命令</span><br><span class="line">   atq：显示目前使用 at 命令后待执行的命令队列</span><br><span class="line">   atrm：删除 at 命令中待执行的命令队列</span><br><span class="line">   batch：在系统负载水平允许的时候执行命令</span><br><span class="line">   bg：后台运行命令</span><br><span class="line">   fg：挂起程序</span><br><span class="line">   jobs：显示后台程序</span><br><span class="line">   kill：杀掉进程</span><br><span class="line">   crontab：设置计时器</span><br><span class="line">   ps：查看权限</span><br><span class="line">   pstree：显示进程状态树</span><br><span class="line">   top：显示进程</span><br><span class="line">   nice：改变优先权等级</span><br><span class="line">   renice：修改优先权等级</span><br><span class="line">   sleep：暂停进程</span><br><span class="line">   nohup：用户退出系统之后继续工作</span><br><span class="line">   pgrep：查找匹配条件的进程</span><br><span class="line">   fuser：用文件或者套接口表示进程</span><br><span class="line">   chkconfig：设置系统的各种服务</span><br><span class="line">   strace：跟踪一个进程的系统调用或信号产生的情况</span><br><span class="line">   ltrace：跟踪进程调用库函数的情况</span><br><span class="line">   vmstat：报告虚拟内存统计信息</span><br><span class="line">   mpstat：监测 CPU（包括多 CPU）性能</span><br><span class="line">   iostat：监测 I/O 性能</span><br><span class="line">   sar：系统活动情况报告</span><br><span class="line">   pidof：查找正在运行进程的进程 ID（PID）</span><br><span class="line">   ntsysv：设置系统服务</span><br></pre></td></tr></table></figure>
<h2 id="网络管理命令"><a href="#网络管理命令" class="headerlink" title="网络管理命令"></a>网络管理命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arp：管理系统中的 ARP 高速缓存</span><br><span class="line">   arpwatch：监听 ARP 记录</span><br><span class="line">   arping：发送 ARP 请求到一个相邻主机</span><br><span class="line">   arpd：收集免费 arp 信息的一个守护进程</span><br><span class="line">   finger：查找并显示用户信息</span><br><span class="line">   ifconfig：设置网络接口</span><br><span class="line">   iwconfig：设置无线网卡</span><br><span class="line">   iw：新一代无线网络配置工具</span><br><span class="line">   hostname：显示主机名</span><br><span class="line">   ifup：激活网络设备</span><br><span class="line">   ifdown：禁用网络设备</span><br><span class="line">   mii-tool：调整网卡模式</span><br><span class="line">   route：设置路由表</span><br><span class="line">   netstat：查看网络连接</span><br><span class="line">   ping：检测主机的连通性</span><br><span class="line">   minicom：设置调制解调器</span><br><span class="line">   pppd：建立 PPP 连接</span><br><span class="line">   pppstats：显示 PPP 连接状态</span><br><span class="line">   chat：拨号命令</span><br><span class="line">   traceroute：检查数据包所经过的路由</span><br><span class="line">   tracepath：追踪连接到目标地址所经过的路由</span><br><span class="line">   rcp：远程复制</span><br><span class="line">   tcpdump：网络数据分析器</span><br><span class="line">   ipcalc：IP 地址计算器</span><br><span class="line">   netreport：监视网络状态</span><br><span class="line">   ip：网络集成命令工具</span><br><span class="line">   pppoe-setup：设置 ADSL</span><br><span class="line">   pppoe-start：激活 ADSL 连接</span><br><span class="line">   pppoe-stop：断开 ADSL 连接</span><br><span class="line">   pppoe-status：检测 ADSL 连接状态</span><br><span class="line">   wget：下载文件</span><br><span class="line">   ngrep：监控网络接口</span><br><span class="line">   lsof：查看打开的文件</span><br><span class="line">   ethtool：查询及设置网卡参数</span><br><span class="line">   netconf：设置各项网络功能</span><br><span class="line">   tc：显示和维护流量控制设置</span><br><span class="line">   telnet：远程登录</span><br><span class="line">   rlogin：远程登录命令</span><br><span class="line">   rsh：远程登录的 Shell</span><br><span class="line">   usernetctl：让普通用户控制网络接口</span><br><span class="line">   nmcli：NetworkManager 命令行网络接口配置工具</span><br><span class="line">   nmtui：基于 Curses 的用户界面 nmtui</span><br><span class="line">   nc：netcat，Linux 下用于调试和检查网络的工具包</span><br><span class="line">   lnstat：显示 Linux 系统的网络状态</span><br><span class="line">   ss：显示网络状态信息</span><br><span class="line">   rexec：在指定的远程 Linux 系统主机上执行命令</span><br></pre></td></tr></table></figure>
<h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd：建立用户</span><br><span class="line">   userdel：删除用户</span><br><span class="line">   usermod：修改已有用户的信息</span><br><span class="line">   passwd：设置密码</span><br><span class="line">   chage：密码老化</span><br><span class="line">   groupadd：添加组</span><br><span class="line">   groupdel：删除组账户</span><br><span class="line">   groupmod：修改组</span><br><span class="line">   vipw：编辑/etc/passwd 文件</span><br><span class="line">   vigr：编辑/etc/group 文件</span><br><span class="line">   newgrp：转换组</span><br><span class="line">   groups：显示组</span><br><span class="line">   gpasswd：添加组</span><br><span class="line">   whoami：显示当前用户名称</span><br><span class="line">   who：显示登录用户</span><br><span class="line">   id：显示用户信息</span><br><span class="line">   su：切换身份</span><br><span class="line">   pwck：检测账户</span><br><span class="line">   grpck：检测用户组账号信息的完整性</span><br><span class="line">   chsh：设置 Shell</span><br><span class="line">   chfn：修改用户信息</span><br><span class="line">   ac：显示用户在线时间的统计信息</span><br><span class="line">   grpconv：开启群组的投影密码</span><br><span class="line">   grpunconv：关闭群组的投影密码</span><br><span class="line">   lastlog：显示最近登录用户的用户名、登录端口和 登录时间</span><br><span class="line">   logname：显示当前用户的名称</span><br><span class="line">   users：显示当前登录到系统的用户</span><br><span class="line">   lastb：显示登录系统失败用户的相关信息</span><br></pre></td></tr></table></figure>
<h2 id="备份和压缩命令"><a href="#备份和压缩命令" class="headerlink" title="备份和压缩命令"></a>备份和压缩命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar：备份文件</span><br><span class="line">   dump：备份文件系统</span><br><span class="line">   cpio（copy in/out）：建立、还原备份文件</span><br><span class="line">   restore：还原备份下来的文件或整个文件系统（一个分区）</span><br><span class="line">   bunzip2：解压缩.bz2 文件</span><br><span class="line">   bzip2：压缩成.bz2 文件</span><br><span class="line">   bzgrep：使用正则表达式搜索.bz2 压缩包中的文件</span><br><span class="line">   unzip：解压缩.zip 文件</span><br><span class="line">   bzip2recover：修复损坏的.bz2 文件</span><br><span class="line">   gzip：压缩文件</span><br><span class="line">   compress：压缩、解压文件</span><br><span class="line">   gzexe：压缩执行文件</span><br><span class="line">   lha：压缩或解压缩文件</span><br><span class="line">   unarj：解压缩文件</span><br><span class="line">   zip：压缩文件</span><br><span class="line">   zipinfo：显示压缩文件的信息</span><br></pre></td></tr></table></figure>
<h2 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apmd：高级电源管理</span><br><span class="line">   apmsleep：APM 进入休眠状态</span><br><span class="line">   apropos：查找使用手册的名字和相关描述</span><br><span class="line">   arch：输出主机的体系结构</span><br><span class="line">   alias：设置别名</span><br><span class="line">   cd：切换目录</span><br><span class="line">   clear：清空终端屏幕</span><br><span class="line">   clock：系统 RTC 时间设置</span><br><span class="line">   cal：显示日历</span><br><span class="line">   chroot：改变根目录</span><br><span class="line">   date：显示或设置系统时间</span><br><span class="line">   dmesg：显示开机信息</span><br><span class="line">   dircolors：设置 ls 命令在显示目录或文件时所用的色彩</span><br><span class="line">   depmod：分析模块</span><br><span class="line">   echo：显示文本行</span><br><span class="line">   exec：执行完命令后交出控制权</span><br><span class="line">   exit：退出 Shell</span><br><span class="line">   eject：弹出介质</span><br><span class="line">   enable：启动或关闭 Shell 命令</span><br><span class="line">   fc：修改或执行命令</span><br><span class="line">   fgconsole：显示虚拟终端的数目</span><br><span class="line">   free：显示内存信息</span><br><span class="line">   fwhois：显示用户的信息</span><br><span class="line">   getty：设置终端模式</span><br><span class="line">   gitps：显示程序情况</span><br><span class="line">   logwatch：可定制和可插入式的日志监视系统</span><br><span class="line">   logsave：把一个命令的输出输出到一个指定的日志 文件中</span><br><span class="line">   GRUB：引导加载程序</span><br><span class="line">   halt：关闭系统</span><br><span class="line">   history：显示历史命令</span><br><span class="line">   hwclock：显示与设定硬件时钟</span><br><span class="line">   init：进程处理初始化</span><br><span class="line">   last：显示登录用户信息</span><br><span class="line">   lilo：引导管理器</span><br><span class="line">   login：登录系统</span><br><span class="line">   local：显示本地支持的语言系统信息</span><br><span class="line">   logout：退出系统</span><br><span class="line">   logrotate：处理 Log 文件</span><br><span class="line">   lsmod：显示 Linux 内核的模块信息</span><br><span class="line">   man：格式化和显示在线手册</span><br><span class="line">   manpath：设置 man 手册的查询路径</span><br><span class="line">   modinfo：显示内核信息</span><br><span class="line">   modprobe：自动处理可载入模块</span><br><span class="line">   pmap：显示程序的内存信息</span><br><span class="line">   procinfo：显示系统状态</span><br><span class="line">   pwd：显示工作目录</span><br><span class="line">   reboot：重新启动系统</span><br><span class="line">   rlogin：远程登录</span><br><span class="line">   rmmod：删除模块</span><br><span class="line">   rpm：软件包管理</span><br><span class="line">   shutdown：系统关机命令</span><br><span class="line">   suspend：暂停执行 Shell</span><br><span class="line">   nproc：打印当前进程可用的处理器数</span><br><span class="line">   tload：显示系统负载</span><br><span class="line">   uname：显示系统信息</span><br><span class="line">   authconfig：配置系统的认证信息</span><br><span class="line">   declare：显示或者设定 Shell 变量</span><br><span class="line">   export：设置或者显示环境变量</span><br><span class="line">   hostid：打印出当前主机的标识</span><br><span class="line">   insmod：载入模块</span><br><span class="line">   rdate：显示其他主机的日期与时间</span><br><span class="line">   runlevel：显示执行等级</span><br><span class="line">   set：设置 Shell</span><br><span class="line">   setenv：查询或显示环境变量</span><br><span class="line">   setserial：设置或显示串口的相关信息</span><br><span class="line">   setup：设置公用程序</span><br><span class="line">   symlinks：维护符号链接的工具程序</span><br><span class="line">   swatch：系统监控程序</span><br><span class="line">   sync：将内存缓冲区内的数据写入磁盘</span><br><span class="line">   startx：启动 X Window</span><br><span class="line">   sysctl：设置系统核心参数</span><br><span class="line">   timeconfig：设置时区</span><br><span class="line">   ulimit：控制 Shell 程序的资源</span><br><span class="line">   unalias：删除别名</span><br><span class="line">   unset：删除变量或函数</span><br><span class="line">   up2date：软件包升级</span><br><span class="line">   uptime：告知系统运行了多长时间</span><br><span class="line">   mouseconfig：设置鼠标相关参数</span><br><span class="line">   bind：显示或设置键盘按键及其相关的功能</span><br><span class="line">   kbdconfig：设置键盘类型</span><br><span class="line">   snapscreenshot：命令行截图</span><br><span class="line">   mt：磁带机控制</span><br><span class="line">   cdrecord：CD 刻录工具</span><br><span class="line">   dvdrecord：DVD 刻录工具</span><br><span class="line">   lspci：查看硬件插槽</span><br><span class="line">   sane-find-scanner：扫描仪搜索</span><br><span class="line">   scanimage：检测扫描仪型号</span><br><span class="line">   mtools：命令集</span><br><span class="line">   whereis：查找文件</span><br><span class="line">   ytalk：与其他用户交谈</span><br><span class="line">   apt：软件包在线管理</span><br><span class="line">   yum：在线管理软件包</span><br><span class="line">   vlock：锁定终端</span><br><span class="line">   wait：等待程序返回状态</span><br><span class="line">   watch：将结果输出到标准输出设备</span><br><span class="line">   rsync：远程数据同步工具</span><br><span class="line">   &amp;：将任务放在后台执行</span><br><span class="line">   screen：多重视窗管理程序</span><br><span class="line">   lsb_release：显示 LSB 和特定版本的相关信息</span><br><span class="line">   lscpu：查看 CPU 信息</span><br><span class="line">   blkid：查看块设备</span><br><span class="line">   journalctl：日志管理</span><br><span class="line">   lsblk：列出块设备</span><br><span class="line">   systemd：服务管理命令组</span><br></pre></td></tr></table></figure>
<h2 id="打印管理命令"><a href="#打印管理命令" class="headerlink" title="打印管理命令"></a>打印管理命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cupsd：通用打印程序守护进程</span><br><span class="line">   cupsaccept：指示打印系统接受发往指定目标打印机的打印任务</span><br><span class="line">   lpadmin：配置 LP 打印服务</span><br><span class="line">   lp：打印文件</span><br><span class="line">   lpstat：显示行式打印机的状态信息</span><br><span class="line">   lpr：排队打印作业</span><br><span class="line">   lprm：从打印队列中删除任务</span><br><span class="line">   lpc：控制打印机</span><br><span class="line">   lpq：检查假脱机队列</span><br><span class="line">   lpinfo：显示驱动和设备</span><br><span class="line">   lpmove：将作业从一个队列移动到另一个队列</span><br><span class="line">   cancel：取消已存在的打印任务</span><br><span class="line">   cupsdisable：禁用指定的打印机或类</span><br><span class="line">   cupsreject：指示打印系统拒绝发往指定目标打印机的打印任务</span><br><span class="line">   cupsenable：启动指定的打印机</span><br></pre></td></tr></table></figure>
<h2 id="库应用命令"><a href="#库应用命令" class="headerlink" title="库应用命令"></a>库应用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldconfig：配置查找共享库</span><br><span class="line">   nm：列举目标文件中的符号名</span><br><span class="line">   ar：建立修改文件或从文件中抽取成员</span><br><span class="line">   strip：去除目标文件中的无用信息</span><br><span class="line">   objdump：展开目标文件、静态库和共享库中的信息</span><br><span class="line">   ldd：显示共享库的依赖情况</span><br><span class="line">   patch：修补文件</span><br><span class="line">   ld：连接器</span><br></pre></td></tr></table></figure>
<h2 id="开发应用命令"><a href="#开发应用命令" class="headerlink" title="开发应用命令"></a>开发应用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">as：标准 GNU 汇编程序</span><br><span class="line">nasm：汇编器</span><br><span class="line">gcc：C/C++编译器</span><br><span class="line">make：维护和编译软件或软件包</span><br><span class="line">gdb：GUN 调试器</span><br><span class="line">gdbserver：远端 GNU 服务器</span><br><span class="line">autoconf：产生配置脚本</span><br><span class="line">autoheader：为 configure 产生模板头文件</span><br><span class="line">autoreconf：更新已经生成的配置文件</span><br><span class="line">autoscan：产生初步的 configure.in 文件</span><br><span class="line">autoupdate：更新 configure.in 文件</span><br><span class="line">automake：自动生成 Makefile.in 的工具</span><br><span class="line">aclocal：生成 aclocal.m4 文件</span><br><span class="line">configure：生成 Makefile 文件</span><br></pre></td></tr></table></figure>
<h2 id="行编辑器"><a href="#行编辑器" class="headerlink" title="行编辑器"></a>行编辑器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ed：文本编辑器</span><br><span class="line">sed：利用 script 命令处理文本文件</span><br><span class="line">pico：编辑文字文件</span><br><span class="line">vim：全屏幕文本编辑器</span><br><span class="line">ex：文本编辑器</span><br><span class="line">nano：文本编辑器</span><br><span class="line">jed：编辑文本文件</span><br><span class="line">joe：编辑文本文件</span><br></pre></td></tr></table></figure>


<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/08/30/Linux1/">https://scholargeek.github.io/2018/08/30/Linux1/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件基本属性</title>
    <url>/2018/09/03/Linux3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux文件属性"><a href="#Linux文件属性" class="headerlink" title="Linux文件属性"></a>Linux文件属性</h1><p>　　Linux系统是典型的多用户系统，不同的用户处于不同的地位就拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。<br>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：<br>    chown (change owner) ： 修改所属用户与组。<br>    chmod (change mode) ： 修改用户的权限。<br>使用<code>ls-l</code>命令以显示一个文件的属性以及文件所属的用户和组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# ls -l</span><br><span class="line">总用量 16</span><br><span class="line">lrwxrwxrwx.   1 root root    7 5月   3 2016 bin -&gt; usr/bin</span><br><span class="line">dr-xr-xr-x.   5 root root 4096 5月   3 2016 boot</span><br><span class="line">drwxr-xr-x.  20 root root 3220 1月  26 20:45 dev</span><br><span class="line">drwxr-xr-x.   3 root root   19 5月   8 2016 docker_data</span><br><span class="line">drwxr-xr-x.  83 root root 8192 1月  26 20:45 etc</span><br><span class="line">drwxr-xr-x.   3 root root   17 5月   3 2016 home</span><br><span class="line">lrwxrwxrwx.   1 root root    7 5月   3 2016 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx.   1 root root    9 5月   3 2016 lib64 -&gt; usr/lib64</span><br><span class="line">drwxr-xr-x.   2 root root    6 4月  11 2016 media</span><br><span class="line">drwxr-xr-x.   2 root root    6 4月  11 2016 mnt</span><br><span class="line">drwxr-xr-x.   3 root root   24 5月   8 2016 opt</span><br><span class="line">dr-xr-xr-x. 132 root root    0 1月  26 20:45 proc</span><br><span class="line">dr-xr-x---.   3 root root  147 5月   8 2016 root</span><br><span class="line">drwxr-xr-x.  23 root root  680 1月  26 20:45 run</span><br><span class="line">lrwxrwxrwx.   1 root root    8 5月   3 2016 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x.   2 root root    6 4月  11 2018 srv</span><br><span class="line">dr-xr-xr-x.  13 root root    0 1月  26 20:45 sys</span><br><span class="line">drwxrwxrwt.   7 root root   93 1月  26 21:40 tmp</span><br><span class="line">drwxr-xr-x.  13 root root  155 5月   3 2016 usr</span><br><span class="line">drwxr-xr-x.  19 root root  267 5月   3 2016 var</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="文件属性符号解释"><a href="#文件属性符号解释" class="headerlink" title="文件属性符号解释"></a>文件属性符号解释</h2><p>第一个字符代表含义解释如下：<br>当为 d 则是目录<br>当为 - 则是文件<br>若是 l 则表示为链接文档(link file)；<br>若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；<br>若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</p>
<p>第二到第十个字符代表含义解释如下:<br>以三个为一组，且均为 rwx 的三个参数的组合,共三组。<br>r 代表可读(read)<br>w 代表可写(write)<br>x 代表可执行(execute)<br>注意这三个权限的位置不会改变，如果没有权限用减号 - 表示。</p>
<p>每个文件的属性由左边第一部分的 10 个字符来确定，如下图：<br><img src="https://s3.bmp.ovh/imgs/2024/01/26/7790891a34385816.png" alt="Linux文件属性"></p>
<h2 id="使用命令修改属性"><a href="#使用命令修改属性" class="headerlink" title="使用命令修改属性"></a>使用命令修改属性</h2><p><strong>文件用户组9个属性说明</strong><br>　　Linux 文件的基本权限就有九个，分别是 owner&#x2F;group&#x2F;others(拥有者&#x2F;组&#x2F;其他) 三种身份各有自己的 read&#x2F;write&#x2F;execute 权限。<br>　　九个权限分三组，每组3个。可以使用数字来代表各个权限，各权限的分数对照表如下：<br>    r:4<br>    w:2<br>    x:1<br>每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数需要累加，如当权限为： -rwxrwx—<br>其分数则是<br>    owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7<br>    group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7<br>    others&#x3D; — &#x3D; 0+0+0 &#x3D; 0<br><strong>使用chmod命令变更权限</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>
<p>选项与参数解释：<br>    xyz : 就是数字类型的权限属性，为rwx属性数值的相加，共三组。<br>    -R : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更。<br>例：将Hello.txt文件赋予最高权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost work]# ls -l</span><br><span class="line">-rw-r--r--.  1 root root 110 6月   2 20:36 Hello.txt</span><br><span class="line">[root@localhost work]# chmod 777 Hello.txt </span><br><span class="line">[root@localhost work]# ls -l</span><br><span class="line">-rwxrwxrwx.  1 root root 110 6月   2 20:36 Hello.txt</span><br></pre></td></tr></table></figure>


<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/09/03/Linux3/">https://scholargeek.github.io/2018/09/03/Linux3/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS简介与基本配置</title>
    <url>/2018/09/05/Linux4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CentOS简介"><a href="#CentOS简介" class="headerlink" title="CentOS简介"></a>CentOS简介</h1><p>　　CentOS(Community Enterprise Operating System)是Linux发行版之一，它来自于Red Hat Enterprise Linux（RHEL）依照开放源代码规定发布的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。两者的不同，在于CentOS并不包含封闭源代码软件。CentOS 对上游代码的主要修改是为了移除不能自由使用的商标。CentOS和RHEL一样，都可以使用Fedora EPEL来补足软件。<br>2014年，CentOS宣布与Red Hat合作，但CentOS将会在新的委员会下继续运作，不受RHEL的影响。<br>2020年12月8日，红帽公司单方面终止CentOS的开发。CentOS的创始人Gregory Kurtzer创建了Rocky Linux项目，以继承CentOS的原始目标。<br>目前，CentOS的上游版本滚动更新版分支CentOS Stream开发仍在继续。</p>
<span id="more"></span>

<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p><img src="https://s3.bmp.ovh/imgs/2024/01/26/959c7694e63cee36.png" alt="Centos-logo"><br>开发者：CentOS项目（隶属于Red Hat）<br>操作系统家族：Linux<br>运作状态：停止开发<br>源码模式：开放源代码<br>首次发布：2004年5月14日，​19年前<br>当前版本：9 (2021年12月3日；稳定版本)<br>市场取向：台式机、大型计算机、服务器及工作站<br>更新方式：长期支持<br>软件包管理系统：Yum（命令行）、dnf (命令行)、PackageKit (图形)、RPM（二进制格式）<br>支持平台：amd64<br>内核类别：宏内核（Linux内核）<br>默认用户界面：命令行、GNOME及KDE Plasma（用户可选）<br>许可证：自由软件（GNU通用公共许可证及其他许可证）<br>官方网站：<a href="https://www.centos.org/">https://www.centos.org/</a></p>
<h2 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h2><p>1.CentOS&#x2F;RHEL的生命周期较长，可以覆盖硬件的生命周期，也意味着硬件更新后不用再次安装操作系统。<br>2.CentOS&#x2F;RHEL对硬件支持良好，主流硬件厂商经过测试一般不存在硬件的兼容性问题。<br>3.大量商业软件如 Oracle 针对Redhat认证，有大量的帮助文档和使用说明，提供良好的技术支持。<br>4.CentOS 是RedHat的克隆版，如果需要可以随时平滑切换到 RedHat，从而享受RedHat的服务支持。<br>5.国内最初商业使用和教学资料等历史原因影响使得CentOS&#x2F;RHEL广泛使用。</p>
<h1 id="CentOS基本配置"><a href="#CentOS基本配置" class="headerlink" title="CentOS基本配置"></a>CentOS基本配置</h1><p>　　在虚拟机中安装好CentOS以方便实验，本次实验的配置有：设置静态IP、安装JavaJdk、安装TomCat、安装Docker、安装MySQL、安装Redis。</p>
<h2 id="设置静态IP"><a href="#设置静态IP" class="headerlink" title="设置静态IP"></a>设置静态IP</h2><p>1.查看虚拟机中的网卡具体信息，如在NAT设置中的子网IP、子网掩码、网关等信息。<br>2.在CentOS中使用Vi编辑器编辑网络配置文件，进入<code>/etc/sysconfig/network-scripts</code>路径下，编辑ifcfg-ens33文件，如下内容并保存。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BOOTPROTO=&quot;static&quot;  //修改</span><br><span class="line"></span><br><span class="line">//增加如下条目</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">IPADDR=192.168.105.188</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.1.1  //根据虚拟网络编辑器网卡中网关地址设置</span><br><span class="line">DNS1=8.8.8.8</span><br><span class="line">DNS2=180.76.76.76</span><br></pre></td></tr></table></figure>
<p>3.重启网络服务，输入命令：<code>systemctl restart network</code></p>
<h2 id="安装JavaJdk"><a href="#安装JavaJdk" class="headerlink" title="安装JavaJdk"></a>安装JavaJdk</h2><p>　　安装Java Jdk以提供java支持。本次使用yum在线安装，Yum(Yellow dogUpdater Modifier)是CentOS等服务器系统中的Shell前端软件包管理器。<br>1.查询当前环境下是否安装有Jdk环境，输入<code>rpm -qa|grep jdk</code>命令以检测当前jdk是否存在。（可以使用 <code>yum -y remove xxx</code> 命令卸载指定软件）<br>2.使用<code>yum install -y java-1.8.0-openjdk-devel.x86_64</code>命令安装。完成后输入<code>java -version</code>命令以检测是否安装成功。</p>
<h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><p>　　Tomcat是免费开放源代码的Web应用服务器，安装Tomcat以提供Web服务。首先从<a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a> 下载安装包并上传至Linux服务器上，如apache-tomcat-8.5.tar.gz 压缩文件，可存放至<code>/usr/local</code>目录下。再使用<code>tar -zxvf apache-tomcat-8.5.tar.gz</code>解压到当前目录。（Tomcat为免安装应用程序，解压即可使用。）<br>　　进入<code>/usr/local/apache-tomcat-8.5.75</code>目录下，看到如下文件及文件夹：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost apache-tomcat-8.5.75]# ls</span><br><span class="line">bin  BUILDING.txt  conf  CONTRIBUTING.md  lib  LICENSE  logs  NOTICE  README.md  RELEASE-NOTES  RUNNING.txt  temp  webapps  work</span><br></pre></td></tr></table></figure>
<p>　　其中，bin&#x2F; 目录下含有启动与关闭脚本；webapps&#x2F; 目录内存放Java项目；logs&#x2F; 目录下存放日志文件。<br>　　进入bin&#x2F; 目录输入<code>sh startup.sh</code> 命令以启动Tomcat，若要验证服务可以打开本地游览器输入<a href="http://ip:8080/">http://ip:8080/</a> (其中IP为Linux服务器IP地址)，若无法访问请开启对应端口或者关闭服务器防火墙，关闭防火墙命令为<code>systemctl stop firewalld</code>。若要关闭Tomcat请进入bin&#x2F; 目录输入<code>./shutdown.sh</code> 。<br>　　在游览器中可以根据 URL（统一资源定位器）访问对应的Java项目。<br>    <a href="http://IP:port/项目名/资源名">http://IP:port/项目名/资源名</a><br>　　若遇错误可查看日志，其存放路径在<code>/apache-tomcat-8.5.75/logs</code>，其中catalina.out为启动日志。可使用<code>tail -f catalina.out</code>命令查看启动日志。</p>
<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>　　Docker是开源的应用容器引擎，基于Go语言开发并且遵从Apache2.0协议。使开发者可以打包其应用及依赖包到这个轻量级、可移植的容器中，然后发布到任何流行的Linux服务器中，可以实现虚拟化。应用容器是完全使用沙箱机制并且之间无任何接口，重要的是容器性能开销极低。<br>　　使用命令安装Docker，在命令行中执行如下步骤。<br>1.安装必要的系统工具 <code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code><br>2.配置镜像源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//添加阿里docker镜像源</span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">//添加清华docker镜像源</span><br><span class="line">sudo yum-config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>3.生成缓存 <code>sudo yum makecache fast</code><br>4.更新并安装Docker-CE <code>sudo yum install -y docker-ce</code><br>5.启动及关闭Docker服务并检查版本信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line">//或</span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line">//查看版本信息</span><br><span class="line">docker version</span><br><span class="line">//或</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line">//关闭Docker</span><br><span class="line">systemctl stop docker</span><br><span class="line">//或</span><br><span class="line">sudo service docker stop</span><br></pre></td></tr></table></figure>
<p><strong>Docker内文件及应用操作命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images  //查看已下载的镜像文件</span><br><span class="line">docker rmi IMAGE ID  //删除已下载的镜像文件</span><br><span class="line">docker pull 包名  //下载指定包名的镜像</span><br><span class="line">docker ps  //查看正在运行的容器（软件）</span><br><span class="line">docker ps -a //查看所有已安装的容器</span><br><span class="line">docker stop CONTAINER ID  //停止运行容器</span><br><span class="line">docker rm CONTAINER ID  //卸载容器（软件）</span><br><span class="line">docker run ID  //运行指定ID的镜像</span><br><span class="line">docker start ID  //启动指定ID的容器</span><br></pre></td></tr></table></figure>
<h3 id="在Docker中安装软件"><a href="#在Docker中安装软件" class="headerlink" title="在Docker中安装软件"></a>在Docker中安装软件</h3><p><strong>安装MySQL</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7  //下载MySql镜像</span><br><span class="line">docker run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7  //安装MySQL并设置端口及密码</span><br></pre></td></tr></table></figure>
<p><strong>安装Redis</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redis:latest  //下载redis镜像</span><br><span class="line">docker run -d --name redis -p 6379:6379 redis --requirepass &quot;123456&quot;  //安装并设置redis</span><br></pre></td></tr></table></figure>


<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/09/05/Linux4/">https://scholargeek.github.io/2018/09/05/Linux4/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习</title>
    <url>/2022/12/30/MySQL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库基本概念与MySQL入门"><a href="#数据库基本概念与MySQL入门" class="headerlink" title="数据库基本概念与MySQL入门"></a>数据库基本概念与MySQL入门</h1><p>　　数据库可以看作电子化的文件柜——存储电子文件的处所。用户可以对文件中的资料执行新增、查询、更新、删除等操作。所谓“数据库”是以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间(Tablespace)构成。</p>
<span id="more"></span>

<h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><p>　　数据库就是”数据“的仓库，一种用于存储信息和数据的软件，它由表、关系、及操作对象组成，数据放在表中。数据库服务器即安装了数据库软件的计算机，一般以主从式架构提供数据库服务。<br><img src="https://s3.bmp.ovh/imgs/2024/03/20/78e8b6092568654a.png" alt="数据库服务器功能"><br><strong>应用程序</strong><br>作用：响应操作并显示结果，向数据库请求数据。<br>要求：美观并且操作简单方便。<br><strong>数据库服务器</strong><br>作用：存储数据、检索数据、生成新的数据。<br>要求：统一、安全、性能等。</p>
<h3 id="技术初衷"><a href="#技术初衷" class="headerlink" title="技术初衷"></a>技术初衷</h3><p>　　在操作系统出现之后，随着计算机应用范围的扩大、需要处理的数据迅速膨胀。最初，数据与程序一样，以简单的文件作为主要存储形式。以这种方式组织的数据在逻辑上更简单，但可扩展性差，访问这种数据的程序需要了解数据的具体组织格式。当系统数据量大或者用户访问量大时，应用程序还需要解决数据的完整性、一致性以及安全性等一系列的问题。因此，必须开发出一种系统软件，它应该能够像操作系统屏蔽了硬件访问复杂性那样，屏蔽数据访问的复杂性。由此产生了数据管理系统，即数据库。</p>
<h3 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h3><p>　　数据库管理系统(Database Management System)，简称DBMS。是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。数据库管理系统可以依据它所支持的数据库模型来作分类，例如关系式、XML；或依据所支持的电脑类型来作分类，例如服务器聚类、移动电话；或依据所用查询语言来作分类，例如SQL、XQuery；或依据性能冲量重点来作分类，例如最大规模、最高执行速度；亦或其他的分类方式。不论使用哪种分类方式，一些DBMS能够跨类别，例如，同时支持多种查询语言。</p>
<h3 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h3><p>　　随着数据库技术与其他分支学科技术的结合，出现了多种新型数据库，例如：与分布处理技术结合产生的分布式数据库、与并行处理技术结合产生的并行数据库、与人工智能结合产生的演绎数据库、与多媒体技术结合产生的多媒体数据库。另外，数据库技术应用于特定的领域，出现了工程数据库、 地理数据库、统计数据库、空间数据库等特定领域数据库。<br>常见关系数据库:<br>MySQL   MariaDB   Percona Server   PostgreSQL   Microsoft Access   Microsoft SQL Server   Google Fusion Tables   FileMaker   Oracle数据库   Sybase   dBASE   Clipper   FoxPro   foshub<br>常见非关系型数据库(NoSQL):<br>BigTable(Google)   Cassandra   MongoDB   CouchDB   Redis   Apache Cassandra   Dynamo   LevelDB(Google)</p>
<h3 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h3><p>　　SQL(Structured Query Language)结构化查询语言是一种特定目的编程语言，用于管理关系数据库管理系统（RDBMS），或在关系流数据管理系统(RDSMS)中进行流处理。SQL基于关系代数和元组关系演算，包括一个数据定义语言和数据操纵语言。SQL的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</p>
<h2 id="MySQL入门"><a href="#MySQL入门" class="headerlink" title="MySQL入门"></a>MySQL入门</h2><p>　　MySQL原本是一个开放源码的关系数据库管理系统，原开发者为瑞典的MySQL AB公司，该公司于2008年被昇阳微系统(Sun Microsystems)收购。2009年，甲骨文公司(Oracle)收购昇阳微系统公司，MySQL成为Oracle旗下产品。MySQL在过去由于性能高、成本低、可靠性好，已经成为最流行的开源数据库，因此被广泛地应用在Internet上的中小型网站中。随着MySQL的不断成熟，它也逐渐用于更多大规模网站和应用。非常流行的开源软件组合LAMP中的“M”指的就是MySQL。<br>官方网站:<a href="https://www.mysql.com/">https://www.mysql.com</a></p>
<h3 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h3><p>●使用命令行工具管理MySQL数据库（命令mysql和mysqladmin），也可以从MySQL的网站下载图形管理工具MySQL Workbench。<br>●Navicat是一套专为MySQL设计的强大数据库管理及开发工具。它可以用于任何版本的MySQL数据库，并支持大部分MySQL的功能，包括触发器、索引、查看等。<br>●phpMyAdmin是由PHP写成的MySQL数据库系统管理程序，让管理者可用Web接口管理MySQL数据库。借由此Web接口可以成为一个简易方式输入繁杂SQL语法的较佳途径，尤其要处理大量资料的导入及导出更为方便。其中一个更大的优势在于由于phpMyAdmin跟其他PHP程序一样在网页服务器上执行，但是可以在任何地方使用这些程序产生的HTML页面，也就是于远程管理MySQL数据库。使用phpMyAdmin就可以方便的建立、修改、删除数据库及资料表。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- 创建XX数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE XX;</span><br><span class="line"><span class="comment">-- 删除XX数据库</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE XX;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">新建两张表</span></span><br><span class="line"><span class="comment">班级表 （班级编号 班级名称）</span></span><br><span class="line"><span class="comment">学生表 （学生编号 学生姓名 学生年龄 生日 身高 班级编号）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- PRIMARY KEY 主键</span></span><br><span class="line"><span class="comment">-- NOT NULL 数据必须插入，不能为空</span></span><br><span class="line"><span class="comment">-- COMMENT 注释</span></span><br><span class="line"><span class="comment">-- FOREIGN KEY 外键</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> classes</span><br><span class="line">(</span><br><span class="line">bjid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY out_increment COMMENT<span class="string">&#x27;班级编号&#x27;</span>,</span><br><span class="line">bjname <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;班级名称&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student</span><br><span class="line">(</span><br><span class="line">stuid <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY auto_increment COMMENT<span class="string">&#x27;学生编号&#x27;</span>,</span><br><span class="line">stuname <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;学生姓名&#x27;</span>,</span><br><span class="line">age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">3</span> COMMENT<span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">birthday <span class="type">DATE</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27;生日&#x27;</span>,</span><br><span class="line">height <span class="type">FLOAT</span> COMMENT<span class="string">&#x27;身高&#x27;</span>,</span><br><span class="line">bjid <span class="type">INT</span> COMMENT<span class="string">&#x27;班级编号&#x27;</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (bjid) <span class="keyword">REFERENCES</span> classes(bjid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2022/12/30/MySQL/">https://scholargeek.github.io/2022/12/30/MySQL/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习1</title>
    <url>/2023/02/01/MySQL1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL数据管理"><a href="#MySQL数据管理" class="headerlink" title="MySQL数据管理"></a>MySQL数据管理</h1><p>　　管理MySQL数据库可以使用命令窗口(cmd)，也可以使用第三方专业数据库管理工具如(Navicat)。Navicat 作为一款为 MySQL 设计的可视化数据库 GUI 管理工具，使得可以使用图形化界面远程管理MySQL 数据库。在管理数据库时常用的操作有增删改查，本文将简述数据库基础管理四种操作的SQL语法。</p>
<span id="more"></span>

<h2 id="Navicat简单用法"><a href="#Navicat简单用法" class="headerlink" title="Navicat简单用法"></a>Navicat简单用法</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>　　从Navicat官网 <a href="http://www.navicat.com.cn/">http://www.navicat.com.cn/</a> 下载并安装软件。打开Navicat ，点击<strong>连接</strong>按钮，选择数据库<strong>MySQL</strong>，填写连接的数据库服务器信息，点击<strong>测试连接</strong>按钮检查连接是否成功。<br>①选择数据库类型<br><img src="https://s3.bmp.ovh/imgs/2024/03/22/43b3d4c7f998f8e6.png" alt="Navicat连接数据库"><br>②填写数据库服务器连接信息<br><img src="https://s3.bmp.ovh/imgs/2024/03/22/c31ce5d7f4180129.png" alt="Navicat连接数据库1"><br>③测试数据库服务器能否连接<br><img src="https://s3.bmp.ovh/imgs/2024/03/22/a5eb60bbd667e5f1.png" alt="Navicat连接数据库2"></p>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>　　在Navicat可以使用鼠标点击软件菜单栏按钮完成简单的数据查询，也可以使用SQL语句在软件查询命令窗口查询数据。使用命令窗口查询数据方法如下：<br>①新建查询窗口<br><img src="https://s3.bmp.ovh/imgs/2024/03/22/16fd1b607e2c38ad.png" alt="Navicat查询数据库"><br>②设置查询数据库参数并输入SQL语句，选择要执行的语句后点击运行按钮即可执行。<br><img src="https://s3.bmp.ovh/imgs/2024/03/22/2dedc7ea1b4883fe.png" alt="Navicat查询数据库1"></p>
<h2 id="数据库的增删改查"><a href="#数据库的增删改查" class="headerlink" title="数据库的增删改查"></a>数据库的增删改查</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>　　●语法：<code>INSERT INTO 表名(字段1，字段2，字段3...) VALUES(值1，值2，值3...);</code><br><strong>例：</strong>向学生表(student)中录入一名年龄是25岁 籍贯为上海 专业为计算机 出生于1999-1-6 名叫天明 在3号班级学习的男生信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student(stuAge,stuAddress,stuMajor,stuBirthday,stuName,bjid,stuSex) <span class="keyword">VALUES</span>(<span class="number">25</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;计算机&#x27;</span>,<span class="string">&#x27;1999-1-6&#x27;</span>,<span class="string">&#x27;天明&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>　　●语法：<code>DELETE FROM 表名 WHERE 条件</code><br><strong>例：</strong>删除名字中包含刁并且年龄在12-20之间的学生信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> stuName <span class="keyword">LIKE</span> <span class="string">&#x27;%刁%&#x27;</span> <span class="keyword">AND</span> stuAge <span class="keyword">BETWEEN</span> <span class="number">12</span> <span class="keyword">AND</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<h3 id="更改数据"><a href="#更改数据" class="headerlink" title="更改数据"></a>更改数据</h3><p>　　●语法：<code>UPDATE 表名 SET 字段1=新值1,字段2=新值2,... WHERE 条件</code><br><strong>例：</strong>修改班级表(classes)编号为3的班级名称为IT2022。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> classes</span><br><span class="line"><span class="keyword">SET</span> bjname <span class="operator">=</span> <span class="string">&#x27;IT2022&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> bjid <span class="operator">=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="查询数据-1"><a href="#查询数据-1" class="headerlink" title="查询数据"></a>查询数据</h3><p>　　●语法：<code>SELECT 查询字段1,查询字段2,查询字段3 FROM 表1,表2... WHERE 条件</code><br><strong>例：</strong>查询分数表(grade)不及格的分数信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sccid,stuid,cid,score</span><br><span class="line"><span class="keyword">FROM</span> grade</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="operator">&lt;</span> <span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>　　●模糊查询LIKE子句通配符解释</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>%</td>
<td>表示任意 0 个或多个字符，可匹配任意类型和长度的字符。</td>
<td><code>name like &#39;%刁%&#39;</code></td>
</tr>
<tr>
<td>_</td>
<td>表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句。</td>
<td><code>name like &#39;王_&#39;</code></td>
</tr>
<tr>
<td>[]</td>
<td>表示括号内所列字符中的一个(类似正则表达式),指定字符范围匹配对象为它们中的任一个。</td>
<td><code>TEL like &#39;152%[1-6]&#39; </code></td>
</tr>
<tr>
<td>[^]</td>
<td>表示不在括号所列之内的单个字符,要求所匹配对象为指定字符以外的任一个字符。</td>
<td><code>TEL like &#39;152%[^4]&#39;</code></td>
</tr>
</tbody></table>
<h3 id="MySQL运算符"><a href="#MySQL运算符" class="headerlink" title="MySQL运算符"></a>MySQL运算符</h3><p>　　MySQL主要有四种运算符：<strong>算术运算符</strong> <strong>比较运算符</strong> <strong>逻辑运算符</strong> <strong>位运算符</strong></p>
<p>●<strong>算术运算符</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
</tr>
<tr>
<td>&#x2F; 或 DIV</td>
<td>除法</td>
</tr>
<tr>
<td>% 或 MOD</td>
<td>取余</td>
</tr>
<tr>
<td>在除法运算和模运算中，如果除数为0，将是非法除数，返回结果为NULL。</td>
<td></td>
</tr>
</tbody></table>
<p>●<strong>比较运算符</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>等于</td>
<td></td>
</tr>
<tr>
<td>&lt;&gt;, !&#x3D;</td>
<td>不等于</td>
<td></td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td></td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td></td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
<td></td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
<td></td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在两值之间</td>
<td>&gt;&#x3D;min&amp;&amp;&lt;&#x3D;max</td>
</tr>
<tr>
<td>NOT BETWEEN</td>
<td>不在两值之间</td>
<td></td>
</tr>
<tr>
<td>IN</td>
<td>在集合中</td>
<td></td>
</tr>
<tr>
<td>NOT IN</td>
<td>不在集合中</td>
<td></td>
</tr>
<tr>
<td>&lt;&#x3D;&gt;</td>
<td>严格比较两个NULL值是否相等</td>
<td>两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0</td>
</tr>
<tr>
<td>LIKE</td>
<td>模糊匹配</td>
<td></td>
</tr>
<tr>
<td>REGEXP 或 RLIKE</td>
<td>正则式匹配</td>
<td></td>
</tr>
<tr>
<td>IS NULL</td>
<td>为空</td>
<td></td>
</tr>
<tr>
<td>IS NOT NULL</td>
<td>不为空</td>
<td></td>
</tr>
</tbody></table>
<p>●<strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th>运算符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>NOT 或 !</td>
<td>逻辑非</td>
</tr>
<tr>
<td>AND</td>
<td>逻辑与</td>
</tr>
<tr>
<td>OR</td>
<td>逻辑或</td>
</tr>
<tr>
<td>XOR</td>
<td>逻辑异或</td>
</tr>
</tbody></table>
<p>●<strong>位运算符</strong></p>
<table>
<thead>
<tr>
<th>运算符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>!</td>
<td>取反</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
</tr>
</tbody></table>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2023/02/01/MySQL1/">https://scholargeek.github.io/2023/02/01/MySQL1/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习2</title>
    <url>/2023/02/03/MySQL2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL进阶"><a href="#MySQL进阶" class="headerlink" title="MySQL进阶"></a>MySQL进阶</h1><p>　　本文将简述MySQL进阶查询基本语法，如 “AS用法”、“条件判断”、“限制结果条目”、“聚合函数”、“排序”、“分组统计”、“多表查询”。</p>
<span id="more"></span>

<h2 id="AS用法与条件替换"><a href="#AS用法与条件替换" class="headerlink" title="AS用法与条件替换"></a>AS用法与条件替换</h2><p>　　关键字AS用来设置别名。<br>●使用AS语句设置别名时，关键字AS可省略。<br>●设置别名时，保证不能与库中其他表或字段名起冲突。</p>
<p>　　条件判断(CASE WHEN XX THEN XX1 ELSE XX2 END)用于将结果集中的数据根据条件替换为指定字符。<br>●如果字段值XX为真，则返回结果XX1，否则返回结果XX2。</p>
<p><strong>例：</strong>查询地址为上海的员工姓名和性别，性别要求F显示为女而M显示为男。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 条件替换即若性别为F显示女否则显示男，将字段重命名为sex</span></span><br><span class="line"><span class="keyword">SELECT</span> ename,(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex<span class="operator">=</span><span class="string">&#x27;F&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">END</span>) <span class="keyword">AS</span> sex</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> address<span class="operator">=</span><span class="string">&#x27;上海&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="限制结果条目"><a href="#限制结果条目" class="headerlink" title="限制结果条目"></a>限制结果条目</h2><p>　　<code>LIMIT [offset,] number</code><br>　　LIMIT的第一个参数是位置偏移量（可选参数），即设置 MySQL 从哪一行开始显示，第二个参数是设置返回记录行的最大数目。<br>●offset作为可选参数，第一条记录的位置偏移量为0。<br>●返回SELECT查询结果的前几行或指定开始行显示条目数。</p>
<p><strong>例：</strong>查询学生表信息3-6行的姓名与年龄。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询3-6行数据即 偏移量为3-1，显示数量为6-3+1</span></span><br><span class="line"><span class="keyword">SELECT</span> stuName,stuAge</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line">LIMIT <span class="number">2</span>,<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>　　聚合函数是对表中数据记录进行集中概括而设计的一类函数，常用聚合函数有平均值、最大值、最小值、总和、计数等。<br>●avg(）返回指定列的平均值<br>●max(）返回指定列的最大值<br>●min(）返回指定列的最小值<br>●sum(）返回指定列的所有值之和<br>●count(）返回指定列中非NULL值的个数</p>
<p><strong>例：</strong>查询计算机专业学生最大年龄、最小年龄、平均年龄、总年龄、总人数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(stuAge),<span class="built_in">MIN</span>(stuAge),<span class="built_in">AVG</span>(stuAge),<span class="built_in">SUM</span>(stuAge),<span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> stuMajor<span class="operator">=</span><span class="string">&#x27;计算机&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="去重与条件NULL关键字"><a href="#去重与条件NULL关键字" class="headerlink" title="去重与条件NULL关键字"></a>去重与条件NULL关键字</h2><p>　　查询数据时若显示重复的行记录，删除重复行可在SELECT语句中使用DISTINCT子句。语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> columns</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> where_conditions;</span><br></pre></td></tr></table></figure>
<p><strong>例：</strong>查询所有的员工来自那些城市（不能重复显示地名且NULL不显示）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> city </span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> city <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>　　MySQL中处理NULL必须使用 IS NULL 和 IS NOT NULL 运算符。<br>　　MySQL使用 SQL SELECT 命令及 WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为 NULL 时，该命令可能就无法正常工作。为了处理这种情况，MySQL提供了三大运算符:<br>● IS NULL: 当列的值是 NULL,此运算符返回 true。<br>● IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。<br>● &lt;&#x3D;&gt;: 比较操作符（不同于 &#x3D; 运算符），当比较的的两个值相等或者都为 NULL 时返回 true。</p>
<h2 id="NULL条件函数"><a href="#NULL条件函数" class="headerlink" title="NULL条件函数"></a>NULL条件函数</h2><p>　　IF()、IFNULL()、NULLIF()、ISNULL()函数的使用。<br>●IF()函数<br><code>IF(expr1,expr2,expr3)</code><br>如果expr1的值为true，则返回expr2的值，如果expr1的值为false，则返回expr3的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IF(<span class="literal">TRUE</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>);    <span class="comment">-- 输出结果：A</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="literal">FALSE</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>);   <span class="comment">-- 输出结果：B</span></span><br></pre></td></tr></table></figure>
<p>●IFNULL()函数<br><code>IFNULL(expr1,expr2)</code><br>如果expr1的值为null，则返回expr2的值，如果expr1的值不为null，则返回expr1的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IFNULL(<span class="keyword">NULL</span>,<span class="string">&#x27;A&#x27;</span>);    <span class="comment">-- 输出结果：A</span></span><br><span class="line"><span class="keyword">SELECT</span> IFNULL(<span class="string">&#x27;HELLO&#x27;</span>,<span class="string">&#x27;A&#x27;</span>); <span class="comment">-- 输出结果：HELLO</span></span><br></pre></td></tr></table></figure>
<p>●NULLIF()函数<br><code>NULLIF(expr1,expr2)</code><br>如果expr1&#x3D;expr2成立，那么返回值为null，否则返回值为expr1的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;A&#x27;</span>);     <span class="comment">-- 输出结果：null</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>);     <span class="comment">-- 输出结果：A</span></span><br></pre></td></tr></table></figure>
<p>●ISNULL()函数<br><code>ISNULL(expr)</code><br>如果expr的值为null，则返回1，如果expr1的值不为null，则返回0。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ISNULL(<span class="keyword">NULL</span>);        <span class="comment">-- 输出结果：1</span></span><br><span class="line"><span class="keyword">SELECT</span> ISNULL(<span class="string">&#x27;HELLO&#x27;</span>);     <span class="comment">-- 输出结果：0</span></span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>　　按关键字排序查询数据时使用<code>ORDER BY</code>语句来实现排序。语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2,…</span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2,…<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>●排序可针对一个或多个字段<br>●ASC：升序，默认排序方式<br>●DESC：降序</p>
<p><strong>例：</strong>查询产品表所有信息，根据库存由小到大排列。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> productID,pName,price,pes</span><br><span class="line"><span class="keyword">FROM</span> product</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> pes <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
<h2 id="分组统计"><a href="#分组统计" class="headerlink" title="分组统计"></a>分组统计</h2><p>　　查询数据结果同时包括普通字段和聚合函数需进行分组统计，这时使用<code>GROUP BY</code>语句对结果进行分组。语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> column_name operator <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name;</span><br></pre></td></tr></table></figure>
<p>●通常结合聚合函数一起使用<br>●以按一个或多个字段对结果进行分组</p>
<p><strong>例：</strong>查询员工表每个专业的员工总人数，显示专业名称和总人数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> major,<span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> major</span><br></pre></td></tr></table></figure>
<p>　　HAVING子句的使用。在SELECT语句中使用HAVING子句来指定一组行或聚合的过滤条件。HAVING子句通常与GROUP BY子句一起使用，以根据指定的条件过滤分组。如果省略GROUP BY子句，则HAVING子句的行为与WHERE子句类似。<br>　　注意：HAVING子句将过滤条件应用于每组分行，而WHERE子句将过滤条件应用于每个单独的行。</p>
<p><strong>例：</strong>查询除北京外的每个城市的客户总人数，只显示1人以上的城市名称和总人数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cAddress,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> TotalNumber</span><br><span class="line"><span class="keyword">FROM</span> customer</span><br><span class="line"><span class="keyword">WHERE</span> cAddress<span class="operator">&lt;&gt;</span><span class="string">&#x27;北京&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> cAddress</span><br><span class="line"><span class="keyword">HAVING</span> TotalNumber<span class="operator">&gt;</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>　　多表查询常使用内连接即查询操作列出与连接条件匹配的数据行。语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 法1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> name(s) </span><br><span class="line"><span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name <span class="operator">=</span> table2.column_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 法2</span></span><br><span class="line"><span class="keyword">SELECT</span> T1.column1, T2.column2,…</span><br><span class="line"><span class="keyword">FROM</span> table_name1 <span class="keyword">AS</span> T1,table_name2 <span class="keyword">AS</span> T2,…</span><br><span class="line"><span class="keyword">WHERE</span> T1.column_keyname<span class="operator">=</span>T2.column_keyname</span><br></pre></td></tr></table></figure>
<p><strong>例：</strong>查询IOT2020班和IOT2022班的软件方向的班级名称和学生姓名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.bjname,s.stuName</span><br><span class="line"><span class="keyword">FROM</span> classes c,student s</span><br><span class="line"><span class="keyword">WHERE</span> c.bjid<span class="operator">=</span>s.bjid <span class="keyword">AND</span> c.bjname <span class="keyword">IN</span> (<span class="string">&#x27;IOT2020&#x27;</span>,<span class="string">&#x27;IOT2022&#x27;</span>) <span class="keyword">AND</span> s.stuMajor<span class="operator">=</span><span class="string">&#x27;软件&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h1 id="SQL查询方法"><a href="#SQL查询方法" class="headerlink" title="SQL查询方法"></a>SQL查询方法</h1><p>①搭建查询结构：<code>SELECT ... FROM ... WHERE ...</code><br>②找出需要查询的表名写在FROM后<br>③建立关系即将各表外键进行内连接<br>④将需求筛选条件写在WHERE后<br>⑤将需求显示的要素写在SELECT后</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2023/02/03/MySQL2/">https://scholargeek.github.io/2023/02/03/MySQL2/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习3</title>
    <url>/2023/02/05/MySQL3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL高级查询"><a href="#MySQL高级查询" class="headerlink" title="MySQL高级查询"></a>MySQL高级查询</h1><p>　　本文将简述MySQL高级查询基本语法，如 “常用日期函数”、“外连接查询”、“交叉连接”、“自查询”、“行列转换”。</p>
<span id="more"></span>

<h2 id="常用日期函数"><a href="#常用日期函数" class="headerlink" title="常用日期函数"></a>常用日期函数</h2><p>　　MySQL中的常用日期函数如下：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NOW()</td>
<td>返回当前的日期和时间</td>
</tr>
<tr>
<td>YEAR(d)</td>
<td>返回年份</td>
</tr>
<tr>
<td>QUARTER(d)</td>
<td>返回日期d是第几季节，返回 1 到 4</td>
</tr>
<tr>
<td>MONTH(d)</td>
<td>返回日期d中的月份值，1 到 12</td>
</tr>
<tr>
<td>WEEK(d)</td>
<td>计算日期 d 是本年的第几个星期，范围是 0 到 53</td>
</tr>
<tr>
<td>DAYOFMONTH(d)</td>
<td>计算日期 d 是本月的第几天</td>
</tr>
<tr>
<td>DAY(d)</td>
<td>返回日期值 d 的日期部分</td>
</tr>
<tr>
<td>HOUR(t)</td>
<td>返回 t 中的小时值</td>
</tr>
<tr>
<td>MINUTE(t)</td>
<td>返回 t 中的分钟值</td>
</tr>
<tr>
<td>SECOND(t)</td>
<td>返回 t 中的秒钟值</td>
</tr>
<tr>
<td>CURDATE()</td>
<td>返回当前的日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前的时间</td>
</tr>
<tr>
<td>DATE()</td>
<td>提取日期或日期&#x2F;时间表达式的日期部分</td>
</tr>
<tr>
<td>EXTRACT()</td>
<td>返回日期&#x2F;时间按的单独部分</td>
</tr>
<tr>
<td>DATE_ADD()</td>
<td>给日期添加指定的时间间隔</td>
</tr>
<tr>
<td>DATE_SUB()</td>
<td>从日期减去指定的时间间隔</td>
</tr>
<tr>
<td>DATEDIFF()</td>
<td>返回两个日期之间的天数</td>
</tr>
<tr>
<td>TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)</td>
<td>返回 datetime_expr2 − datetime_expr1 的时间差</td>
</tr>
<tr>
<td>DATE_FORMAT()</td>
<td>用不同的格式显示日期&#x2F;时间</td>
</tr>
</tbody></table>
<h2 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h2><p>　　外连接即合并具有同一列的两个以上的表的行，结果集中除了包含一个表与另一个表匹配的行之外，还查询到了左表或右表中不匹配的行。外连接又分为左外连接、右外连接、全连接。</p>
<p>●左外连接：两个表在连接过程中除了返回满足连接条件的行以外，还返回左表中不满足条件的行。<br>左外连接语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> a_table a <span class="keyword">left</span> <span class="keyword">join</span> b_table b <span class="keyword">on</span> a.a_id <span class="operator">=</span> b.b_id;</span><br></pre></td></tr></table></figure>
<p>●右外连接：两个表在连接过程中除了返回满足连接条件的行以外，还返回右表中不满足条件的行。<br>右外连接语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> a_table a <span class="keyword">right</span> <span class="keyword">join</span> b_table b <span class="keyword">on</span> a.a_id <span class="operator">=</span> b.b_id;</span><br></pre></td></tr></table></figure>
<p>●全连接：两个表在连接过程中除了返回满足连接条件的行以外，还返回左表和右表中不满足条件的行。(MySQL暂不支持这种语句，不过可使用union将两个结果集“堆一起”，利用左连接，右连接分两次将数据取出，然后用union将数据合并去重。)<br>列如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> a_table a <span class="keyword">left</span> <span class="keyword">join</span> b_table b <span class="keyword">on</span> a.a_id <span class="operator">=</span> b.b_id;</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> a_table a <span class="keyword">right</span> <span class="keyword">join</span> b_table b <span class="keyword">on</span> a.a_id <span class="operator">=</span> b.b_id;</span><br></pre></td></tr></table></figure>
<p><strong>例：</strong>查询所有的班级及学生信息，没有学生的班级也显示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 左外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> c.bjname,s.stuName</span><br><span class="line"><span class="keyword">FROM</span> classes c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student s <span class="keyword">ON</span> c.bjid<span class="operator">=</span>s.bjid</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 右外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> c.bjname,s.stuName</span><br><span class="line"><span class="keyword">FROM</span> student s <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> classes c <span class="keyword">ON</span> s.bjid<span class="operator">=</span>c.bjid</span><br></pre></td></tr></table></figure>
<h2 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h2><p>　　交叉连接即返回两个表的笛卡尔乘积，作用就是计算两个表之间每个可能的组合，结果集中的记录数等于两张表各自记录数的乘积。一般使用<code>CROSS JOIN</code>连接两张表进行交叉连接。<br>语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> T1 <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> T2</span><br></pre></td></tr></table></figure>
<p><strong>例：</strong>假设每个学生都学习每门必修课，显示学生和课程名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.stuName,c.cname</span><br><span class="line"><span class="keyword">FROM</span> student s <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> course c</span><br></pre></td></tr></table></figure>
<p><strong>例：</strong>用笛卡儿积查询所有学生姓名、课程名称及分数，将没有成绩的分数显示为0分。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.stuName,c.cname,IFNULL(g.score,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">FROM</span> student s <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> course c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> grade g</span><br><span class="line"><span class="keyword">ON</span> s.stuId<span class="operator">=</span>g.stuid <span class="keyword">AND</span> c.cid<span class="operator">=</span>g.cid</span><br></pre></td></tr></table></figure>
<h2 id="自查询"><a href="#自查询" class="headerlink" title="自查询"></a>自查询</h2><p>　　某些情况下需要对一张表内的数据进行对比，获得各列层次关系，而通过一般的SQL写法，可能需要通过写多个子查询的方式才能解决，但用自连接查询可以轻松解决。自连接查询是指使用表的别名实现表与其自身连接的查询方法。</p>
<p><strong>例：</strong>在学生表中查询李得胜同学的同乡有哪些人。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s2.stuName</span><br><span class="line"><span class="keyword">FROM</span> student s1,student s2</span><br><span class="line"><span class="keyword">WHERE</span> s1.stuAddress<span class="operator">=</span>s2.stuAddress <span class="keyword">AND</span> s1.stuName<span class="operator">=</span><span class="string">&#x27;李得胜&#x27;</span> <span class="keyword">AND</span> s2.stuName<span class="operator">&lt;&gt;</span><span class="string">&#x27;李得胜&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="行列转换"><a href="#行列转换" class="headerlink" title="行列转换"></a>行列转换</h2><p>　　实际应用中可能需要把表的某些行转换成列，或者把列转换成行的情况。如下图例：<br><img src="https://s3.bmp.ovh/imgs/2024/04/07/aab8645dd982edbc.png" alt="SQL行列转换例子"></p>
<p><strong>例：</strong>查询学生姓名课程和成绩并行列转换，使用<code>case ...  when  ... then ... else ... end</code>方法解如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,<span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> course<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">THEN</span> score <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> &quot;软件工程&quot;,</span><br><span class="line">            <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> course<span class="operator">=</span><span class="string">&#x27;计算机技术&#x27;</span> <span class="keyword">THEN</span> score <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> &quot;计算机技术&quot;,</span><br><span class="line">            <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> course<span class="operator">=</span><span class="string">&#x27;物联网工程&#x27;</span> <span class="keyword">THEN</span> score <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> &quot;物联网工程&quot;</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> name</span><br></pre></td></tr></table></figure>


<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2023/02/05/MySQL3/">https://scholargeek.github.io/2023/02/05/MySQL3/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell简介</title>
    <url>/2018/08/28/Shell/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="壳层简介"><a href="#壳层简介" class="headerlink" title="壳层简介"></a>壳层简介</h1><p>　　Shell（壳层）在计算机科学中指“为用户提供用户界面”的软件，通常指的是命令行界面的解析器。一般来说是指操作系统中提供访问内核所提供之服务的程序。Shell也用于泛指所有为用户提供操作界面的程序，也就是程序和用户交互的层面。</p>
<span id="more"></span>

<p>　　通常将shell分为两类：命令行与图形界面。命令行壳层提供一个命令行界面（CLI）；而图形壳层提供一个图形用户界面（GUI）。<br><img src="https://s3.bmp.ovh/imgs/2024/01/26/b91b5c427a937cb0.png" alt="Shell层次图"><br>　　在Linux中Shell是一个用C语言编写的程序,它是用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言。Shell作为一种应用程序提供了一个界面，用户可以通过这个界面访问操作系统内核的服务。</p>
<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>　　壳层（shell）这个说法起源于路易斯·普赞(Louis Pouzin)，在1964年至1965年间首次提出，随后在Multics（MULTiplexed Information and Computing System）项目中首次被实现出来。<br>　　Unix上的第一个Unix壳层（Unix shell）是肯·汤普逊（Ken Thompson）以Multics上的shell为范本，所写出的Thompson shell。<br>　　微软Windows操作系统也提供了命令行壳层的功能。如Windows 95 &#x2F; 98下的command.com、Windows NT内核下的cmd.exe以及PowerShell；而图形界面壳层即为explorer.exe。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/08/28/Shell/">https://scholargeek.github.io/2018/08/28/Shell/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习4</title>
    <url>/2023/02/07/MySQL4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p>　　数据库设计指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。<br>　　数据库设计的目标：是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境 。数据库设计的基本任务：是根据用户的信息需求、处理需求和数据库的支持环境(包括硬件、操作系统和DBMS)，设计出数据库模式(包括外模式、逻辑模式和内模式)及其典型的应用程序。</p>
<span id="more"></span>

<h2 id="数据库设计的方法"><a href="#数据库设计的方法" class="headerlink" title="数据库设计的方法"></a>数据库设计的方法</h2><p>●直观设计法（手工试凑发）：数据库设计只是一种经验的反复实施，而不能称为是一门科学，缺乏科学分析理论基础和工程手段的支持，因为设计质量与设计人员的经验和水平有直接关系，所以设计质量很难保证。具有周期短、效率高、操作简便、易于实现等优点。主要是用于简单小型系统。<br>●规范设计法：将数据库设计分为若干阶段，明确规定各阶段的任务，采用“自顶向下、分层实现、逐步求精”的设计原则，结合数据库理论和软件工程设计方法，实现设计过程的每一细节，最终完成整个设计任务。（新奥尔良方法、基于E-R模型的数据库设计方法、基于3NF（第三范式）的设计方法、面向对象的数据库设计方法、统一建模语言（UML）方法）。<br>●计算机辅助设计法：在数据库设计的某些过程中，利用计算机和一些辅助设计工具，模拟某一规范设计方法，并以人的知识或经验为主导，通过人机交互方式实现设计中的某些部分。 （Oracle 公司开发的 Designer、Sybase公司开发的 PowerDesigner）。</p>
<h2 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h2><p>●需求分析：通过详细调查现实世界要处理的对象（组织、部门、企业等），充分了解原系统（手工系统或计算机系统）工作概况，明确用户的各种需求。<br>●概念结构设计：通过对用户需求进行综合、归纳与抽象，形成一个独立于具体数据库管理系统的概念模型。<br>●逻辑结构设计：将概念结构转换为某个数据库管理系统所支持的数据模型，并对其进行优化。<br>●物理结构设计：为逻辑数据结构选取一个最适合应用环境的物理结构,包括存储结构和存取方法。<br>●数据库实施：根据逻辑设计和物理设计的结果构建数据库,编写与调试应用程序,组织数据入库并进行试运行。<br>●数据库运行和维护：经过试运行后即可投入正式运行,在运行过程中必须不断对其进行评估、调整与修改。</p>
<p>★需求分析和概念设计独立于任何数据库管理系统<br>★逻辑设计和物理设计与选用的数据库管理系统密切相关<br><img src="https://s3.bmp.ovh/imgs/2024/04/08/2eba9052bf218f7b.png" alt="数据库设计流程"></p>
<h3 id="设计具体步骤"><a href="#设计具体步骤" class="headerlink" title="设计具体步骤"></a>设计具体步骤</h3><p>　　①收集信息：与该系统有关的人员进行交流，充分理解数据库需要完成的任务。<br>　　②标识对象：标识实体(Entity)<br>　　③标识每个实体的属性：标识各实体所含有的基本要素<br>　　④标识对象之间的关系：若为(1:N)一对多的关系，在多的实体表内建立外键与一的实体主键相连；若为(N:N)多对多的关系，则需建立一张桥表并将多的两张表中主键放入桥表作为外键，在桥表中新建ID作为主键。</p>
<h3 id="绘制E-R图"><a href="#绘制E-R图" class="headerlink" title="绘制E-R图"></a>绘制E-R图</h3><p>　　ER图分为实体、属性、关系三个核心部分。在ER图中，实体是长方形，属性是椭圆形，关系为菱形。绘制E-R图的步骤如下：<br>　　①确定所有的实体集合；<br>　　②选择实体集应包含的属性；<br>　　③确定实体集之间的联系；<br>　　④确定实体集的关键字，用下划线在属性上表明关键字的属性组合；<br>　　⑤确定联系的类型，在用线将表示联系的菱形框联系到实体集时，在线旁注明是1或n(多）来表示联系的类型。</p>
<h3 id="E-R图转换为表"><a href="#E-R图转换为表" class="headerlink" title="E-R图转换为表"></a>E-R图转换为表</h3><p>　　①将各个实体转换为对应的表名<br>　　②将各属性转换为各表对应的字段<br>　　③分析各个实体之间的关系确定主键与外键<br>　　④在各表之间建立主外键关系，实现实体间的联系</p>
<h2 id="数据库规范化"><a href="#数据库规范化" class="headerlink" title="数据库规范化"></a>数据库规范化</h2><p>　　数据库规范化又称正规化、标准化。是数据库设计的一系列原理和技术，以减少数据库中数据冗余，增进数据的一致性。关系模型的发明者埃德加·科德最早提出这一概念，并于1970年代初定义了第一范式、第二范式和第三范式的概念，还与Raymond F. Boyce于1974年共同定义了第三范式的改进范式——BC范式。除外还包括针对多值依赖的第四范式，连接依赖的第五范式、DK范式和第六范式。现在数据库设计最多满足3NF，普遍认为范式过高，虽然具有对数据关系更好的约束性，但也导致数据关系表增加而令数据库IO更易繁忙，原来交由数据库处理的关系约束现更多在数据库使用程序中完成。</p>
<p>●1NF: 第一范式：确保每列的原子性，即每列都是不可再分的最小数据单元（字段原子性）<br>●2NF: 第二范式：满足第一范式，且除主键外的其他列都依赖于主键。<br>●3NF: 第三范式：满足第二范式，且非主键字段不能依赖于其它非主键字段，即非主键字段间不能有传递依赖关系。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2023/02/07/MySQL4/">https://scholargeek.github.io/2023/02/07/MySQL4/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>日志二</title>
    <url>/2019/07/19/%E5%BF%97%E4%BA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>若你惘然若失，也可瞥见不羁的空间。<br>若你不堪回首，也可领会自在的神思。<br>若你心无旁骛，也可探寻奋力的结果。<br>虽然你仍未看破，所有迷惑皆等你破解。<br>虽然你会存怀疑，所有可能皆等你实现。<br>我的博客在这里，它是我的另一种存在!</p>
<span id="more"></span>

<p>If you lose, you can also glimpse the unruly space.<br>If you can’t look back, you can also grasp the mind of your self-confessedness.<br>If you are not happy, you can also explore the results of hard work.<br>Although you still haven’t seen it, all the confusion is waiting for you to crack it.<br>Although you will have doubts, all may be waiting for you to achieve.<br>My blog is here and it’s another existence of mine!</p>
<p><a href="http://scholargeek.top/">http://scholargeek.top/</a></p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/19/%E5%BF%97%E4%BA%8C/">https://scholargeek.github.io/2019/07/19/%E5%BF%97%E4%BA%8C/</a></p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>日志一</title>
    <url>/2019/07/16/%E5%BF%97%E4%B8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>若你自由自在，必可看见美好的空间。<br>若你沉默寡言，必可感受寂静的心灵。<br>若你心有所属，必可明白付出的价值。<br>即使你仍不明白，一切未知皆等你探索。<br>即使你会存偏见，一切真相皆等你发现。<br>这里是我的博客，也是我的另一面!</p>
<span id="more"></span>

<p>If you are free, you will see the beautiful space.<br>If you are silent, you will feel the silent heart.<br>If your heart has its own, you will understand the value of the pay.<br>Even if you still don’t understand, all the unknowns wait for you to explore.<br>Even if you are prejudiced, all the truth will be found.<br>Here is my blog, and it’s the other side of me!</p>
<p><a href="https://scholargeek.github.io/">https://scholargeek.github.io/</a></p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/16/%E5%BF%97%E4%B8%80/">https://scholargeek.github.io/2019/07/16/%E5%BF%97%E4%B8%80/</a></p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/08/28/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="快速入门-Quick-Start"><a href="#快速入门-Quick-Start" class="headerlink" title="快速入门[Quick Start]"></a>快速入门[Quick Start]</h2><h3 id="创建新帖子-Create-a-new-post"><a href="#创建新帖子-Create-a-new-post" class="headerlink" title="创建新帖子[Create a new post]"></a>创建新帖子[Create a new post]</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>更多信息: <a href="https://hexo.io/docs/writing.html">写作</a></p>
<h3 id="运行服务器-Run-server"><a href="#运行服务器-Run-server" class="headerlink" title="运行服务器[Run server]"></a>运行服务器[Run server]</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>更多信息: <a href="https://hexo.io/docs/server.html">服务器</a></p>
<h3 id="生成静态文件-Generate-static-files"><a href="#生成静态文件-Generate-static-files" class="headerlink" title="生成静态文件[Generate static files]"></a>生成静态文件[Generate static files]</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>更多信息: <a href="https://hexo.io/docs/generating.html">生成</a></p>
<h3 id="部署到远程站点-Deploy-to-remote-sites"><a href="#部署到远程站点-Deploy-to-remote-sites" class="headerlink" title="部署到远程站点[Deploy to remote sites]"></a>部署到远程站点[Deploy to remote sites]</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>更多信息: <a href="https://hexo.io/docs/deployment.html">部署</a></p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/08/28/hello-world/">https://scholargeek.github.io/2018/08/28/hello-world/</a></p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客文章——博客的搭建</title>
    <url>/2019/07/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Scholar的博客搭建"><a href="#Scholar的博客搭建" class="headerlink" title="Scholar的博客搭建"></a>Scholar的博客搭建</h1><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world !"></a>Hello world !</h2><p>由于互联网与计算机技术的迅猛发展使得个人博客的搭建门槛直线降低，方便易用的开发工具与框架代码使得一切如此简单。<br>本文将简述博客如何搭建</p>
<span id="more"></span>

<h2 id="一、环境的搭建"><a href="#一、环境的搭建" class="headerlink" title="一、环境的搭建"></a>一、环境的搭建</h2><p>使用的硬件环境为：64位电脑<br>使用的软件环境为：Windows10家庭中文版，node.js(基于 Chrome V8 引擎的 JavaScript 运行环境)、git与Hexo框架，来搭建属于自己的博客。<br>使用工具node.js的下载：<a href="https://nodejs.org/en/%EF%BC%88%E9%80%89%E6%8B%A9LTS%E7%89%88%E6%9C%AC%EF%BC%89">https://nodejs.org/en/（选择LTS版本）</a><br>默认安装即可，截图如下：<img src="/images/pasted-0.png"> </p>
<p>一路Next，完全安装后，再使用Power shell验证安装是否成功。Win+R键入Power shell中，输入node -v回显版本号，输入npm -v回显版本号。截图如下：<img src="/images/pasted-1.png"><br>接着使用npm工具（Node.js 平台的默认包管理工具）下载淘宝维护的npm镜像即cnpm，在Power shell中，<br>输入npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a><br>回车后即开始下载，完成后如图：<img src="/images/pasted-2.png"> </p>
<p>接着验证cnpm是否存在，在Power shell中，输入cnpm -v将会回显路径等信息，截图如下：<br> <img src="/images/pasted-3.png"><br>如果存在，那么可以使用cnpm来下载Hexo框架，<br>即在Power shell中，输入cnpm install -g hexo-cli回车即开始下载，完成后截图如下：<br> <img src="/images/pasted-4.png"><br>接着验证Hexo框架是否存在，在Power shell中，输入hexo -v回车即可回显版本号。截图如下：<br> <img src="/images/pasted-5.png"><br>为了使用init初始化命令而不报错需要安装git（分布式版本控制系统），那么现在开始安装git吧！<br>首先进入git官网<a href="https://git-scm.com/">https://git-scm.com/</a><br>选择与自己电脑对应的版本，进行下载即可。<br>安装截图如下：<br><img src="/images/pasted-6.png"><br>选择NEXT<br><img src="/images/pasted-7.png"><br>自定义安装位置<br> <img src="/images/pasted-8.png"><br>选择关联文件<br> <img src="/images/pasted-9.png"><br>默认路径及选择是否不要创建开始菜单<br> <img src="/images/pasted-10.png"><br>默认选择vim作为git的编辑器<br> <img src="/images/pasted-11.png"><br>默认选择使用git命令的工具<br> <img src="/images/pasted-12.png"><br>默认使用OpenSSL来加密HTTP传输的信息<br> <img src="/images/pasted-13.png"><br>选择提交代码的风格为默认<br> <img src="/images/pasted-14.png"><br>使用minTTY为git的终端<br>一路NEXT直到Install<br> <img src="/images/pasted-15.png"><br>默认不开启实验功能，选择Install即可安装。<br> <img src="/images/pasted-16.png"><br>选择Finish即可完成安装<br>为了使得PowerShell可以使用git命令，需关闭Powershell并重启。<br>接着在自定义的目录中创建用于存储blog框架的文件夹(D:\Program file\blog)<br>然后在PowerShell中输入：<br>cd “D:\Program file\blog”  &#x2F;&#x2F;进入文件夹<br>hexo init   &#x2F;&#x2F;初始化博客框架<br>截图如下：<br> <img src="/images/pasted-17.png"><br>这样Hexo博客框架已经初始化完成。<br>输入ls查看目录下生成的文件，截图如下：<br> <img src="/images/pasted-18.png"><br>   输入hexo s即可启动博客框架，截图如下：<br> <img src="/images/pasted-19.png"><br>这样在本地就启动了hexo博客，在游览器地址栏中输入：<a href="http://localhost:4000/">http://localhost:4000</a> 即可打开自动生成的博客，如果要停止服务在Powershell中按Ctrl+C即可。<br>在本地游览器中的显示截图如下：<br> <img src="/images/pasted-20.png"><br>至此博客在本地已搭建完成，接着就是对博客的编辑。</p>
<h2 id="二、博客的编辑"><a href="#二、博客的编辑" class="headerlink" title="二、博客的编辑"></a>二、博客的编辑</h2><p>在Powershell中输入：<br>hexo n “ My first blog post “<br>即在D:\Program file\blog\source_posts目录下创建了一个名为” My first blog post “的Markdown格式的文件，接着你可以手动打开这个文件，推荐使用Yu Writer对其进行编辑，当然Typora也是个不错的选择。</p>
<p>使用hexo clean命令可以清除缓存文件<br>使用hexo g 命令可以生成静态网页文件<br>使用hexo s命令可以开启服务</p>
<p>更新后的游览器截图如下：<br> <img src="/images/pasted-21.png"> 
 </p>
<h2 id="三、将博文部署至远端"><a href="#三、将博文部署至远端" class="headerlink" title="三、将博文部署至远端"></a>三、将博文部署至远端</h2><p>在已注册好的Github中创建仓库项目，设置域名为：<br>如图：<img src="/images/pasted-22.png"> </p>
<p>选择Create repository继续<br>在Powershell下输入:<br>cnpm install –save hexo-deployer-git    &#x2F;&#x2F;安装git插件<br>安装成功后截图如下：<br> <img src="/images/pasted-23.png"> </p>
<p>然后ls查看文件，使用编辑器对_config.yml文件进行编辑<br>添加如下内容：<br>type:git<br>  repo:<a href="https://github.com/scholargeek/scholargeek-.github.io.git">https://github.com/scholargeek/scholargeek-.github.io.git</a><br>  branch:master<br>保存即可。<br>接着在Powershell下输入：<br>git config –global user.email “<a href="mailto:&#121;&#111;&#x75;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#x6f;&#109;">&#121;&#111;&#x75;&#x40;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#x6f;&#109;</a>“<br>git config –global user.name “Your Name”<br>注：<br>将<a href="mailto:&#121;&#111;&#117;&#64;&#x65;&#120;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#109;">&#121;&#111;&#117;&#64;&#x65;&#120;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#109;</a>替换为在GitHub上注册的邮箱<br>将Your Name替换为GitHub上注册的用户名</p>
<p>最后可以在Powershell下输入hexo d 就可以将博客上传至github服务器上。<br>回到Github的仓库管理页，刷新即可查看上传的文件。<br>验证网络服务可以直接在游览器中输入<a href="https://scholargeek.github.io/">https://scholargeek.github.io/</a> 查看博客网页。</p>
<h2 id="四、下载主题"><a href="#四、下载主题" class="headerlink" title="四、下载主题"></a>四、下载主题</h2><p>在Powershell下输入git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes&#x2F;yilia<br>即可将yilia主题下载至D:\Program file\blog\themes\yilia文件夹下。<br>编辑_config.yml文件，设置主题theme: landscape，将landscape替换为yilia，即可更换主题。</p>
<p>如果下载主题时出现以下错误：<br> <img src="/images/pasted-24.png"><br>则需设置缓存区的大小<br>在Powershell下输入：git config –global http.postBuffer 524288000<br>再次输入：<br>git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes&#x2F;yilia即可</p>
<p>其他主题推荐：<br>git clone -b master <a href="https://github.com/Molunerfinn/hexo-theme-melody">https://github.com/Molunerfinn/hexo-theme-melody</a> themes&#x2F;melody</p>
<p>注：使用下载的命令需进入blog目录执行</p>
<h2 id="五、编辑及修改主题"><a href="#五、编辑及修改主题" class="headerlink" title="五、编辑及修改主题"></a>五、编辑及修改主题</h2><p>可以在 D:\Program file\blog_config.yml 中修改大部分的配置，参数如下：<br>#Site<br>title: Scholar’s Blog               &#x2F;&#x2F;网站标题<br>subtitle: Welcome to my blog!     &#x2F;&#x2F;网站副标题<br>description: Geek Style           &#x2F;&#x2F;网站的描述<br>keywords:<br>author: DSL                  &#x2F;&#x2F;作者<br>language: zh-cn             &#x2F;&#x2F;使用的语言<br>timezone: Asia&#x2F;Shanghai     &#x2F;&#x2F;网站的时区<br>#Extensions<br>##Plugins: <a href="https://hexo.io/plugins/">https://hexo.io/plugins/</a><br>##Themes: <a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>theme: landscape      &#x2F;&#x2F;使用的主题为默认的landscape，可将landscape修改为yilia，<br>&#x2F;&#x2F;保存即完成主题的更换</p>
<h2 id="六、使用Hexo-Admin插件让编辑博客更简单"><a href="#六、使用Hexo-Admin插件让编辑博客更简单" class="headerlink" title="六、使用Hexo Admin插件让编辑博客更简单"></a>六、使用Hexo Admin插件让编辑博客更简单</h2><p>在Powershell下进入blog目录下输入：npm install –save hexo-admin<br>安装完成后启动服务，在浏览器地址栏中输入网址:localhost:4000&#x2F;admin，即可对所有的博客进行管理何编辑。<br>为了能为添加图片，首先配置好D:\Program file\blog_config.yml文件，将post_asset_folder:false中false替换为为true，再在Powershell下进入blog目录下输入：<br>npm install hexo-asset-image –save     &#x2F;&#x2F;安装image工具<br>安装完成截图如下：<br><img src="/images/pasted-25.png"></p>
<p>这样就可以使用</p>
<p>在Powershell中常用的命令：<br>hexo clean  &#x2F;&#x2F;清除缓存与静态网页<br>hexo g     &#x2F;&#x2F;生成静态网页<br>hexo s     &#x2F;&#x2F;开启本地预览服务<br>hexo d    &#x2F;&#x2F;推送到远端的网络服务器中</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2019/07/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/">https://scholargeek.github.io/2019/07/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习</title>
    <url>/2018/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><pre><code>“数据结构”这门学科形成和发展的背景：自1946年第一台计算机问世以来，计算机产业的飞速发展已远远超出人们对它的预料，在某些生产线上，甚至几秒钟就能产出一台微型计算机，常量猛增，价格低廉，使得它的应用范围迅速扩展。如今，计算机已深入到人类社会的各个领域。
</code></pre>
<span id="more"></span>
<p>计算机的应用已不再局限于科学计算，而更多地用于控制，管理及数据处理等非数值计算的处理工作。与此相应，计算机加工处理的对象由纯粹的数值发展到字符、表格和图像等各种具有一定结构的数据，这就给程序设计带来一些新问题。为编写出一个“好”的程序，必须分析待处理的对象的特征以及各处理对象之间存在的关系。<br>用计算机解决一个具体问题时，大致需要经过下列几个步骤：首先要从具体问题抽象出一个适当的数字模型，然后设计一个解此数学模型的算法，最后编出程序，进行测试，调整直至得到最终解答。寻求数学模型的实质是分析问题，从中提取操作的对象，并找出这些操作对象之间含有的关系，然后用数学的语言加以描述。<br>简单来说，数据结构是一门研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作 等的学科。<br>可以认为“数据结构”是介于数学、计算机硬件和计算机软件三者之间的一门核心课程。</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/01/26/8b0116a955ec5a2a.png" alt="数据结构所处地位"></p>
<p>“数据结构”的概念起源于1968年美国计算机科学家 唐纳德·克努特(Donald Ecvin Knuth)教授所著的《计算机程序设计艺术》(The Art of Computer Programming)。在该书的第一卷《基本算法》中，他开创了数据结构的最初体系，较系统地阐述了数据的逻辑结构和存储结构及其操作。<br>在计算机科学中，研究数据结构对设计出高性能的算法和软件至关重要。数据结构课程不仅是程序设计的基础，而且是设计和实现编译程序、操作系统、数据库系统及其他应用程序的重要基础。</p>
<h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><p>数据(date)是对客观事物的符号表示，在计算机科学中指所有能输入到计算机中并被计算机程序处理的符号的总称。它是计算机程序加工的“原料”。<br>数据元素(data element)是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。<br>数据对象(data object)是性质相同的元素的集合，是数据的一个子集。<br>数据结构(data structure)是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素之间的关系称为*结构(Structure)*。 数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。</p>
<h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。</p>
<h3 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h3><p>存储结构是指数据结构在计算机中的表示(又称印象)，也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。</p>
<h3 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h3><p>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p>
<p>不存在只体现存储结构而不体现逻辑结构的表述，所以可以认为：逻辑结构独立于存储结构。</p>
<p>数据类型：是一个值的集合和定义在这个值集上的一组操作的总称。<br>抽象数据类型(Abstract Data Type,简称 ADT):指一个数学模型以及在该模型上的一组操作。</p>
<h2 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法(algorithm)是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作；此外算法还具有下列5个重要特性：<br>(1)有穷性。一个算法必须总是(对于任何合法的输入值)在执行有穷步之后结束，且每一步都可在有穷时间内完成。<br>(2)确定性。算法中每一条指令必须确切的含义，读者理解时不会产生二义性。并且，在任何条件下，算法只有唯一的一条执行路径，即对于相同的输入只能得出相同的输出。<br>(3)可行性。一个算法是可行的，即算法中描述的操作都是可以通过实现的基本运算执行有限次来实现的。<br>(4)输入。一个算法有零个或多个输入，这些输入取自于某特定的对象的集合。<br>(5)输出。一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量。</p>
<h3 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h3><p>(1)正确性。算法应能够正确地解决求解问题。<br>(2)可读性。算法应具有良好的可读性，以帮助人们理解。<br>(3)健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。<br>(4)效率与底存储量需求。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。</p>
<h3 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h3><p>算法效率的度量是通过时间复杂度和空间复杂度来描述的。</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为T(n)，它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。<br>算法中基本运算(最深层循环内的语句)的频度与T(n)同数量级，因此通常采用基本运算的频度f(n)来分析算法的时间复杂度。因此，算法的时间复杂度记为 T(n)&#x3D;O(f(n))<br>式中，O的含义是T(n)的数量级，其严格的数学定义是：若T(n)和f(n)是定义在正整数集合上的两个函数，则存在正常数C和n_0	 ,使得当n&gt;&#x3D; n_0时，都满足0&lt;&#x3D;T(n)&lt;&#x3D;Cf(n)</p>
<p>最坏时间复杂度是指在最坏情况下，算法的时间复杂度。<br>平均时间复杂度是指所有可能输入实列在等概率出现的情况下，算法的期望运行时间。<br>最好时间复杂度是指在最好情况下，算法的时间复杂度。</p>
<p>在分析一个程序的时间复杂性时，有以下两条规则：<br>(a)加法规则 T(n)&#x3D;T_1(n)+T_2(n) &#x3D; O(f(n))+O(g(n)) &#x3D; O(max(f(n),g(n)))<br>(b)乘法规则 T(n)&#x3D;T_1(n)×T_2(n) &#x3D; O(f(n))×O(g(n)) &#x3D; O(f(n)×g(n))</p>
<p>常见的渐进时间复杂度为<br>O(1)&lt;O(log_2 n)&lt;O(n)&lt;O(nlog_2 n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)<br>记法：常对幂指阶</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它是问题规模n的函数。记作 S(n) &#x3D; O(f(n))<br>一个程序在执行时需要存储空间来存放本身所用的指令，常数、变量和输入数据外，还需要一些对于数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。<br>若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。<br>算法原地工作是指 算法 所需的辅助空间 为常量，即O(1)。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2018/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/">https://scholargeek.github.io/2018/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>考研日志二</title>
    <url>/2022/12/28/%E8%80%83%E7%A0%94%E5%BF%97%E4%BA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于考研失利，我的心境从低落恢复到正常，花费了几个月时间。这段时间是我人生最灰暗的时光，服用了药物后才渐渐好转。我在脑海中无数次构想考研的过程与结果，期望我能总结经验，争取上岸。当我再次选定考研目标院校时，非常无奈的选择了西北的学校，我定了个较低的目标；但却非常纠结，因为这和我当初励志离开西北的想法不同，但现在却为了上岸妥协了初衷，我无颜面对当初的自己。在无数个日夜中我不断纠结，看着时光流逝感到无奈，深感对自我掌控力的不足。<br>与过去复习过程类似，有种搬苞谷的感觉，怀疑不断打击着自信，直到把理想摧垮。后来逐渐发现考研需要的不仅是理想，考研需要的更是信念。唯有坚定的信念才能抵御困难的打击，只有不屈的意志才能克服险隘的阻挡。</p>
<pre><code>下定决心，排除万难。
</code></pre>
<span id="more"></span>
<p>我为何考研？这个问题我曾思考了许久，因为我想弥补高考的失败，因为我想提高专业能力，因为我想有更广阔的未来。总之，我想无论成败我都要去考，不遗余力的考，不顾一切的考。<br>时间来到2022年12月，由于新冠疫情的影响，石城已封闭了3个月，现在逐渐解封，但却造成许多人患上了新冠奥密克戎。我正好在考前一天发烧，无奈地考虑到即使去了考场也无法完成考试，便放弃了，当了逃兵。到这里我心心念念的考研就告一段落了，我想我还没有一次全力以赴的参考，这就是我的遗憾吧。当有人问起我这些年的考研成绩，我只能说我正在准备中，希望我在新的一年中全力以赴，争取给自己一个满意的结果。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2022/12/28/%E8%80%83%E7%A0%94%E5%BF%97%E4%BA%8C/">https://scholargeek.github.io/2022/12/28/%E8%80%83%E7%A0%94%E5%BF%97%E4%BA%8C/</a></p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>PostgraduateEntranceExamination</tag>
      </tags>
  </entry>
  <entry>
    <title>考研日志一</title>
    <url>/2021/12/28/%E8%80%83%E7%A0%94%E5%BF%97%E4%B8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记得我大一时励志一定要考研，但在学校蹉跎岁月，很长时间都无法准备。考研这个想法长时间停留在我的脑海中，我不知道自己是否有实力和毅力面对这场人生大考，但我仍想尝试。毕竟考研如同小马过河，在没有尝试过之前没人知道水深水浅。其实在大学的最后一年中，我也观察了许多考研人的努力；有浅尝辄止的，有反复无常的，也有全力以赴的；我最多算浅尝辄止的，面对困难和机遇我愧对大一时的自己。记得我跨入大学校门的那一天，我曾经发下的誓言，我背负的耻辱，我无颜面对曾经的自己。在即将毕业的这段时间，我十分痛苦纠结，没什么准备的参加了20考研专业课考试，题会的不多，我已然抱着看题目的心态面对这场考试。之后无奈走入工作岗位，但我仍然心系考研，看着一年又一年的考研人入场，不断壮大的考研人数，我知道以后的考研只会更难。<br>    2020年考研人数为341万；2021年考研人数为377万；2022年考研人数为457万；······</p>
<span id="more"></span>
<p>我在国家银行的工作随着不断学习也越发得心应手，但对未来的焦虑也与日俱增。我迫切的想提升学历，于是重新开始制定考研的计划，在单位的宿舍中我不断的搜索资料，希望能找到合适的院校，最后将目标定在了西南的一所知名院校。后来搬回到家中我买了考研所需的资料，在工作之余尽量复习，虽然我制定了计划，但复习进度不如人意。我时而积极时而颓丧，工作和考研不断调和，我不知道该专心工作还是该专心考研，无论我怎么做都像在逃避什么。如果我专心工作那么考研该怎么办？若我专心考研那么我工作该怎么办？我反复纠结，拿不定主意，最后将焦虑诉说给父母，这就把选择权交了出去，最后听了我妈的建议为考研放弃工作，全心全意备战考研。其实我已经开始习惯了工作的状态，当我交出辞职报告时还是有些纠结，但木已成舟时我忽然轻松了不少，只是略微有些留恋。故事到了这应该即刻出现夜以继日、废寝忘食的学习画面，但实际从工作状态切换到完全学习的状态的确不易。<br><img src="https://s3.bmp.ovh/imgs/2023/01/25/3b976ba2b4e38616.png" alt="2022考研计划"><br>在家复习的那段时光，让我认清自己，承认自己是迟钝的、无知的、无畏的。我曾励志考研，现在机会就摆在面前，我却犹豫。复习初始的状态当然很好，但随着时间的流逝我就陷入了焦虑和自责中。我开始在复习时间走神，回忆，被动的回忆，不由自主的回忆。可能我才认识到过去的半年是我人生最重要的时刻，从开始到未来。我可能才意识到，我的内心世界是如此活跃，但身体上却感到很疲倦，不想动弹。回想从前的工作，如同被驯化的工具，我已然内心抗拒。离职后我的情绪在变化，觉得自己在逼自己，但我已然也必然走出了关键性的一步，无论是否坚定，但这一切是真实的。<br>现实的我已然坠落，我要向上攀爬，无论面对什么，都要有自我。或许我怀念轻松的时光，但为了梦想而且还要挣脱现实，又怎能轻松。况且从来的轻松只是暂时的，又不可预知。为了心甘情愿的走过这漫漫人生路，为了更加美好的一切。不必自责，不必怀念，不必幻想，因为人只活在当下。唯有把握现在，才能塑造将来。我想既已如此，只有现在的我可以再次证明，证明我仍是可塑的，我要做我心中的那个人，不负此生。虽然生命中总有许多缺憾，但我仍相信事在人为，做我要做的。心中有力量，就无惧挑战；倘若成功，必是美好。<br>    你是谁？是你本身的想法决定的，而非做了什么决定了你是谁。<br>在复习期间母亲身体抱恙，虽然我没有表现出什么，但我心里却十分担心，希望她一切都好。说回我自己，考前一个月我已经无法安然入睡，甚至有了抑郁的情绪，纷乱的思绪使我痛苦，我知道自己复习的成果无法达到预期。在考试当天压抑的情绪使我出现了胸痛的情况，我忍着疼痛完成了考试，虽然我预料到考试成绩不会理想，可能无法接受这种结果，最终抑郁。在我人生最难熬的时候，父母给了我最大的支持，使我的精神状态渐渐恢复到正常。反复思量后我决定再战，我不信我考不上，或许就是这种不服输的勇气让我开始了2022年的复习之旅。但只有勇气是不够的，我还需要毅力，希望我能给自己一个满意的交代。</p>
<hr>
<p><strong>版权声明</strong></p>
<p><img src="/images/cc.png"></p>
<p><a href="https://scholargeek.github.io/">Scholar’s Blog</a> by <a href="https://scholargeek.github.io/About/">scholargeek</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0 International License</a>.<br>由<a href="https://scholargeek.github.io/About/">董仕麟</a>创作并维护的<a href="https://scholargeek.github.io/">scholargeek</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="https://scholargeek.github.io/">Scholar’s Blog</a>博客，版权所有，侵权必究。</p>
<p>本文永久链接：<a href="https://scholargeek.github.io/2021/12/28/%E8%80%83%E7%A0%94%E5%BF%97%E4%B8%80/">https://scholargeek.github.io/2021/12/28/%E8%80%83%E7%A0%94%E5%BF%97%E4%B8%80/</a></p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>PostgraduateEntranceExamination</tag>
      </tags>
  </entry>
</search>
